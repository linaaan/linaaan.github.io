<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JavaScript进阶</title>
      <link href="/2021/11/16/JavaScript%E8%BF%9B%E9%98%B6/"/>
      <url>/2021/11/16/JavaScript%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="DOM简单学习：为了满足案例要求"><a href="#DOM简单学习：为了满足案例要求" class="headerlink" title="DOM简单学习：为了满足案例要求"></a>DOM简单学习：为了满足案例要求</h1><ul><li><p>功能：控制html文档的内容</p></li><li><p>获取页面标签（元素）对象：Element</p><ul><li><code>document.getElementById(&quot;id值&quot;)</code>:通过元素的id获取元素对象</li></ul></li><li><p>操作Element对象：</p><ol><li>修改属性值：<ol><li>明确获取的对象是哪一个</li><li>查看API文档，找该对象有哪些属性可以设置 img.src=…</li></ol></li><li>修改标签体内容：<ul><li>属性：innerHTML<ol><li>获取元素对象</li><li>使用innerHTML属性修改标签体内容 title.innerHTML=…</li></ol></li></ul></li></ol></li></ul><h1 id="事件简单学习"><a href="#事件简单学习" class="headerlink" title="事件简单学习"></a>事件简单学习</h1><ul><li><p>功能： 某些组件被执行了某些操作后，触发某些代码的执行。</p><ul><li>造句：  xxx被xxx,我就xxx<ul><li>我方水晶被摧毁后，我就责备对友。</li><li>敌方水晶被摧毁后，我就夸奖自己。</li></ul></li></ul></li><li><p>如何绑定事件</p><ol><li><p>直接在html标签上，指定事件的属性(操作)，属性值就是js代码</p><ol><li>事件：onclick— 单击事件</li></ol></li><li><p>通过js获取元素对象，指定事件属性，设置一个函数</p></li></ol><ul><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;  onclick=&quot;fun();&quot;&gt; //方法1</span><br><span class="line">  &lt;img id=&quot;light2&quot; src=&quot;img/off.gif&quot;&gt; // 方法2</span><br><span class="line">  </span><br><span class="line">  &lt;script&gt;</span><br><span class="line">      function fun()&#123;</span><br><span class="line">          alert(&#x27;我被点了&#x27;);</span><br><span class="line">          alert(&#x27;我又被点了&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      function fun2()&#123;</span><br><span class="line">          alert(&#x27;咋老点我？&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      //1.获取light2对象</span><br><span class="line">      var light2 = document.getElementById(&quot;light2&quot;);</span><br><span class="line">      //2.绑定事件</span><br><span class="line">      light2.onclick = fun2;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ul><p>  注意什么时候用<code>fun()</code>，什么时候用fun，加引号是”<code>fun()</code>“，不加引号是fun<br>  <strong>DOM获取对象必须在对象创建之后才可以获取！！但是方法可以在调用前定义也可以在调用后定义</strong><br>  如果方法之中存在DOM获取对象，那么这个方法最好也是在创建对象之后再调用</p></li><li><p>案例1：电灯开关</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;电灯开关&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;img id=&quot;light&quot; src=&quot;img/off.gif&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    /*</span><br><span class="line">        分析：</span><br><span class="line">            1.获取图片对象</span><br><span class="line">            2.绑定单击事件</span><br><span class="line">            3.每次点击切换图片</span><br><span class="line">                * 规则：</span><br><span class="line">                    * 如果灯是开的 on,切换图片为 off</span><br><span class="line">                    * 如果灯是关的 off,切换图片为 on</span><br><span class="line">                * 使用标记flag来完成</span><br><span class="line"></span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">    //1.获取图片对象</span><br><span class="line">    var light = document.getElementById(&quot;light&quot;);</span><br><span class="line"></span><br><span class="line">    var flag = false;//代表灯是灭的。 off图片</span><br><span class="line"></span><br><span class="line">    //2.绑定单击事件</span><br><span class="line">    light.onclick = function()&#123;</span><br><span class="line">        if(flag)&#123;//判断如果灯是开的，则灭掉</span><br><span class="line">            light.src = &quot;img/off.gif&quot;;</span><br><span class="line">            flag = false;</span><br><span class="line"></span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            //如果灯是灭的，则打开</span><br><span class="line"></span><br><span class="line">            light.src = &quot;img/on.gif&quot;;</span><br><span class="line">            flag = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p><strong>debug需要在浏览器按F12，在console观察错误</strong></p><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h1><ol><li><p>概念：Browser Object Model 浏览器对象模型</p><ul><li>将浏览器的各个组成部分封装成对象。</li></ul></li><li><p>组成：</p><ul><li>Window：窗口对象</li><li>Navigator：浏览器对象</li><li>Screen：显示器屏幕对象</li><li>History：历史记录对象</li><li>Location：地址栏对象</li></ul><p> 还有一个document对象，因为很重要，单独划分为DOM对象</p></li><li><p>Window：窗口对象</p><ol><li><p>创建</p></li><li><p>方法</p><ol><li><p>与弹出框有关的方法：</p><ul><li><code>alert()</code>    显示带有一段消息和一个确认按钮的警告框。</li><li><code>confirm()</code>    显示带有一段消息以及确认按钮和取消按钮的对话框。<ul><li>如果用户点击确定按钮，则方法返回true</li><li>如果用户点击取消按钮，则方法返回false</li></ul></li><li><code>prompt()</code>    显示可提示用户输入的对话框。<ul><li>返回值：获取用户输入的值</li></ul></li></ul></li><li><p>与打开关闭有关的方法：</p><ul><li><code>close()</code>    关闭浏览器窗口。<ul><li>谁调用我 ，我关谁</li></ul></li><li><code>open()</code>    打开一个新的浏览器窗口<ul><li>返回新的Window对象，可以<code>open(&quot;网址&quot;)</code></li></ul></li></ul></li><li><p>与定时器有关的方式</p><ul><li><p><code>setTimeout()</code>    在指定的毫秒数后调用函数或计算表达式。</p><ul><li>参数：<ol><li>js代码或者方法对象</li><li>毫秒值</li></ol></li><li>返回值：唯一标识，用于取消定时器</li></ul></li><li><p><code>clearTimeout()</code>    取消由 <code>setTimeout()</code> 方法设置的 timeout，参数为目标定时器的返回值。</p></li><li><p><code>setInterval()</code>    按照指定的周期（以毫秒计）来调用函数或计算表达式。</p></li><li><p><code>clearInterval()</code>    取消由 <code>setInterval()</code> 设置的 timeout。</p></li></ul></li></ol></li><li><p>属性：</p><ol><li>获取其他BOM对象：<br> history  window.history或者history<br> location<br> Navigator<br> Screen:</li><li>获取DOM对象<br> document</li></ol></li><li><p>特点</p><ul><li>Window对象不需要创建可以直接使用 window使用。 <code>window.方法名()</code>;</li><li>window引用可以省略。  <code>方法名()</code>;</li></ul></li></ol></li></ol><ol start="4"><li><p>Location：地址栏对象</p><ol><li><p>创建（获取）：</p><ol><li>window.location</li><li>location</li></ol></li><li><p>方法：</p><ul><li><code>reload()</code>    重新加载当前文档。刷新</li></ul></li><li><p>属性</p><ul><li>href    设置或返回完整的 URL。<br>设计函数触发location.href=”目标网址”，可以进行页面跳转</li></ul></li></ol></li></ol><ol start="5"><li><p>History：当前页面的历史记录对象（不是当前浏览器的）</p><ol><li><p>创建（获取）：</p><ol><li>window.history</li><li>history</li></ol></li><li><p>方法：</p><ul><li><code>back()</code>    加载 history 列表中的前一个 URL。</li><li><code>forward()</code>    加载 history 列表中的下一个 URL。</li><li><code>go(参数)    </code>加载 history 列表中的某个具体页面。<ul><li>参数：<ul><li>正数：前进几个历史记录</li><li>负数：后退几个历史记录</li></ul></li></ul></li></ul></li><li><p>属性：</p><ul><li>length    返回当前窗口历史列表中的 URL 数量。</li></ul></li></ol></li></ol><h1 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h1><ul><li><p>概念： Document Object Model 文档对象模型</p><ul><li>将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作</li></ul></li><li><p>W3C DOM 标准被分为 3 个不同的部分：</p><ul><li><p>核心 DOM - 针对任何结构化文档的标准模型</p><ul><li><p>Document：文档对象</p></li><li><p>Element：元素对象</p></li><li><p>Attribute：属性对象</p></li><li><p>Text：文本对象</p></li><li><p>Comment:注释对象</p></li><li><p>Node：节点对象，其他5个的父对象</p></li></ul></li><li><p>XML DOM - 针对 XML 文档的标准模型</p></li><li><p>HTML DOM - 针对 HTML 文档的标准模型</p></li></ul></li></ul><h2 id="核心DOM模型："><a href="#核心DOM模型：" class="headerlink" title="核心DOM模型："></a>核心DOM模型：</h2><ul><li><p>Document：文档对象</p><ol><li>创建（获取）：在html dom模型中可以使用window对象来获取<ol><li>window.document</li><li>document</li></ol></li><li>方法：<ol><li>获取Element对象：<ol><li><code>getElementById()</code>    ： 根据id属性值获取元素对象。id属性值一般唯一</li><li><code>getElementsByTagName()</code>：根据元素名称获取元素对象们。返回值是一个数组</li><li><code>getElementsByClassName()</code>:根据Class属性值获取元素对象们。返回值是一个数组</li><li><code>getElementsByName()</code>: 根据name属性值获取元素对象们。返回值是一个数组</li></ol></li><li>创建其他DOM对象：<br><code> createAttribute(name)</code><br><code>createComment()</code><br><code>createElement()</code><br><code>createTextNode()</code></li></ol></li><li>属性</li></ol></li><li><p>Element：元素对象</p><ol><li>获取/创建：通过document来获取和创建</li><li>方法：<ol><li><code>removeAttribute()</code>：删除属性</li><li><code>setAttribute()</code>：设置属性<br><code>a.setAttribute(&quot;href&quot;,&quot;https://www.baidu.com&quot;)</code><br>给a设置一个超链接属性<br><code>href=&quot;javascript:void(0);&quot; </code> 保留可以被点击的样式，但不可以进行页面跳转</li></ol></li></ol></li><li><p>Node：节点对象，其他5个的父对象</p><ul><li>特点：<strong>所有dom对象都可以被认为是一个节点</strong>，如表格，行，列，字符串等都是节点</li><li>方法：<ul><li>CRUD dom树：<ul><li><code>appendChild()</code>：向节点的子节点列表的结尾添加新的<strong>子节点</strong>。</li><li><code>removeChild()</code>    ：删除（并返回）当前节点的指定<strong>子节点</strong>。 <code>father.removeChild(child);</code></li><li><code>replaceChild()</code>：用新节点替换一个子节点。</li></ul></li></ul></li><li>属性：<ul><li>parentNode 返回节点的父节点。</li></ul></li></ul></li></ul><h2 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h2><ol><li>标签体的<strong>设置</strong>和<strong>获取</strong>：innerHTML  <code>&lt;div&gt;111&lt;/div&gt;</code>  div.innerHTML获取的就是111</li><li>使用html元素对象的属性</li><li>控制元素样式<ol><li>使用元素的style属性来设置，类似于css<br>如： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//修改样式方式1</span><br><span class="line">  div1.style.border = &quot;1px solid red&quot;;</span><br><span class="line">  div1.style.width = &quot;200px&quot;;</span><br><span class="line">  //font-size--&gt; fontSize</span><br><span class="line">  div1.style.fontSize = &quot;20px&quot;;</span><br></pre></td></tr></table></figure></li><li>提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。<br><code>div.className = &quot;d1&quot;</code></li></ol></li></ol><h1 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h1><ul><li>概念：某些组件被执行了某些操作后，触发某些代码的执行。    <ul><li>事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了</li><li>事件源：组件。如： 按钮 文本输入框…</li><li>监听器：代码。</li><li>注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。</li></ul></li></ul><ul><li><p>常见的事件：</p><ol><li><p>点击事件：</p><ol><li>onclick：单击事件</li><li>ondblclick：双击事件</li></ol></li><li><p>焦点事件</p><ol><li>onblur：失去焦点</li><li>onfocus:元素获得焦点。</li></ol></li><li><p>加载事件：</p><ol><li>onload：一张页面或一幅图像完成加载。</li></ol></li><li><p>鼠标事件：</p><ol><li>onmousedown    鼠标按钮被按下。</li><li>onmouseup    鼠标按键被松开。</li><li>onmousemove    鼠标被移动。</li><li>onmouseover    鼠标移到某元素之上。</li><li>onmouseout    鼠标从某元素移开。</li></ol></li><li><p>键盘事件：</p><ol><li>onkeydown    某个键盘按键被按下。    </li><li>onkeyup        某个键盘按键被松开。</li><li>onkeypress    某个键盘按键被按下并松开。</li></ol></li><li><p>选择和改变</p><ol><li>onchange    域的内容被改变。</li><li>onselect    文本被选中。</li></ol></li><li><p>表单事件：</p><ol><li>onsubmit    确认按钮被点击。</li><li>onreset    重置按钮被点击。</li></ol></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础</title>
      <link href="/2021/11/09/JavaScript%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/11/09/JavaScript%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript概念："><a href="#JavaScript概念：" class="headerlink" title="JavaScript概念："></a>JavaScript概念：</h1><p>和Java语法接近，但JAVA和JavaScript实际上关系不大</p><ul><li><p>概念：    一门客户端脚本语言</p><ul><li>运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</li><li>脚本语言：不需要编译，直接就可以被浏览器解析执行了</li></ul></li><li><p>功能：</p><ul><li>可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</li><li>JavaScript = ECMAScript + JavaScript自己特有的东西（BOM+DOM）</li></ul></li></ul><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>ECMAScript：客户端脚本语言的标准</p><h2 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h2><ol><li><p>与html结合方式</p><ol><li><p>内部JS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 定义&lt;script&gt;，标签体内容就是js代码</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></li><li><p>外部JS：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 定义&lt;script&gt;，通过src属性引入外部的js文件</span><br><span class="line">&lt;script src=&quot;js/a.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>注意：<ol><li><code>&lt;script&gt;</code>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。</li><li><code>&lt;script&gt;</code>可以定义多个。</li></ol></li></ul></li><li><p>注释</p><ol><li>单行注释：//注释内容</li><li>多行注释：/<em>注释内容</em>/</li></ol></li><li><p>数据类型：</p><ol><li>原始数据类型（基本数据类型）：<ol><li>number：数字。 整数/小数/NaN（not a number 一个不是数字的数字类型）</li><li>string：字符串。 字符串  “abc” “a” ‘abc’</li><li>boolean: true和false</li><li>null：一个对象为空的占位符</li><li>undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</li></ol></li><li>引用数据类型：对象（基本对象 BOM DOM）</li></ol></li><li><p>变量</p><ul><li>变量：一小块存储数据的内存空间</li><li>Java语言是强类型语言，而JavaScript是弱类型语言。<ul><li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</li><li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</li></ul></li><li>语法：<ul><li>var 变量名 = 初始化值;</li></ul></li><li>typeof()运算符：获取变量的类型。<ul><li>注：null运算后得到的是object</li></ul></li></ul></li><li><p>运算符</p><ol><li><p>一元运算符：只有一个运算数的运算符<br> ++，- - ， +（正号）  </p><ul><li>++ - -: 自增（自减）<ul><li>++（- -） 在前，先自增（自减），再运算</li><li>++（- -） 在后，先运算，再自增（自减）</li></ul></li><li>+（-）：正负号<ul><li>注意：<strong>在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换</strong><ul><li>其他类型转number：<ul><li>string转number：按照字面值转换,”123”=&gt;123。如果字面值不是数字，则转为NaN（不是数字的数字）。”anc”=&gt;NaN</li><li>boolean转number：true转为1，false转为0</li></ul></li></ul></li></ul></li></ul></li><li><p>算数运算符<br><code>+ - * / % ...</code></p></li><li><p>赋值运算符<br>= += -+….</p></li><li><p>比较运算符</p><blockquote><p>&lt; &gt;= &lt;= == ===（全等于）</p></blockquote><ul><li>比较方式<ol><li>类型相同：直接比较<ul><li>字符串：按照字典顺序比较（a&gt;b）。按位逐一比较，直到得出大小为止。</li></ul></li><li>类型不同：先进行类型转换，再比较<ul><li>===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</li></ul></li></ol></li></ul></li><li><p>逻辑运算符<br>&amp;&amp; || !</p><ul><li>其他类型转boolean：<ol><li>number：0或NaN为假，其他为真</li><li>string：除了空字符串(“”)，其他都是true</li><li>null&amp;undefined:都是false</li><li>对象：所有对象都为true</li></ol></li></ul></li><li><p>三元运算符<br>? : 表达式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 3;</span><br><span class="line">    var b = 4;</span><br><span class="line"></span><br><span class="line">    var c = a &gt; b ? 1:0;</span><br></pre></td></tr></table></figure></li></ol><ul><li>语法：<ul><li>表达式? 值1:值2;</li><li>判断表达式的值，如果是true则取值1，如果是false则取值2；</li></ul></li></ul></li><li><p>流程控制语句：</p><ol><li>if…else…</li><li>switch:<ul><li>在java中，switch语句的case值可以接受的数据类型： byte int short char,枚举（1.5） ,String（1.7）<ul><li>switch（变量）:<br>case 值:</li></ul></li><li>在JS中,switch语句的case值可以接受任意的原始数据类型</li></ul></li><li>while</li><li>do…while</li><li>for</li></ol></li><li><p>JS特殊语法：</p><ol><li>语句以 ; 结尾，如果一行只有一条语句则 ;可以省略 （不建议）</li><li>变量的定义使用var关键字，也可以不使用<ul><li>用： 定义的变量是局部变量</li><li>不用：定义的变量是全局变量（不建议）</li></ul></li></ol></li></ol><h3 id="练习：99乘法表"><a href="#练习：99乘法表" class="headerlink" title="练习：99乘法表"></a>练习：99乘法表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;99乘法表&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        td&#123;</span><br><span class="line">            border: 1px solid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line"></span><br><span class="line">        document.write(&quot;&lt;table  align=&#x27;center&#x27;&gt;&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //1.完成基本的for循环嵌套，展示乘法表</span><br><span class="line">        for (var i = 1; i &lt;= 9 ; i++) &#123;</span><br><span class="line">            document.write(&quot;&lt;tr&gt;&quot;);</span><br><span class="line">            for (var j = 1; j &lt;=i ; j++) &#123;</span><br><span class="line">                document.write(&quot;&lt;td&gt;&quot;);</span><br><span class="line"></span><br><span class="line">                //输出  1 * 1 = 1</span><br><span class="line">                document.write(i + &quot; * &quot; + j + &quot; = &quot; + ( i*j) +&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;);</span><br><span class="line"></span><br><span class="line">                document.write(&quot;&lt;/td&gt;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            /*//输出换行</span><br><span class="line">            document.write(&quot;&lt;br&gt;&quot;);*/</span><br><span class="line"></span><br><span class="line">            document.write(&quot;&lt;/tr&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //2.完成表格嵌套</span><br><span class="line">        document.write(&quot;&lt;/table&gt;&quot;);</span><br><span class="line"></span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="基本对象："><a href="#基本对象：" class="headerlink" title="基本对象："></a>基本对象：</h2><ol><li><p>Function：函数（方法）对象</p><ol><li><p>创建：</p><ol><li><p><code>var fun = new Function(形式参数列表,方法体)</code>;  //忘掉吧</p></li><li><p>形式二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function 方法名称(形式参数列表)&#123;</span><br><span class="line">      方法体</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>形式三</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var 方法名 = function(形式参数列表)&#123;</span><br><span class="line">      方法体</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>方法：</p></li><li><p>属性：<br> length:代表形参的个数 fun.length</p></li><li><p>特点：</p><ol><li>方法定义时，形参的类型不用写,返回值类型也不写。</li><li>方法是一个对象，如果定义名称相同的方法，会覆盖</li><li>在JS中，方法的调用只与方法的名称有关，和参数列表无关（即有两个参数，只给一个参数赋值，另一个参数不管，系统会默认赋值该参数为undefined，仍可以成功调用方法）</li><li>在方法声明中有一个隐藏的内置对象（数组）arguments,封装所有的实际参数，可以在方法内部调用arguments</li></ol></li><li><p>调用：<br> 方法名称（实际参数列表）;</p></li></ol></li><li><p>Array:数组对象</p><ol><li>创建：<ol><li><code>var arr = new Array(元素列表)</code>;</li><li><code>var arr = new Array(默认长度)</code>;</li><li><code>var arr = [元素列表]</code>;</li></ol></li><li>方法<br> <code>join(分隔符)</code>:将数组中的元素按照指定的分隔符拼接为字符串 <code>arr.join(&quot;--&quot;)</code><br> <code>push()</code>:    向数组的末尾添加一个或更多元素，并返回新的长度。</li><li>属性<br> length:数组的长度</li><li>特点：<ol><li>JS中，数组元素的类型可变的。</li><li>JS中，数组长度可变的。</li></ol></li></ol></li><li><p>Boolean</p></li><li><p>Date：日期对象</p><ol><li><p>创建：<br> <code>var date = new Date()</code>;</p></li><li><p>方法：<br> <code>toLocaleString()</code>：返回当前date对象对应的时间本地字符串格式<br> <code>getTime()</code>:获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</p></li></ol></li><li><p>Math：数学对象</p><ol><li><p>创建：</p><ul><li>特点：Math对象不用创建，直接使用。  <code>Math.方法名()</code>;</li></ul></li><li><p>方法：<br> <code>random()</code>:返回 0 ~ 1 之间的随机数。 含0不含1<br> <code>ceil(x)</code>：对数进行上舍入。<br> <code>floor(x)</code>：对数进行下舍入。<br> <code>round(x)</code>：把数四舍五入为最接近的整数。</p></li><li><p>属性：<br> PI Math.PI</p></li></ol></li><li><p>Number</p></li><li><p>String</p></li><li><p>RegExp：正则表达式对象</p><ol><li><p>正则表达式：<strong>定义字符串的组成规则</strong>。</p><ol><li><p>单个字符:[]<br>如： [a] [ab] [a-zA-Z0-9_]</p><ul><li>特殊符号代表特殊含义的单个字符:<br>\d:单个数字字符 [0-9]<br>\w:单个单词字符[a-zA-Z0-9_]</li></ul></li><li><p>量词符号：</p><ul><li>?：表示出现0次或1次</li><li>*：表示出现0次或多次</li><li>+：出现1次或多次</li><li>{m,n}:表示 m&lt;= 数量 &lt;= n<ul><li>m如果缺省： {,n}:最多n次</li><li>n如果缺省：{m,} 最少m次<br>\w{6,12}</li></ul></li></ul></li><li><p>开始结束符号</p><ul><li>^:开始</li><li>$:结束</li></ul></li></ol></li><li><p>正则对象：</p><ol><li>创建<ol><li><code>var reg = new RegExp(&quot;正则表达式&quot;)</code>;<br><code>var reg = new RegExp(&quot;^\\w(6,12)$&quot;)</code><br>字符串里防止转义，需要\</li><li><code>var reg = /正则表达式/</code>;<br><code>var reg = /^\w(6,12)$/</code></li></ol></li><li>方法    <ul><li><code>test(参数)</code>:验证指定的字符串是否符合正则定义的规范    <code>reg.test(字符串)</code></li></ul></li></ol></li></ol></li><li><p>Global</p><ol><li><p>特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  <code>方法名()</code>;</p></li><li><p>方法：</p><ul><li><p><code>encodeURI()</code>:url编码</p></li><li><p><code>var encode = encodeURI(str)</code></p></li><li><p><code>decodeURI()</code>:url解码</p></li><li><p><code>encodeURIComponent()</code>:url编码,编码的字符更多</p></li><li><p><code>decodeURIComponent()</code>:url解码</p></li><li><p><code>parseInt()</code>:将字符串转为数字<br>逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number,后边不是数字的不转换也不显示<br>123abc =&gt; 123</p></li><li><p><code>isNaN()</code>:判断一个值是否是NaN<br>NaN六亲不认，连自己都不认。NaN参与的==比较全部为false<br>NaN == NaN =&gt; false</p></li><li><p><code>eval()</code>:将 JavaScript 字符串，并把它作为脚本代码来执行。</p></li><li><p><code>eval(&quot;alert(123)&quot;)</code> =&gt; 执行<code>alert(123)</code></p></li></ul></li><li><p>URL编码<br>传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</p></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2021/11/02/CSS/"/>
      <url>/2021/11/02/CSS/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS基本概念"><a href="#CSS基本概念" class="headerlink" title="CSS基本概念"></a>CSS基本概念</h1><p>页面美化和布局控制</p><ol><li><p>概念： Cascading Style Sheets 层叠样式表</p><ul><li>层叠：多个样式可以作用在同一个html的元素上，同时生效</li></ul></li><li><p>好处：</p><ol><li>功能强大</li><li>将内容展示和样式控制分离<ul><li>降低耦合度。解耦</li><li>让分工协作更容易</li><li>提高开发效率</li></ul></li></ol></li></ol><h1 id="CSS的使用"><a href="#CSS的使用" class="headerlink" title="CSS的使用"></a>CSS的使用</h1><p>CSS与html结合方式</p><ol><li>内联样式<ul><li>在标签内使用style属性指定css代码</li><li>如：<code>&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;</code></li></ul></li><li>内部样式<ul><li>在head标签内，定义style标签，style标签的标签体内容就是css代码</li><li>如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">        div&#123;</span><br><span class="line">            color:blue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div&gt;hello css&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li>外部样式<ol><li>定义css资源文件。新建一个css文件夹，存放css文件</li><li>在head标签内，定义link标签，引入外部的资源文件<ul><li>如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  * a.css文件：</span><br><span class="line">  div&#123;</span><br><span class="line">      color:green;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br><span class="line">&lt;div&gt;hello css&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><ul><li>注意：<ul><li>1,2,3种方式 css作用范围越来越大</li><li><strong>1方式不常用，后期常用2,3</strong></li><li>第3种格式可以写为：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">      @import &quot;css/a.css&quot;;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="css语法："><a href="#css语法：" class="headerlink" title="css语法："></a>css语法：</h2><ul><li>格式：<br>选择器 {<br>  属性名1:属性值1;<br>  属性名2:属性值2;<br>  …<br>}</li><li>选择器:筛选具有相似特征的元素</li><li>注意：<ul><li>每一对属性需要使用；隔开，最后一对属性可以不加；</li></ul></li></ul><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><p>：筛选具有相似特征的元素</p><ul><li><p>分类：</p><ol><li><p>基础选择器</p><ol><li><p>id选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一</p><ul><li>语法：#id属性值{}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#div1&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;div1&quot;&gt;你好&lt;/div&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>元素选择器：选择具有相同标签名称的元素，例如所有div标签</p><ul><li>语法： 标签名称{}</li><li>注意：id选择器优先级高于元素选择器</li></ul></li><li><p>类选择器：选择具有相同的class属性值的元素。</p><ul><li>语法：.class属性值{}</li><li>注意：类选择器选择器优先级高于元素选择器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.cls1&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;cls1&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p>扩展选择器：</p><ol><li><p>选择所有元素：</p><ul><li>语法： *{}</li></ul></li><li><p>并集选择器：</p><ul><li>选择器1,选择器2{}</li></ul></li><li><p>子选择器：筛选选择器1元素下的所有选择器2</p><ul><li>语法：  选择器1 选择器2{}</li></ul></li><li><p>父选择器：筛选属于选择器1<strong>子元素</strong>的所有选择器2</p><ul><li>语法：  选择器1 &gt; 选择器2{}</li></ul></li><li><p>属性选择器：选择元素名称，属性名=属性值的元素</p><ul><li>语法：  <code>元素名称[属性名=&quot;属性值&quot;]&#123;&#125;</code><br>  <code>input[type=&quot;text&quot;]&#123;...&#125;</code></li></ul></li><li><p>伪类选择器：选择一些元素具有的状态</p><ul><li>语法： 元素:状态{}<br>如： <code>a:状态&#123;&#125;</code></li><li>状态：<ul><li>link：初始化的状态（超链接还没有被访问）</li><li>visited：被访问过的状态</li><li>active：正在访问状态（例如超链接按住不松手）</li><li>hover：鼠标悬浮状态</li></ul></li></ul></li></ol></li></ol></li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol><li><p>字体、文本</p><ul><li>font-size：字体大小</li><li>color：文本颜色</li><li>text-align：对其方式</li><li>line-height：行高 </li></ul></li><li><p>背景</p><ul><li><code>background：url(...)</code></li></ul></li><li><p>边框</p><ul><li>border：设置边框，复合属性<br>border：1px solid red</li></ul></li><li><p>尺寸</p><ul><li>width：宽度</li><li>height：高度</li></ul></li><li><p>盒子模型：控制布局</p><ul><li><p>margin：外边距</p></li><li><p>padding：内边距</p><ul><li>默认情况下内边距会影响整个盒子的大小</li><li>box-sizing: border-box;  设置盒子的属性，让width和height就是最终盒子的大小，此时内边距不再影响盒子的大小</li></ul></li><li><p>float：浮动</p><ul><li>left</li><li>right</li></ul></li></ul></li></ol><h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;注册页面&lt;/title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0px;</span><br><span class="line">        padding: 0px;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">    &#125;</span><br><span class="line">    body&#123;</span><br><span class="line">        background: url(&quot;img/register_bg.png&quot;) no-repeat center;</span><br><span class="line">        padding-top: 25px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .rg_layout&#123;</span><br><span class="line">        width: 900px;</span><br><span class="line">        height: 500px;</span><br><span class="line">        border: 8px solid #EEEEEE;</span><br><span class="line">        background-color: white;</span><br><span class="line">        /*让div水平居中*/</span><br><span class="line">        margin: auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .rg_left&#123;</span><br><span class="line">        /*border: 1px solid red;*/</span><br><span class="line">        float: left;</span><br><span class="line">        margin: 15px;</span><br><span class="line">    &#125;</span><br><span class="line">    .rg_left &gt; p:first-child&#123;</span><br><span class="line">        color:#FFD026;</span><br><span class="line">        font-size: 20px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .rg_left &gt; p:last-child&#123;</span><br><span class="line">        color:#A6A6A6;</span><br><span class="line">        font-size: 20px;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    .rg_center&#123;</span><br><span class="line">        float: left;</span><br><span class="line">        /* border: 1px solid red;*/</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .rg_right&#123;</span><br><span class="line">        /*border: 1px solid red;*/</span><br><span class="line">        float: right;</span><br><span class="line">        margin: 15px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .rg_right &gt; p:first-child&#123;</span><br><span class="line">        font-size: 15px;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    .rg_right p a &#123;</span><br><span class="line">        color:pink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .td_left&#123;</span><br><span class="line">        width: 100px;</span><br><span class="line">        text-align: right;</span><br><span class="line">        height: 45px;</span><br><span class="line">    &#125;</span><br><span class="line">    .td_right&#123;</span><br><span class="line">        padding-left: 50px ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #username,#password,#email,#name,#tel,#birthday,#checkcode&#123;</span><br><span class="line">        width: 251px;</span><br><span class="line">        height: 32px;</span><br><span class="line">        border: 1px solid #A6A6A6 ;</span><br><span class="line">        /*设置边框圆角*/</span><br><span class="line">        border-radius: 5px;</span><br><span class="line">        padding-left: 10px;</span><br><span class="line">    &#125;</span><br><span class="line">    #checkcode&#123;</span><br><span class="line">        width: 110px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #img_check&#123;</span><br><span class="line">        height: 32px;</span><br><span class="line">        vertical-align: middle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #btn_sub&#123;</span><br><span class="line">        width: 150px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        background-color: #FFD026;</span><br><span class="line">        border: 1px solid #FFD026 ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;rg_layout&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;rg_left&quot;&gt;</span><br><span class="line">        &lt;p&gt;新用户注册&lt;/p&gt;</span><br><span class="line">        &lt;p&gt;USER REGISTER&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;rg_center&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;rg_form&quot;&gt;</span><br><span class="line">            &lt;!--定义表单 form--&gt;</span><br><span class="line">            &lt;form action=&quot;#&quot; method=&quot;post&quot;&gt;</span><br><span class="line">                &lt;table&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;password&quot;&gt;密码&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;email&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;请输入邮箱&quot;&gt;&lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;name&quot;&gt;姓名&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; placeholder=&quot;请输入姓名&quot;&gt;&lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;tel&quot;&gt;手机号&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;tel&quot; id=&quot;tel&quot; placeholder=&quot;请输入手机号&quot;&gt;&lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td class=&quot;td_left&quot;&gt;&lt;label&gt;性别&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                        &lt;td class=&quot;td_right&quot;&gt;</span><br><span class="line">                            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男</span><br><span class="line">                            &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;birthday&quot;&gt;出生日期&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;date&quot; name=&quot;birthday&quot; id=&quot;birthday&quot; placeholder=&quot;请输入出生日期&quot;&gt;&lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td class=&quot;td_left&quot;&gt;&lt;label for=&quot;checkcode&quot; &gt;验证码&lt;/label&gt;&lt;/td&gt;</span><br><span class="line">                        &lt;td class=&quot;td_right&quot;&gt;&lt;input type=&quot;text&quot; name=&quot;checkcode&quot; id=&quot;checkcode&quot; placeholder=&quot;请输入验证码&quot;&gt;</span><br><span class="line">                            &lt;img id=&quot;img_check&quot; src=&quot;img/verify_code.jpg&quot;&gt;</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;input type=&quot;submit&quot; id=&quot;btn_sub&quot; value=&quot;注册&quot;&gt;&lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/table&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/form&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div class=&quot;rg_right&quot;&gt;</span><br><span class="line">        &lt;p&gt;已有账号?&lt;a href=&quot;#&quot;&gt;立即登录&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>效果图<br><img src="https://img12.360buyimg.com/ddimg/jfs/t1/6112/19/20760/2765240/61822227E766ff596/674e92faa6e549bb.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2021/10/29/HTML/"/>
      <url>/2021/10/29/HTML/</url>
      
        <content type="html"><![CDATA[<h1 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h1><ul><li><p>JavaWeb：</p><ul><li>使用Java语言开发基于互联网的项目</li></ul></li><li><p>软件架构：</p><ol><li>C/S: Client/Server 客户端/服务器端<ul><li>在用户本地有一个客户端程序，在远程有一个服务器端程序</li><li>如：QQ，迅雷…</li><li>优点：<ol><li>用户体验好</li></ol></li><li>缺点：<ol><li>开发、安装，部署，维护 麻烦</li></ol></li></ul></li><li>B/S: Browser/Server 浏览器/服务器端<ul><li>只需要一个浏览器，用户通过不同的网址（URL），客户访问不同的服务器端程序</li><li>优点：<ol><li>开发、安装，部署，维护 简单</li></ol></li><li>缺点：<ol><li>如果应用过大，用户的体验可能会受到影响</li><li>对硬件要求过高</li></ol></li></ul></li></ol></li><li><p>B/S架构详解</p><ul><li><p>资源分类：</p><ol><li>静态资源：<ul><li>使用静态网页开发技术发布的资源。</li><li>特点：<ul><li>所有用户访问，得到的结果是一样的。</li><li>如：文本，图片，音频、视频, HTML,CSS,JavaScript</li><li>如果用户请求的是静态资源，那么<strong>服务器会直接将静态资源发送给浏览器</strong>。浏览器中内置了静态资源的解析引擎，可以展示静态资源</li></ul></li></ul></li><li>动态资源（java开发方向）：<ul><li>使用动态网页及时发布的资源。</li><li>特点：<ul><li>所有用户访问，得到的结果可能不一样。</li><li>如：jsp/servlet,php,asp…</li><li>如果用户请求的是动态资源，那么<strong>服务器会执行动态资源，转换为静态资源，再发送给浏览器</strong></li></ul></li></ul></li></ol></li><li><p>要学习动态资源，必须先学习静态资源！</p></li><li><p>静态资源：</p><ul><li>HTML：用于搭建基础网页，展示页面的内容（非常基础的文字图片展示）</li><li>CSS：用于美化页面，布局页面</li><li>JavaScript：控制页面的元素，让页面有一些动态的效果</li></ul></li></ul></li></ul><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><ol><li><p>概念：是最基础的网页开发语言</p><ul><li>Hyper Text Markup Language 超文本标记语言<ul><li>超文本:<ul><li>超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.</li></ul></li><li>标记语言:<ul><li>由标签构成的语言。&lt;标签名称&gt; 如 html，xml</li><li>标记语言不是编程语言</li></ul></li></ul></li></ul></li><li><p>快速入门：</p><ul><li><p>语法：</p><ol><li><p>html文档后缀名 .html 或者 .htm</p></li><li><p>标签分为</p><ol><li>围堵标签：有开始标签和结束标签。如 <code>&lt;html&gt; &lt;/html&gt;</code></li><li>自闭和 标签：开始标签和结束标签在一起。如 <code>&lt;br/&gt;</code></li></ol></li><li><p>标签可以嵌套：<br>需要正确嵌套，不能你中有我，我中有你<br>错误：<code>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</code><br>正确：<code>&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;</code></p></li><li><p>在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</p></li><li><p>html的标签不区分大小写，但是建议使用小写。</p></li></ol></li><li><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;FONT color=&#x27;red&#x27;&gt;Hello World&lt;/font&gt;&lt;br/&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;font color=&#x27;green&#x27;&gt;Hello World&lt;/font&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="标签学习："><a href="#标签学习：" class="headerlink" title="标签学习："></a>标签学习：</h2><ol><li><p>文件标签：构成html最基本的标签(一般会自动生成)</p><ul><li>html:html文档的根标签</li><li>head：头标签。用于指定html文档的一些属性。引入外部的资源</li><li>title：标题标签。</li><li>body：体标签</li><li><!DOCTYPE html>：html5中定义该文档是html文档</li></ul></li><li><p>文本标签：和文本有关的标签</p><ul><li><p>注释：<code>&lt;!-- 注释内容 --&gt;</code></p></li><li><p><code>&lt;h1&gt;</code> to <code>&lt;h6&gt;</code>：标题标签</p><ul><li>h1~h6:字体大小逐渐递减</li></ul></li><li><p><code>&lt;p&gt;</code>：段落标签</p></li><li><p><code>&lt;br&gt;</code>：换行标签</p></li><li><p><code>&lt;hr&gt;</code>：展示一条水平线</p><ul><li>属性：<ul><li>color：颜色</li><li>width：宽度</li><li>size：高度</li><li>align：对其方式<ul><li>center：居中</li><li>left：左对齐</li><li>right：右对齐</li></ul></li></ul></li></ul></li><li><p><code>&lt;b&gt;</code>：字体加粗</p></li><li><p><code>&lt;i&gt;</code>：字体斜体</p></li><li><p><code>&lt;font&gt;</code>:字体标签</p></li><li><p><code>&lt;center&gt;</code>:文本居中</p><ul><li>属性：<ul><li>color：颜色</li><li>size：大小</li><li>face：字体</li></ul></li></ul></li><li><p>属性定义：</p><ul><li>color：<ol><li>英文单词：red,green,blue</li><li>rgb（值1，值2，值3）：值的范围：0~255  如  <code>rgb(0,0,255)</code></li><li>#值1值2值3：值的范围：00~FF之间。如： #FF00FF</li></ol></li><li>width：<ol><li>数值：width=’20’ ,数值的单位，默认是 px（像素）</li><li>数值%：占比相对于父元素的比例</li></ol></li></ul></li><li><p>特殊字符需要特殊处理，即使打很多空格最后页面显示出来的也只有一个空</p><p>  <img src="https://img14.360buyimg.com/ddimg/jfs/t1/198757/2/15217/228043/617bb568E429fda46/af259fbe08f3b190.png" alt="特殊字符.png"></p></li><li><p>案例：公司简介</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;ch&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;黑马程序员简介&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;</span><br><span class="line">    公司简介</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;hr color=&quot;#ffd700&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">&lt;font color=&quot;#FF0000&quot;&gt;&quot;中关村黑马程序员训练营&quot;&lt;/font&gt;是由&lt;b&gt;&lt;i&gt;传智播客&lt;/i&gt;&lt;/b&gt;联合中关村软件园、CSDN， 并委托传智播客进行教学实施的软件开发高端培训机构，致力于服务各大软件企业，解决当前软件开发技术飞速发展， 而企业招不到优秀人才的困扰。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line">目前，“中关村黑马程序员训练营”已成长为行业“学员质量好、课程内容深、企业满意”的移动开发高端训练基地， 并被评为中关村软件园重点扶持人才企业。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line"></span><br><span class="line">黑马程序员的学员多为大学毕业后，有理想、有梦想，想从事IT行业，而没有环境和机遇改变自己命运的年轻人。 黑马程序员的学员筛选制度，远比现在90%以上的企业招聘流程更为严格。任何一名学员想成功入学“黑马程序员”， 必须经历长达2个月的面试流程，这些流程中不仅包括严格的技术测试、自学能力测试，还包括性格测试、压力测试、 品德测试等等测试。毫不夸张地说，黑马程序员训练营所有学员都是精挑细选出来的。百里挑一的残酷筛选制度确 保学员质量，并降低企业的用人风险。</span><br><span class="line">中关村黑马程序员训练营不仅着重培养学员的基础理论知识，更注重培养项目实施管理能力，并密切关注技术革新， 不断引入先进的技术，研发更新技术课程，确保学员进入企业后不仅能独立从事开发工作，更能给企业带来新的技术体系和理念。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;p&gt;</span><br><span class="line"></span><br><span class="line">一直以来，黑马程序员以技术视角关注IT产业发展，以深度分享推进产业技术成长，致力于弘扬技术创新，倡导分享、 开放和协作，努力打造高质量的IT人才服务平台。</span><br><span class="line">&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr color=&quot;#ffd700&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;font color=&quot;gray&quot; size=&quot;2&quot;&gt;</span><br><span class="line">    &lt;center&gt;</span><br><span class="line">        江苏传智播客教育科技股份有限公司&lt;br&gt;</span><br><span class="line">        版权所有Copyright 2006-2018&amp;copy;, All Rights Reserved 苏ICP备16007882</span><br><span class="line">    &lt;/center&gt;</span><br><span class="line">&lt;/font&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>图片标签：</p><ul><li><p>img：展示图片</p><ul><li>属性：<ul><li>src：指定图片的位置</li></ul></li></ul></li><li><p>代码：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--展示一张图片 img--&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;image/jingxuan_2.jpg&quot; align=&quot;right&quot; alt=&quot;古镇&quot; width=&quot;500&quot; height=&quot;500&quot;/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">    相对路径，相对于本html文件所在的位置</span><br><span class="line">        * 以.开头的路径</span><br><span class="line">            * ./：代表当前目录  ./image/1.jpg</span><br><span class="line">            * ../:代表上一级目录</span><br><span class="line">          不写默认是./，即当前目录</span><br><span class="line">  --&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;./image/jiangwai_1.jpg&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;../image/jiangwai_1.jpg&quot;&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>列表标签：</p><ul><li>有序列表：<ul><li>ol: </li><li>li:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--按照1，2，3排序--&gt;</span><br><span class="line">&lt;ol type=&quot;1&quot;&gt;</span><br><span class="line">  &lt;li&gt;上床&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;睡觉&lt;/li&gt;</span><br><span class="line">&lt;/ol&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li>无序列表：<ul><li>ul:</li><li>li:</li></ul></li></ul></li><li><p>链接标签：</p><ul><li><p>a:定义一个超链接</p><ul><li>属性：<ul><li>href：指定访问资源的URL(统一资源定位符)</li><li>target：指定打开资源的方式<ul><li>_self:默认值，在当前页面打开</li><li>_blank：在空白页面打开</li></ul></li></ul></li></ul></li><li><p>代码：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--超链接  a--&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;http://www.itcast.cn&quot;&gt;点我&lt;/a&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_self&quot;&gt;点我&lt;/a&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;a href=&quot;http://www.itcast.cn&quot; target=&quot;_blank&quot;&gt;点我&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;a href=&quot;./5_列表标签.html&quot;&gt;列表标签&lt;/a&gt;&lt;br&gt;</span><br><span class="line">&lt;a href=&quot;mailto:itcast@itcast.cn&quot;&gt;联系我们&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;a href=&quot;http://www.itcast.cn&quot;&gt;&lt;img src=&quot;image/jiangwai_1.jpg&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>div和span：<br>没有样式，配合css使用</p><ul><li>div:每一个div占满一整行。块级标签</li><li>span：文本信息在一行展示，行内标签/内联标签</li></ul></li><li><p>语义化标签：html5中为了提高程序的可读性，提供了一些标签。<br>没有样式，配合css使用</p><ol><li><code>&lt;header&gt;</code>：页眉</li><li><code>&lt;footer&gt;</code>：页脚</li></ol></li></ol><ol start="8"><li>表格标签：<ul><li>table：定义表格<ul><li>width：宽度</li><li>border：边框</li><li>cellpadding：定义内容和单元格的距离</li><li>cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、</li><li>bgcolor：背景色</li><li>align：表格在网页中的对齐方式</li></ul></li><li>tr：定义行<ul><li>bgcolor：背景色</li><li>align：对齐方式</li></ul></li><li>td：定义单元格<ul><li>colspan：合并列</li><li>rowspan：合并行</li></ul></li><li>th：定义表头单元格<ul><li><code>&lt;caption&gt;</code>：表格标题</li><li><code>&lt;thead&gt;</code>：表示表格的头部分</li><li><code>&lt;tbody&gt;</code>：表示表格的体部分</li><li><code>&lt;tfoot&gt;</code>：表示表格的脚部分</li></ul></li></ul></li></ol><h1 id="案例：旅游网站首页"><a href="#案例：旅游网站首页" class="headerlink" title="案例：旅游网站首页"></a>案例：旅游网站首页</h1><p>alt+/ 可以自动提示标签写法和格式，很方便</p><ol><li>确定使用table来完成布局    </li><li>如果某一行只有一个单元格，则使用<code>&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;</code></li><li>如果某一行有多个单元格，则使用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">  &lt;td&gt;</span><br><span class="line">    &lt;table&gt;&lt;/table&gt;</span><br><span class="line">  &lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>说是这样操作方便控制格式，不很理解，先记住去这样用</li><li>代码实现懒得写了</li></ol><h1 id="HTML标签：表单标签"><a href="#HTML标签：表单标签" class="headerlink" title="HTML标签：表单标签"></a>HTML标签：表单标签</h1><p>表单：概念：用于采集用户输入的数据的。用于和服务器进行交互。</p><h2 id="form"><a href="#form" class="headerlink" title="form"></a>form</h2><p>：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围</p><ul><li><p>属性：</p><ul><li>action：指定提交数据的URL</li><li>method:指定提交方式<ul><li>分类：一共7种，2种比较常用<ul><li>get：<ol><li>请求参数会在地址栏中显示。会封装到请求行中（之后会学到）。</li><li>请求参数大小是有限制的。</li><li>不太安全。</li></ol></li><li>post：<ol start="2"><li>请求参数不会再地址栏中显示。会封装在请求体中（之后会学到）</li><li>请求参数的大小没有限制。</li><li>较为安全。</li></ol></li></ul></li></ul></li></ul></li><li><p>表单项中的数据要想被提交：必须指定其name属性</p></li></ul><h2 id="表单项标签："><a href="#表单项标签：" class="headerlink" title="表单项标签："></a>表单项标签：</h2><p>包含的name属性主要是为了提交的时候来传递信息使用（提交后显示在网址部分），<strong>一定要记得写name部分</strong></p><ul><li><p>input：可以通过type属性值，改变元素展示的样式</p><ul><li><p>type属性：</p><ul><li><p>text：文本输入框，默认值</p><ul><li>placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息    </li></ul></li><li><p>password：密码输入框</p></li><li><p>radio:单选框</p><ul><li>注意：<ol><li>要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。</li><li>一般会给每一个单选框提供value属性，指定其被选中后提交的值</li><li>checked属性，可以指定默认值<br><code>&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; 男</code><br><code>&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; 女</code></li></ol></li></ul></li><li><p>checkbox：复选框</p><ul><li>注意：<ol><li>一般会给每一个单选框提供value属性，指定其被选中后提交的值</li><li>checked属性，可以指定默认值</li></ol></li></ul></li><li><p>file：文件选择框</p></li><li><p>hidden：隐藏域，用于提交一些信息。</p></li><li><p>按钮：</p><ul><li>submit：提交按钮。可以提交表单</li><li>button：普通按钮，不可以提交表单，但可以有其他用途</li><li>image：图片提交按钮,可以提交表单<ul><li>src属性指定图片的路径    </li></ul></li></ul></li><li><p>email</p></li><li><p>date</p></li><li><p>number<br>等等</p></li></ul></li><li><p>label：指定输入项的文字描述信息</p><ul><li>注意：<ul><li>label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。<br><code>&lt;label for=&quot;username&quot;&gt;用户&lt;/label&gt;: &lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;请输入用户名&quot; id=&quot;username&quot;&gt;</code></li></ul></li></ul></li></ul></li><li><p>select: 下拉列表</p><ul><li>子元素：option，指定列表项</li></ul></li><li><p>textarea：文本域</p><ul><li>cols：指定列数，每一行有多少个字符</li><li>rows：默认多少行。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC连接池和Template</title>
      <link href="/2021/10/26/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%92%8CTemplate/"/>
      <url>/2021/10/26/JDBC%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%92%8CTemplate/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h1><p>以前相当于开饭馆，来一个客人，就招聘一个服务员，客人走后，就开除服务员，这样子重复<br>连接池相当于一个为客人持续提供服务的服务员</p><ol><li><p>概念：其实就是一个容器（集合），存放数据库连接的容器。<br>当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</p></li><li><p>好处：</p><ol><li>节约资源</li><li>用户访问高效</li></ol></li><li><p>实现：</p><ol><li><p>标准接口：DataSource<br>javax.sql包下的</p><ul><li>方法：<ul><li>获取连接：<code>getConnection()</code></li><li>归还连接：<code>Connection.close()</code><br>如果连接对象Connection是从连接池中获取的，那么调用<code>Connection.close()</code>方法，则不会再关闭连接了，而是归还连接</li></ul></li></ul></li><li><p>一般我们不去实现它，有数据库厂商来实现</p><ol><li>C3P0：数据库连接池技术</li><li>Druid：数据库连接池实现技术，由阿里巴巴提供的（主要使用）</li></ol></li></ol></li></ol><h2 id="C3P0：数据库连接池技术"><a href="#C3P0：数据库连接池技术" class="headerlink" title="C3P0：数据库连接池技术"></a>C3P0：数据库连接池技术</h2><ul><li><p>步骤：</p><ol><li><p>导入jar包 （两个）<br>c3p0-0.9.5.2.jar<br>mchange-commons-java-0.2.12.jar ，</p><ul><li>不要忘记导入数据库驱动jar包 mysql-connector-java-5.1.37-bin.jar<br>新建libs文件夹（libs和src同级），然后将包复制粘贴，并右键add as library</li></ul></li><li><p>定义配置文件：</p><ul><li>名称： c3p0.properties 或者 c3p0-config.xml</li><li>路径：直接将文件放在<strong>src</strong>目录下即可。<br>会自动从配置文件获取信息<br>如果是<code>new ComboPooledDataSource()</code>则使用默认配置<br>是<code>new ComboPooledDataSource(&quot;configName&quot;)</code>则使用对应名称的配置</li></ul><p> <img src="https://img14.360buyimg.com/ddimg/jfs/t1/198026/14/14757/190548/6177a6caE538190d1/3df668e7a7c340a6.png" alt="image.png"></p></li><li><p>创建核心对象 数据库连接池对象 ComboPooledDataSource</p></li><li><p>获取连接： getConnection</p></li></ol></li><li><p>代码：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//1.创建数据库连接池对象</span><br><span class="line">  DataSource ds  = new ComboPooledDataSource();</span><br><span class="line">  //2. 获取连接对象</span><br><span class="line">  Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure></li></ul><h2 id="Druid：数据库连接池实现技术（常用）"><a href="#Druid：数据库连接池实现技术（常用）" class="headerlink" title="Druid：数据库连接池实现技术（常用）"></a>Druid：数据库连接池实现技术（常用）</h2><ol><li>步骤：<ol><li>导入jar包 druid-1.0.9.jar</li><li>定义配置文件：<ul><li>是properties形式的</li><li>可以叫任意名称，可以放在任意目录下，需要手动加载</li></ul></li><li>加载配置文件Properties</li><li>获取数据库连接池对象：通过工厂类来获取  DruidDataSourceFactory</li><li>获取连接：getConnection</li></ol></li></ol><ul><li>代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//3.加载配置文件</span><br><span class="line">  Properties pro = new Properties();</span><br><span class="line">  InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;);</span><br><span class="line">// 从本类的src中获取文件内容的方法</span><br><span class="line">  pro.load(is);</span><br><span class="line">  //4.获取连接池对象</span><br><span class="line">  DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">  //5.获取连接</span><br><span class="line">  Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>定义工具类<ol><li>定义一个类 JDBCUtils</li><li>提供静态代码块加载配置文件，初始化连接池对象</li><li>提供方法<ol><li>获取连接方法：通过数据库连接池获取连接</li><li>释放资源</li><li>获取信息配置完全的连接池的方法</li></ol></li></ol></li></ol><ul><li><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">public class JDBCUtils &#123;</span><br><span class="line"></span><br><span class="line">    //1.定义成员变量 DataSource</span><br><span class="line">    private static DataSource ds ;</span><br><span class="line">  // 静态代码块，调用这个类就会执行代码块，注意静态代码块中不要产生需要释放的对象</span><br><span class="line">    static&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //1.加载配置文件</span><br><span class="line">            Properties pro = new Properties();</span><br><span class="line">            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(&quot;druid.properties&quot;));</span><br><span class="line">            //2.获取DataSource，配置好的连接池</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 获取连接</span><br><span class="line">      */</span><br><span class="line">    public static Connection getConnection() throws SQLException &#123;</span><br><span class="line">        return ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 释放资源</span><br><span class="line">      */</span><br><span class="line">    public static void close(Statement stmt,Connection conn)&#123;</span><br><span class="line">        /* if(stmt != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(conn != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();//归还连接</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;*/</span><br><span class="line"></span><br><span class="line">        close(null,stmt,conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void close(ResultSet rs , Statement stmt, Connection conn)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(rs != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if(stmt != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                stmt.close();</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(conn != null)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                conn.close();//归还连接</span><br><span class="line">            &#125; catch (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 获取连接池方法</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">    public static DataSource getDataSource()&#123;</span><br><span class="line">        return  ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class DruidDemo &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Connection cn = null;</span><br><span class="line">    PreparedStatement pstmt = null;</span><br><span class="line">    try &#123;</span><br><span class="line">      cn = JDBCUtils.getConnection();</span><br><span class="line">      String sql = &quot;insert into dept values(50,?,?)&quot;;</span><br><span class="line">      pstmt = cn.prepareStatement(sql);</span><br><span class="line">      pstmt.setString(1,&quot;ceshi&quot;);</span><br><span class="line">      pstmt.setString(2,&quot;北京&quot;);</span><br><span class="line">      pstmt.executeUpdate();</span><br><span class="line"></span><br><span class="line">    &#125; catch (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;finally &#123;</span><br><span class="line">      JDBCUtils.close(pstmt,cn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="Spring-JDBC"><a href="#Spring-JDBC" class="headerlink" title="Spring JDBC"></a>Spring JDBC</h1><ul><li><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p></li><li><p>步骤：</p><ol><li><p>导入jar包 还需要导入驱动包和Druid连接池的包</p></li><li><p>创建JdbcTemplate对象。依赖于数据源DataSource</p><ul><li><code>JdbcTemplate template = new JdbcTemplate(ds)</code>;</li></ul></li><li><p>调用JdbcTemplate的方法来完成CRUD的操作</p><ul><li><code>update()</code>:执行DML语句。增、删、改语句<br><code>update(sql)</code></li><li><code>queryForMap()</code>:查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合<ul><li>注意：这个方法查询的结果集长度只能是1<br><code>queryForMap(sql)</code></li></ul></li><li><code>queryForList()</code>:查询结果将结果集封装为list集合<ul><li>注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中<br><code>queryForList(sql)</code></li></ul></li><li><code>query()</code>:查询结果，将结果封装为JavaBean对象（返回一个list集合）<ul><li>query的参数：RowMapper</li><li>一般我们使用BeanPropertyRowMapper实现类。<strong>可以完成数据到JavaBean的自动封装</strong>，忽略复杂步骤，但需要将目标封装类中的int改为integer（类比其他）</li><li><code>new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</code><br><code>query(sql, new BeanPropertyRowMapper&lt;封装类型&gt;(封装类型.class))</code></li></ul></li><li>queryForObject：查询结果，将结果封装为对象<ul><li>一般用于<strong>聚合函数</strong>的查询<br><code>queryForObject(sql, 查询结果类型.class)</code></li></ul></li></ul></li></ol></li><li><p>练习：</p><ul><li><p>需求：</p><ol><li>修改1号数据的 salary 为 10000</li><li>添加一条记录</li><li>删除刚才添加的记录</li><li>查询id为1的记录，将其封装为Map集合</li><li>查询所有记录，将其封装为List</li><li>查询所有记录，将其封装为Emp对象的List集合</li><li>查询总记录数</li></ol></li><li><p>代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">import cn.itcast.domain.Emp;</span><br><span class="line">import cn.itcast.utils.JDBCUtils;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.jdbc.core.RowMapper;</span><br><span class="line"></span><br><span class="line">import java.sql.Date;</span><br><span class="line">import java.sql.ResultSet;</span><br><span class="line">import java.sql.SQLException;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class JdbcTemplateDemo2 &#123;</span><br><span class="line"></span><br><span class="line">    //Junit单元测试，可以让方法独立执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //1. 获取JDBCTemplate对象</span><br><span class="line">    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">    /**</span><br><span class="line">      * 1. 修改1号数据的 salary 为 10000</span><br><span class="line">      */</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line"></span><br><span class="line">        //2. 定义sql</span><br><span class="line">        String sql = &quot;update emp set salary = 10000 where id = 1001&quot;;</span><br><span class="line">        //3. 执行sql</span><br><span class="line">        int count = template.update(sql);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 2. 添加一条记录</span><br><span class="line">      */</span><br><span class="line">    @Test</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        String sql = &quot;insert into emp(id,ename,dept_id) values(?,?,?)&quot;;</span><br><span class="line">        int count = template.update(sql, 1015, &quot;郭靖&quot;, 10);</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 3.删除刚才添加的记录</span><br><span class="line">      */</span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;</span><br><span class="line">        String sql = &quot;delete from emp where id = ?&quot;;</span><br><span class="line">        int count = template.update(sql, 1015);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 4.查询id为1001的记录，将其封装为Map集合</span><br><span class="line">      * 注意：这个方法查询的结果集长度只能是1</span><br><span class="line">      */</span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        String sql = &quot;select * from emp where id = ? or id = ?&quot;;</span><br><span class="line">        Map&lt;String, Object&gt; map = template.queryForMap(sql, 1001,1002);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        //&#123;id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20&#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 5. 查询所有记录，将其封装为List</span><br><span class="line">      */</span><br><span class="line">    @Test</span><br><span class="line">    public void test5()&#123;</span><br><span class="line">        String sql = &quot;select * from emp&quot;;</span><br><span class="line">        List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);</span><br><span class="line"></span><br><span class="line">        for (Map&lt;String, Object&gt; stringObjectMap : list) &#123;</span><br><span class="line">            System.out.println(stringObjectMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 6. 查询所有记录，将其封装为Emp对象的List集合，较麻烦的方法</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test6()&#123;</span><br><span class="line">        String sql = &quot;select * from emp&quot;;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, new RowMapper&lt;Emp&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Emp mapRow(ResultSet rs, int i) throws SQLException &#123;</span><br><span class="line">                Emp emp = new Emp();</span><br><span class="line">                int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">                String ename = rs.getString(&quot;ename&quot;);</span><br><span class="line">                int job_id = rs.getInt(&quot;job_id&quot;);</span><br><span class="line">                int mgr = rs.getInt(&quot;mgr&quot;);</span><br><span class="line">                Date joindate = rs.getDate(&quot;joindate&quot;);</span><br><span class="line">                double salary = rs.getDouble(&quot;salary&quot;);</span><br><span class="line">                double bonus = rs.getDouble(&quot;bonus&quot;);</span><br><span class="line">                int dept_id = rs.getInt(&quot;dept_id&quot;);</span><br><span class="line"></span><br><span class="line">                emp.setId(id);</span><br><span class="line">                emp.setEname(ename);</span><br><span class="line">                emp.setJob_id(job_id);</span><br><span class="line">                emp.setMgr(mgr);</span><br><span class="line">                emp.setJoindate(joindate);</span><br><span class="line">                emp.setSalary(salary);</span><br><span class="line">                emp.setBonus(bonus);</span><br><span class="line">                emp.setDept_id(dept_id);</span><br><span class="line"></span><br><span class="line">                return emp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        for (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 6. 查询所有记录，将其封装为Emp对象的List集合，spring提供的简单方法，需要将类中的int改为integer</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test6_2()&#123;</span><br><span class="line">        String sql = &quot;select * from emp&quot;;</span><br><span class="line">        List&lt;Emp&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;Emp&gt;(Emp.class));</span><br><span class="line">        for (Emp emp : list) &#123;</span><br><span class="line">            System.out.println(emp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">      * 7. 查询总记录数</span><br><span class="line">      */</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test7()&#123;</span><br><span class="line">        String sql = &quot;select count(id) from emp&quot;;</span><br><span class="line">        Long total = template.queryForObject(sql, Long.class);</span><br><span class="line">        System.out.println(total);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC入门</title>
      <link href="/2021/10/12/JDBC%E5%85%A5%E9%97%A8/"/>
      <url>/2021/10/12/JDBC%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h1><ol><li><p>概念：Java DataBase Connectivity  Java 数据库连接 -&gt; Java语言操作数据库</p><ul><li>JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即<strong>接口</strong>。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是<strong>驱动jar包中的实现类</strong>。</li></ul></li><li><p>快速入门：</p><ul><li><p>步骤：</p><ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar<ol><li>在对应的module里new一个新的Directory，命名为libs<br>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li><li>在libs右键–&gt;Add As Library</li></ol></li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql</li><li>获取执行sql语句的对象 Statement</li><li>执行sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol></li><li><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//1. 导入驱动jar包</span><br><span class="line">//2.注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//3.获取数据库连接对象</span><br><span class="line">Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">//4.定义sql语句</span><br><span class="line">String sql = &quot;update account set balance = 500 where id = 1&quot;;</span><br><span class="line">//5.获取执行sql的对象 Statement</span><br><span class="line">Statement stmt = conn.createStatement();</span><br><span class="line">//6.执行sql</span><br><span class="line">int count = stmt.executeUpdate(sql);</span><br><span class="line">//7.处理结果</span><br><span class="line">System.out.println(count);</span><br><span class="line">//8.释放资源</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br></pre></td></tr></table></figure></li><li><p>特殊例子<br>因为字符串变量不可以放在引号中，不然就不能做为变量使用<br>需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*2.定义sql   </span><br><span class="line">在这一部分把这个sql语句当成最基本的字符串去处理，username和password是字符串变量所以需要拼接，</span><br><span class="line">+号前后连接的是字符串所以要分成</span><br><span class="line">&quot;select * from user where username = &#x27;&quot;</span><br><span class="line">+</span><br><span class="line">username</span><br><span class="line">+</span><br><span class="line">&quot;&#x27; and password = &#x27;&quot;</span><br><span class="line">+</span><br><span class="line">password</span><br><span class="line">+</span><br><span class="line">&quot;&#x27; &quot;</span><br><span class="line">这几个部分，为保证最后拼接出的字符串可以使用，sql的&#x27;&#x27;也不可以缺失</span><br><span class="line">*/</span><br><span class="line">String sql = &quot;select * from user where username = &#x27;&quot;+username+&quot;&#x27; and password = &#x27;&quot;+password+&quot;&#x27; &quot;;</span><br></pre></td></tr></table></figure></li></ul><p> 或者使用后续学习的PreparedStatement来处理</p></li></ol><h1 id="详解各个步骤："><a href="#详解各个步骤：" class="headerlink" title="详解各个步骤："></a>详解各个步骤：</h1><ol><li><p>DriverManager：驱动管理对象</p><ul><li><p>功能：</p><ol><li><p>注册驱动：告诉程序该使用哪一个数据库驱动jar<br> <code>static void registerDriver(Driver driver)</code> :注册给定的驱动程序 DriverManager<br> 写代码使用：  <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code>;<br> 注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。</p></li><li><p>获取数据库连接：</p><ul><li>方法：<code>static Connection getConnection(String url, String user, String password) </code><br><code>DriverManager.getConnection()</code> 返回一个Connection对象</li><li>参数：<ul><li>url：指定连接的路径<ul><li>语法：jdbc:mysql://ip地址（域名）:端口号/数据库名称</li><li>例子：jdbc:mysql://localhost:3306/db3</li><li>细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称</li></ul></li><li>user：用户名</li><li>password：密码 </li></ul></li></ul></li></ol></li></ul></li><li><p>Connection：数据库连接对象</p><ul><li><p>功能：</p><ol><li><p>获取执行sql 的对象</p><ul><li><code>Statement createStatement()</code></li><li><code>PreparedStatement prepareStatement(String sql) </code> </li></ul></li><li><p>管理事务：</p><ul><li>开启事务：<code>setAutoCommit(boolean autoCommit)</code> ：调用该方法设置参数为false，即开启事务</li><li>提交事务：<code>commit() </code></li><li>回滚事务：<code>rollback()</code> </li></ul></li></ol></li></ul></li><li><p>Statement：执行sql的对象</p><ol><li><p>执行sql</p><ol><li><code>boolean execute(String sql)</code> ：可以执行任意的sql 了解 </li><li><code>int executeUpdate(String sql)</code> ：执行DML（insert、update、delete，操作表中数据）语句、DDL（create，alter、drop，操作数据库、表）语句<ul><li>返回值：<br>DML，影响的行数，可以通过这个影响的行数判断DML语句是否执行成功，返回值&gt;0的则执行成功，反之，则失败。<br>DDL，返回值为0</li></ul></li><li><code>ResultSet executeQuery(String sql)</code>  ：执行DQL（select，查询表中数据）语句</li></ol></li><li><p>练习：</p><ol><li>account表 添加一条记录</li></ol><p> 代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Statement stmt = null;</span><br><span class="line">Connection conn = null;</span><br><span class="line">try &#123;</span><br><span class="line">//1. 注册驱动</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">//2. 定义sql</span><br><span class="line">String sql = &quot;insert into account values(null,&#x27;王五&#x27;,3000)&quot;;</span><br><span class="line">//3.获取Connection对象</span><br><span class="line">conn = DriverManager.getConnection(&quot;jdbc:mysql:///db3&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">//4.获取执行sql的对象 Statement</span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line">//5.执行sql</span><br><span class="line">int count = stmt.executeUpdate(sql);//影响的行数</span><br><span class="line">//6.处理结果</span><br><span class="line">System.out.println(count);</span><br><span class="line">if(count &gt; 0)&#123;</span><br><span class="line">System.out.println(&quot;添加成功！&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;添加失败！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">//stmt.close();</span><br><span class="line">//7. 释放资源</span><br><span class="line">//如果stmt还没有赋值就报错跳转到finally，直接释放stmt资源会造成空指针异常</span><br><span class="line">if(stmt != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">stmt.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(conn != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>ResultSet：结果集对象,封装查询结果</p><ul><li><p><code>boolean next()</code>: 游标最开始位于第一行之前（类似于属性行），每运行一次，游标向下移动一行，判断当前行是否是最后一行末尾（是否有数据，最后一行末尾即没有数据），如果是，则返回false，如果不是则返回true</p></li><li><p><code>getXxx(参数)</code>:获取数据</p><ul><li>Xxx：代表数据类型   如： <code>int getInt()</code> ,    <code>String getString()</code></li><li>参数：<ol><li>参数是int：代表列的编号,从1开始   如： <code>getString(1)</code></li><li>参数是String：代表列名称。 如： <code>getDouble(&quot;balance&quot;)</code></li></ol></li></ul></li><li><p>注意：</p><ul><li><p>使用步骤：</p><ol><li>游标向下移动一行</li><li>判断是否有数据</li><li>获取数据</li></ol><p>  rs是新获得的ResultSet对象，查询数据库获得</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//循环判断游标是否是最后一行末尾。</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">//获取数据</span><br><span class="line">//6.2 获取数据</span><br><span class="line">int id = rs.getInt(1);</span><br><span class="line">String name = rs.getString(&quot;name&quot;);</span><br><span class="line">double balance = rs.getDouble(3);</span><br><span class="line"></span><br><span class="line">System.out.println(id + &quot;---&quot; + name + &quot;---&quot; + balance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>练习：</p><ul><li>定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。<ol><li>定义Emp类</li><li>定义方法 public List<Emp> findAll(){}</Emp></li><li>实现方法 select * from emp;</li></ol></li></ul><p>  EMP类                </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">public class Emp &#123;</span><br><span class="line">private int id;</span><br><span class="line">private String name;</span><br><span class="line">private int job_id;</span><br><span class="line">private int mgr;</span><br><span class="line">private Date joindate;</span><br><span class="line">private double salary;</span><br><span class="line">private double bonus;</span><br><span class="line">private int dept_id;</span><br><span class="line"></span><br><span class="line">public Emp() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Emp&#123;&quot; +</span><br><span class="line">&quot;id=&quot; + id +</span><br><span class="line">&quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">&quot;, job_id=&quot; + job_id +</span><br><span class="line">&quot;, mgr=&quot; + mgr +</span><br><span class="line">&quot;, joindate=&quot; + joindate +</span><br><span class="line">&quot;, salary=&quot; + salary +</span><br><span class="line">&quot;, bonus=&quot; + bonus +</span><br><span class="line">&quot;, dept_id=&quot; + dept_id +</span><br><span class="line">&#x27;&#125;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getId() &#123;</span><br><span class="line">return id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setId(int id) &#123;</span><br><span class="line">this.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getJob_id() &#123;</span><br><span class="line">return job_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setJob_id(int job_id) &#123;</span><br><span class="line">this.job_id = job_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getMgr() &#123;</span><br><span class="line">return mgr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMgr(int mgr) &#123;</span><br><span class="line">this.mgr = mgr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Date getJoindate() &#123;</span><br><span class="line">return joindate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setJoindate(Date joindate) &#123;</span><br><span class="line">this.joindate = joindate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getSalary() &#123;</span><br><span class="line">return salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setSalary(double salary) &#123;</span><br><span class="line">this.salary = salary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public double getBonus() &#123;</span><br><span class="line">return bonus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setBouns(double bonu) &#123;</span><br><span class="line">this.bonus = bonus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getDept_id() &#123;</span><br><span class="line">return dept_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setDept_id(int dept_id) &#123;</span><br><span class="line">this.dept_id = dept_id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  实现类</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class JdbcDemo02 &#123;</span><br><span class="line">/**</span><br><span class="line">* 查询所有emp对象</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">List&lt;Emp&gt; all = new JdbcDemo02().findAll();</span><br><span class="line">// 本类的非静态方法（实例方法）需要创建一个本类的对象去调用</span><br><span class="line">for (Emp emp : all) &#123;</span><br><span class="line">System.out.println(emp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public List&lt;Emp&gt; findAll()&#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">Statement stmt = null;</span><br><span class="line">ResultSet rs = null;</span><br><span class="line">List&lt;Emp&gt; list = null;</span><br><span class="line">try &#123;</span><br><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">// add try catch</span><br><span class="line">conn = DriverManager.getConnection(&quot;jdbc:mysql:///db2&quot;, &quot;root&quot;, &quot;root&quot;);</span><br><span class="line">// add catch</span><br><span class="line">String sql = &quot;select * from emp&quot;;</span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line">rs = stmt.executeQuery(sql);</span><br><span class="line">// 遍历结果集，封装对象，加载到集合=&gt;将一次遍历的数据封装到一个emp对象里，然后将这个对象放到集合中</span><br><span class="line">Emp emp = null;</span><br><span class="line">list = new ArrayList&lt;&gt;();</span><br><span class="line">// 放在里面Emp引用过多,影响栈内存</span><br><span class="line">while (rs.next())&#123;</span><br><span class="line">int id = rs.getInt(&quot;id&quot;);</span><br><span class="line">String ename = rs.getString(&quot;ename&quot;);</span><br><span class="line">int job_id = rs.getInt(&quot;job_id&quot;);</span><br><span class="line">int mgr = rs.getInt(&quot;mgr&quot;);</span><br><span class="line">Date joindate = rs.getDate(&quot;joindate&quot;);</span><br><span class="line">double salary = rs.getDouble(&quot;salary&quot;);</span><br><span class="line">double bonus = rs.getDouble(&quot;bonus&quot;);</span><br><span class="line">int dept_id = rs.getInt(&quot;dept_id&quot;);</span><br><span class="line">emp = new Emp();</span><br><span class="line">emp.setId(id);</span><br><span class="line">emp.setName(ename);</span><br><span class="line">emp.setDept_id(dept_id);</span><br><span class="line">emp.setJob_id(job_id);</span><br><span class="line">emp.setMgr(mgr);</span><br><span class="line">emp.setJoindate(joindate);</span><br><span class="line">emp.setSalary(salary);</span><br><span class="line">emp.setBouns(bonus);</span><br><span class="line">list.add(emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (SQLException throwables) &#123;</span><br><span class="line">throwables.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">// 释放顺序 =&gt; 先释放后生成的</span><br><span class="line">if(rs!=null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; catch (SQLException throwables) &#123;</span><br><span class="line">throwables.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(stmt!=null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">stmt.close();</span><br><span class="line">&#125; catch (SQLException throwables) &#123;</span><br><span class="line">throwables.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if(conn!=null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; catch (SQLException throwables) &#123;</span><br><span class="line">throwables.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return list;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="PreparedStatement：执行sql的对象"><a href="#PreparedStatement：执行sql的对象" class="headerlink" title="PreparedStatement：执行sql的对象"></a>PreparedStatement：执行sql的对象</h2><ol><li><p>SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的<strong>拼接</strong>。会造成安全性问题</p><ol><li>输入用户随便，输入密码：a’ or ‘a’ = ‘a</li><li>sql：select * from user where username = ‘fhdsjkf’ and password = ‘a’ or ‘a’ = ‘a’<br>可以划分为 select * from user where    username = ‘fhdsjkf’ and password = ‘a’     or ‘a’ = ‘a’ </li></ol></li><li><p>解决sql注入问题：使用PreparedStatement对象来解决</p></li><li><p>预编译的SQL：参数使用?作为占位符</p></li><li><p>步骤：(<strong>后期真正使用的步骤</strong>)</p><ol><li>导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</li><li>注册驱动</li><li>获取数据库连接对象 Connection</li><li>定义sql<ul><li>注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;</li></ul></li><li>获取执行sql语句的对象 <code>PreparedStatement pstmt =  Connection.prepareStatement(String sql)</code> </li><li>给？赋值：<ul><li>方法： setXxx(参数1,参数2)<ul><li>参数1：？的位置编号 从1 开始</li><li>参数2：？的值<br><code>pstmt.setString(1, username)</code>;<br><code>pstmt.setString(2, password)</code></li></ul></li></ul></li><li>执行sql，接受返回结果，不需要传递sql语句 <code>pstmt.executeQuery()</code> 或者<code>pstmt.executeUpdate()</code></li><li>处理结果</li><li>释放资源</li></ol></li><li><p>注意：后期都会使用PreparedStatement来完成增删改查的所有操作</p><ol><li>可以防止SQL注入</li><li>效率更高</li></ol></li></ol><h1 id="抽取JDBC工具类-：-JDBCUtils"><a href="#抽取JDBC工具类-：-JDBCUtils" class="headerlink" title="抽取JDBC工具类 ： JDBCUtils"></a>抽取JDBC工具类 ： JDBCUtils</h1><ul><li><p>目的：简化书写</p></li><li><p>分析：</p><ol><li><p>注册驱动也抽取</p></li><li><p>抽取一个方法获取连接对象</p><ul><li>需求：不想传递参数（麻烦），还得保证工具类的通用性。</li><li>解决：<strong>配置文件</strong>   在src里新建一个File文件，将信息写入<br>  jdbc.properties<br>  url=<br>  user=<br>  password=</li></ul><p> <img src="https://img12.360buyimg.com/ddimg/jfs/t1/176595/6/25583/88346/61693f13Efdd50819/ff9fcc935b55ae7f.png" alt="image.png"></p></li><li><p>抽取一个方法释放资源</p></li></ol></li><li><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public class JDBCUtils &#123;</span><br><span class="line">private static String url;</span><br><span class="line">private static String user;</span><br><span class="line">private static String password;</span><br><span class="line">private static String driver;</span><br><span class="line">/**</span><br><span class="line">* 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块，只要调用这个类就会运行静态代码块</span><br><span class="line">*/</span><br><span class="line">static&#123;</span><br><span class="line">//读取资源文件，获取值。</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">//1. 创建Properties集合类。</span><br><span class="line">Properties pro = new Properties();</span><br><span class="line"></span><br><span class="line">//获取src路径下的文件的方式---&gt;ClassLoader 类加载器</span><br><span class="line">ClassLoader classLoader = JDBCUtils.class.getClassLoader();</span><br><span class="line">URL res  = classLoader.getResource(&quot;jdbc.properties&quot;);</span><br><span class="line">String path = res.getPath();</span><br><span class="line">System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties</span><br><span class="line">//2. 加载文件</span><br><span class="line">// pro.load(new FileReader(&quot;D:\\IdeaProjects\\itcast\\day04_jdbc\\src\\jdbc.properties&quot;));</span><br><span class="line">pro.load(new FileReader(path));</span><br><span class="line"></span><br><span class="line">//3. 获取数据，赋值</span><br><span class="line">url = pro.getProperty(&quot;url&quot;);</span><br><span class="line">user = pro.getProperty(&quot;user&quot;);</span><br><span class="line">password = pro.getProperty(&quot;password&quot;);</span><br><span class="line">driver = pro.getProperty(&quot;driver&quot;);</span><br><span class="line">//4. 注册驱动</span><br><span class="line">Class.forName(driver);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 获取连接</span><br><span class="line">* @return 连接对象</span><br><span class="line">*/</span><br><span class="line">public static Connection getConnection() throws SQLException &#123;</span><br><span class="line"></span><br><span class="line">return DriverManager.getConnection(url, user, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 释放资源</span><br><span class="line">* @param stmt</span><br><span class="line">* @param conn</span><br><span class="line">*/</span><br><span class="line">public static void close(Statement stmt,Connection conn)&#123;</span><br><span class="line">if( stmt != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">stmt.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if( conn != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 释放资源，重载</span><br><span class="line">* @param stmt</span><br><span class="line">* @param conn</span><br><span class="line">*/</span><br><span class="line">public static void close(ResultSet rs,Statement stmt, Connection conn)&#123;</span><br><span class="line">if( rs != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if( stmt != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">stmt.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if( conn != null)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>练习：</p><ul><li><p>需求：</p><ol><li>通过键盘录入用户名和密码</li><li>判断用户是否登录成功<ul><li>select * from user where username = “” and password = “”;</li><li>如果这个sql有查询结果，则成功，反之，则失败</li></ul></li></ol></li><li><p>步骤：</p><ol><li><p>创建数据库表 user</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE USER(</span><br><span class="line">id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">username VARCHAR(32),</span><br><span class="line">PASSWORD VARCHAR(32)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO USER VALUES(NULL,&#x27;zhangsan&#x27;,&#x27;123&#x27;);</span><br><span class="line">INSERT INTO USER VALUES(NULL,&#x27;lisi&#x27;,&#x27;234&#x27;);</span><br></pre></td></tr></table></figure></li><li><p>代码实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public class JDBCDemo9 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//1.键盘录入，接受用户名和密码</span><br><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">System.out.println(&quot;请输入用户名：&quot;);</span><br><span class="line">String username = sc.nextLine();</span><br><span class="line">System.out.println(&quot;请输入密码：&quot;);</span><br><span class="line">String password = sc.nextLine();</span><br><span class="line">//2.调用方法</span><br><span class="line">boolean flag = new JDBCDemo9().login(username, password);</span><br><span class="line">//3.判断结果，输出不同语句</span><br><span class="line">if(flag)&#123;</span><br><span class="line">//登录成功</span><br><span class="line">System.out.println(&quot;登录成功！&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">System.out.println(&quot;用户名或密码错误！&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* 登录方法</span><br><span class="line">*/</span><br><span class="line">public boolean login(String username ,String password)&#123;</span><br><span class="line">if(username == null || password == null)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">//连接数据库判断是否登录成功</span><br><span class="line">Connection conn = null;</span><br><span class="line">Statement stmt =  null;</span><br><span class="line">ResultSet rs = null;</span><br><span class="line">//1.获取连接</span><br><span class="line">try &#123;</span><br><span class="line">conn =  JDBCUtils.getConnection();</span><br><span class="line">/*2.定义sql   </span><br><span class="line">在这一部分把这个sql语句当成最基本的字符串去处理，username和password是字符串变量所以需要拼接，</span><br><span class="line">+号前后连接的是字符串所以要分成</span><br><span class="line">&quot;select * from user where username = &#x27;&quot;</span><br><span class="line">+</span><br><span class="line">username</span><br><span class="line">+</span><br><span class="line">&quot;&#x27; and password = &#x27;&quot;</span><br><span class="line">+</span><br><span class="line">password</span><br><span class="line">+</span><br><span class="line">&quot;&#x27; &quot;</span><br><span class="line">这几个部分，为保证最后拼接出的字符串可以使用，sql的&#x27;&#x27;也不可以缺失</span><br><span class="line">*/</span><br><span class="line">String sql = &quot;select * from user where username = &#x27;&quot;+username+&quot;&#x27; and password = &#x27;&quot;+password+&quot;&#x27; &quot;;</span><br><span class="line">//3.获取执行sql的对象</span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line">//4.执行查询</span><br><span class="line">rs = stmt.executeQuery(sql);</span><br><span class="line">//5.判断</span><br><span class="line">/* if(rs.next())&#123;//如果有下一行，则返回true</span><br><span class="line">return true;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;*/</span><br><span class="line">return rs.next();//如果有下一行，则返回true</span><br><span class="line"></span><br><span class="line">&#125; catch (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">JDBCUtils.close(rs,stmt,conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">return false;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h1 id="JDBC控制事务："><a href="#JDBC控制事务：" class="headerlink" title="JDBC控制事务："></a>JDBC控制事务：</h1><ol><li><p>事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。</p></li><li><p>操作：</p><ol><li>开启事务</li><li>提交事务</li><li>回滚事务</li></ol></li><li><p>使用Connection对象来管理事务</p><ul><li>开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务<ul><li>在执行sql之前开启事务</li></ul></li><li>提交事务：commit() <ul><li>当所有sql都执行完提交事务</li></ul></li><li>回滚事务：rollback() <ul><li>在catch中回滚事务，需要catch一个大异常Exception</li></ul></li></ul></li><li><p>代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class JDBCDemo10 &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Connection conn = null;</span><br><span class="line">PreparedStatement pstmt1 = null;</span><br><span class="line">PreparedStatement pstmt2 = null;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">//1.使用工具类获取连接</span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line">//开启事务</span><br><span class="line">conn.setAutoCommit(false);</span><br><span class="line"></span><br><span class="line">//2.定义sql</span><br><span class="line">//2.1 张三 - 500</span><br><span class="line">String sql1 = &quot;update account set balance = balance - ? where id = ?&quot;;</span><br><span class="line">//2.2 李四 + 500</span><br><span class="line">String sql2 = &quot;update account set balance = balance + ? where id = ?&quot;;</span><br><span class="line">//3.获取执行sql对象</span><br><span class="line">pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">//4. 设置参数</span><br><span class="line">pstmt1.setDouble(1,500);</span><br><span class="line">pstmt1.setInt(2,1);</span><br><span class="line"></span><br><span class="line">pstmt2.setDouble(1,500);</span><br><span class="line">pstmt2.setInt(2,2);</span><br><span class="line">//5.执行sql</span><br><span class="line">pstmt1.executeUpdate();</span><br><span class="line">// 手动制造异常</span><br><span class="line">int i = 3/0;</span><br><span class="line"></span><br><span class="line">pstmt2.executeUpdate();</span><br><span class="line">//提交事务</span><br><span class="line">conn.commit();</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">//事务回滚，这个catch必须抓一个大的异常Exception才能确保报错会调用内部的回滚</span><br><span class="line">try &#123;</span><br><span class="line">if(conn != null) &#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (SQLException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;finally &#123;</span><br><span class="line">JDBCUtils.close(pstmt1,conn);</span><br><span class="line">JDBCUtils.close(pstmt2,null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql多表&amp;事务</title>
      <link href="/2021/10/04/Mysql%E5%A4%9A%E8%A1%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/"/>
      <url>/2021/10/04/Mysql%E5%A4%9A%E8%A1%A8%E5%92%8C%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="多表查询："><a href="#多表查询：" class="headerlink" title="多表查询："></a>多表查询：</h1><ul><li><p>查询语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">  列名列表</span><br><span class="line">from</span><br><span class="line">  表名列表</span><br><span class="line">where....</span><br></pre></td></tr></table></figure></li><li><p>准备sql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 创建部门表</span><br><span class="line">CREATE TABLE dept(</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  NAME VARCHAR(20)</span><br><span class="line">);</span><br><span class="line">INSERT INTO dept (NAME) VALUES (&#x27;开发部&#x27;),(&#x27;市场部&#x27;),(&#x27;财务部&#x27;);</span><br><span class="line"># 创建员工表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  NAME VARCHAR(10),</span><br><span class="line">  gender CHAR(1), -- 性别</span><br><span class="line">  salary DOUBLE, -- 工资</span><br><span class="line">  join_date DATE, -- 入职日期</span><br><span class="line">  dept_id INT,</span><br><span class="line">  FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)</span><br><span class="line">);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;孙悟空&#x27;,&#x27;男&#x27;,7200,&#x27;2013-02-24&#x27;,1);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;猪八戒&#x27;,&#x27;男&#x27;,3600,&#x27;2010-12-02&#x27;,2);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;唐僧&#x27;,&#x27;男&#x27;,9000,&#x27;2008-08-08&#x27;,2);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;白骨精&#x27;,&#x27;女&#x27;,5000,&#x27;2015-10-07&#x27;,3);</span><br><span class="line">INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(&#x27;蜘蛛精&#x27;,&#x27;女&#x27;,4500,&#x27;2011-03-14&#x27;,1);</span><br></pre></td></tr></table></figure></li><li><p>笛卡尔积：</p><ul><li>有两个集合A,B 。取这两个集合的<strong>所有</strong>组成情况，即会有A*B种数据。<br>直接 SELECT * FROM emp,dept 会产生大量无用数据</li><li>要完成多表查询，需要消除无用的数据</li></ul></li></ul><h1 id="多表查询的分类："><a href="#多表查询的分类：" class="headerlink" title="多表查询的分类："></a>多表查询的分类：</h1><h2 id="内连接查询："><a href="#内连接查询：" class="headerlink" title="内连接查询："></a>内连接查询：</h2><ol><li>隐式内连接：使用where条件消除无用数据</li></ol><ul><li>例子：</li></ul><p>  – 查询所有员工信息和对应的部门信息</p><p>  SELECT * FROM emp,dept WHERE emp.<code>dept_id</code> = dept.<code>id</code>;</p><p>  – 查询员工表的名称，性别。部门表的名称<br>  SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.<code>dept_id</code> = dept.<code>id</code>;</p><p>  最标准的写法，方便理解和加注释<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">t1.name, -- 员工表的姓名</span><br><span class="line">t1.gender,-- 员工表的性别</span><br><span class="line">t2.name -- 部门表的名称</span><br><span class="line">FROM</span><br><span class="line">emp t1,</span><br><span class="line">dept t2</span><br><span class="line">WHERE </span><br><span class="line">t1.`dept_id` = t2.`id`;</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>显式内连接：</p><ul><li>语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件<br>[]括进去的意思是可选的，可以添加或者不添加</li><li>例如：<ul><li>SELECT * FROM emp INNER JOIN dept ON emp.<code>dept_id</code> = dept.<code>id</code>;    </li><li>SELECT * FROM emp JOIN dept ON emp.<code>dept_id</code> = dept.<code>id</code>;    </li></ul></li></ul></li><li><p>内连接查询：</p><ol><li>从哪些表中查询数据</li><li>条件是什么</li><li>查询哪些字段</li></ol></li></ol><h2 id="外连接查询："><a href="#外连接查询：" class="headerlink" title="外连接查询："></a>外连接查询：</h2><ol><li><p>左外连接：</p><ul><li>语法：select 字段列表 from 表1（左表） left [outer] join 表2 on 条件；</li><li>查询的是左表所有数据以及其交集部分，即使左表有外键为null的数据也依然会显示出来</li><li>例子：<br>– 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称<br>即所有的员工信息都要显示出来，部门有就显示，没有就null<br>SELECT     t1.*,t2.<code>name</code> FROM emp t1 LEFT JOIN dept t2 ON t1.<code>dept_id</code> = t2.<code>id</code>;</li></ul></li><li><p>右外连接：</p><ul><li>语法：select 字段列表 from 表1 right [outer] join 表2（右表） on 条件；</li><li>查询的是右表所有数据以及其交集部分。</li><li>例子：<br>SELECT     * FROM dept t2 RIGHT JOIN emp t1 ON t1.<code>dept_id</code> = t2.<code>id</code>;</li></ul></li></ol><h2 id="子查询："><a href="#子查询：" class="headerlink" title="子查询："></a>子查询：</h2><ul><li><p>概念：查询中嵌套查询，称 嵌套查询 为子查询。<br>– 查询工资最高的员工信息<br>– 1 查询最高的工资是多少 9000<br><code>SELECT MAX(salary) FROM emp;</code></p><p>– 2 查询员工信息，并且工资等于9000的<br>SELECT * FROM emp WHERE emp.<code>salary</code> = 9000;</p><p>– 一条sql就完成这个操作。子查询<br><code>SELECT * FROM emp WHERE emp.</code>salary<code> = (SELECT MAX(salary) FROM emp);</code></p></li><li><p>子查询不同情况</p><ol><li><p>子查询的结果是单行单列的：</p><ul><li>子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =</li><li></li></ul><p> – 查询员工工资小于平均工资的人<br> <code>SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);</code></p></li><li><p>子查询的结果是多行单列的：</p><ul><li>子查询可以作为条件，使用运算符in来判断</li></ul><p> – 查询’财务部’和’市场部’所有的员工信息<br> SELECT id FROM dept WHERE NAME = ‘财务部’ OR NAME = ‘市场部’;<br> SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;<br> – 子查询<br> <code>SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &#39;财务部&#39; OR NAME = &#39;市场部&#39;);</code></p></li><li><p>子查询的结果是多行多列的：</p><ul><li>子查询可以作为一张虚拟表参与查询</li></ul><p> – 查询员工入职日期是2011-11-11日之后的员工信息和部门信息<br> – 子查询<br> <code> SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.&#39;join_date&#39; &gt; &#39;2011-11-11&#39;) t2 WHERE t1.id = t2.dept_id;</code></p><p> – 普通内连接<br> SELECT * FROM emp t1,dept t2 WHERE t1.<code>dept_id</code> = t2.<code>id</code> AND t1.<code>join_date</code> &gt;  ‘2011-11-11’</p></li></ol></li></ul><h1 id="多表查询练习"><a href="#多表查询练习" class="headerlink" title="多表查询练习"></a>多表查询练习</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line">-- 部门表</span><br><span class="line">CREATE TABLE dept (</span><br><span class="line">  id INT PRIMARY KEY PRIMARY KEY, -- 部门id</span><br><span class="line">  dname VARCHAR(50), -- 部门名称</span><br><span class="line">  loc VARCHAR(50) -- 部门所在地</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加4个部门</span><br><span class="line">INSERT INTO dept(id,dname,loc) VALUES </span><br><span class="line">(10,&#x27;教研部&#x27;,&#x27;北京&#x27;),</span><br><span class="line">(20,&#x27;学工部&#x27;,&#x27;上海&#x27;),</span><br><span class="line">(30,&#x27;销售部&#x27;,&#x27;广州&#x27;),</span><br><span class="line">(40,&#x27;财务部&#x27;,&#x27;深圳&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 职务表，职务名称，职务描述</span><br><span class="line">CREATE TABLE job (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  jname VARCHAR(20),</span><br><span class="line">  description VARCHAR(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加4个职务</span><br><span class="line">INSERT INTO job (id, jname, description) VALUES</span><br><span class="line">(1, &#x27;董事长&#x27;, &#x27;管理整个公司，接单&#x27;),</span><br><span class="line">(2, &#x27;经理&#x27;, &#x27;管理部门员工&#x27;),</span><br><span class="line">(3, &#x27;销售员&#x27;, &#x27;向客人推销产品&#x27;),</span><br><span class="line">(4, &#x27;文员&#x27;, &#x27;使用办公软件&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 员工表</span><br><span class="line">CREATE TABLE emp (</span><br><span class="line">  id INT PRIMARY KEY, -- 员工id</span><br><span class="line">  ename VARCHAR(50), -- 员工姓名</span><br><span class="line">  job_id INT, -- 职务id</span><br><span class="line">  mgr INT , -- 上级领导</span><br><span class="line">  joindate DATE, -- 入职日期</span><br><span class="line">  salary DECIMAL(7,2), -- 工资</span><br><span class="line">  bonus DECIMAL(7,2), -- 奖金</span><br><span class="line">  dept_id INT, -- 所在部门编号</span><br><span class="line">  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),</span><br><span class="line">  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加员工</span><br><span class="line">INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES </span><br><span class="line">(1001,&#x27;孙悟空&#x27;,4,1004,&#x27;2000-12-17&#x27;,&#x27;8000.00&#x27;,NULL,20),</span><br><span class="line">(1002,&#x27;卢俊义&#x27;,3,1006,&#x27;2001-02-20&#x27;,&#x27;16000.00&#x27;,&#x27;3000.00&#x27;,30),</span><br><span class="line">(1003,&#x27;林冲&#x27;,3,1006,&#x27;2001-02-22&#x27;,&#x27;12500.00&#x27;,&#x27;5000.00&#x27;,30),</span><br><span class="line">(1004,&#x27;唐僧&#x27;,2,1009,&#x27;2001-04-02&#x27;,&#x27;29750.00&#x27;,NULL,20),</span><br><span class="line">(1005,&#x27;李逵&#x27;,4,1006,&#x27;2001-09-28&#x27;,&#x27;12500.00&#x27;,&#x27;14000.00&#x27;,30),</span><br><span class="line">(1006,&#x27;宋江&#x27;,2,1009,&#x27;2001-05-01&#x27;,&#x27;28500.00&#x27;,NULL,30),</span><br><span class="line">(1007,&#x27;刘备&#x27;,2,1009,&#x27;2001-09-01&#x27;,&#x27;24500.00&#x27;,NULL,10),</span><br><span class="line">(1008,&#x27;猪八戒&#x27;,4,1004,&#x27;2007-04-19&#x27;,&#x27;30000.00&#x27;,NULL,20),</span><br><span class="line">(1009,&#x27;罗贯中&#x27;,1,NULL,&#x27;2001-11-17&#x27;,&#x27;50000.00&#x27;,NULL,10),</span><br><span class="line">(1010,&#x27;吴用&#x27;,3,1006,&#x27;2001-09-08&#x27;,&#x27;15000.00&#x27;,&#x27;0.00&#x27;,30),</span><br><span class="line">(1011,&#x27;沙僧&#x27;,4,1004,&#x27;2007-05-23&#x27;,&#x27;11000.00&#x27;,NULL,20),</span><br><span class="line">(1012,&#x27;李逵&#x27;,4,1006,&#x27;2001-12-03&#x27;,&#x27;9500.00&#x27;,NULL,30),</span><br><span class="line">(1013,&#x27;小白龙&#x27;,4,1004,&#x27;2001-12-03&#x27;,&#x27;30000.00&#x27;,NULL,20),</span><br><span class="line">(1014,&#x27;关羽&#x27;,4,1007,&#x27;2002-01-23&#x27;,&#x27;13000.00&#x27;,NULL,10);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 工资等级表</span><br><span class="line">CREATE TABLE salarygrade (</span><br><span class="line">  grade INT PRIMARY KEY,   -- 级别</span><br><span class="line">  losalary INT,  -- 最低工资</span><br><span class="line">  hisalary INT -- 最高工资</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 添加5个工资等级</span><br><span class="line">INSERT INTO salarygrade(grade,losalary,hisalary) VALUES </span><br><span class="line">(1,7000,12000),</span><br><span class="line">(2,12010,14000),</span><br><span class="line">(3,14010,20000),</span><br><span class="line">(4,20010,30000),</span><br><span class="line">(5,30010,99990);</span><br><span class="line"></span><br><span class="line">-- 需求：</span><br><span class="line"></span><br><span class="line">-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述</span><br><span class="line">/*</span><br><span class="line">  分析：</span><br><span class="line">    1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表</span><br><span class="line">    2.查询条件 emp.job_id = job.id</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">SELECT </span><br><span class="line">  t1.`id`, -- 员工编号</span><br><span class="line">  t1.`ename`, -- 员工姓名</span><br><span class="line">  t1.`salary`,-- 工资</span><br><span class="line">  t2.`jname`, -- 职务名称</span><br><span class="line">  t2.`description` -- 职务描述</span><br><span class="line">FROM </span><br><span class="line">  emp t1, job t2</span><br><span class="line">WHERE </span><br><span class="line">  t1.`job_id` = t2.`id`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置</span><br><span class="line">/*</span><br><span class="line">  分析：</span><br><span class="line">    1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept</span><br><span class="line">    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  t1.`id`, -- 员工编号</span><br><span class="line">  t1.`ename`, -- 员工姓名</span><br><span class="line">  t1.`salary`,-- 工资</span><br><span class="line">  t2.`jname`, -- 职务名称</span><br><span class="line">  t2.`description`, -- 职务描述</span><br><span class="line">  t3.`dname`, -- 部门名称</span><br><span class="line">  t3.`loc` -- 部门位置</span><br><span class="line">FROM </span><br><span class="line">  emp t1, job t2,dept t3</span><br><span class="line">WHERE </span><br><span class="line">  t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;</span><br><span class="line">    </span><br><span class="line">-- 3.查询员工姓名，工资，工资等级</span><br><span class="line">/*</span><br><span class="line">  分析：</span><br><span class="line">    1.员工姓名，工资 emp  工资等级 salarygrade</span><br><span class="line">    2.条件 emp.salary &gt;= salarygrade.losalary and emp.salary &lt;= salarygrade.hisalary</span><br><span class="line">      emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary</span><br><span class="line">*/</span><br><span class="line">SELECT </span><br><span class="line">  t1.ename ,</span><br><span class="line">  t1.`salary`,</span><br><span class="line">  t2.*</span><br><span class="line">FROM emp t1, salarygrade t2</span><br><span class="line">WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级</span><br><span class="line">/*</span><br><span class="line">  分析：</span><br><span class="line">    1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade</span><br><span class="line">    2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary</span><br><span class="line">      </span><br><span class="line">*/</span><br><span class="line">SELECT </span><br><span class="line">  t1.`ename`,</span><br><span class="line">  t1.`salary`,</span><br><span class="line">  t2.`jname`,</span><br><span class="line">  t2.`description`,</span><br><span class="line">  t3.`dname`,</span><br><span class="line">  t3.`loc`,</span><br><span class="line">  t4.`grade`</span><br><span class="line">FROM </span><br><span class="line">  emp t1,job t2,dept t3,salarygrade t4</span><br><span class="line">WHERE </span><br><span class="line">  t1.`job_id` = t2.`id` </span><br><span class="line">  AND t1.`dept_id` = t3.`id`</span><br><span class="line">  AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 5.查询出部门编号、部门名称、部门位置、部门人数</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  分析：</span><br><span class="line">    1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表</span><br><span class="line">    2.使用分组查询。按照emp.dept_id完成分组，查询count(id)</span><br><span class="line">    3.使用子查询将第2步的查询结果和dept表进行关联查询</span><br><span class="line">    </span><br><span class="line">*/</span><br><span class="line">SELECT </span><br><span class="line">  t1.`id`,t1.`dname`,t1.`loc` , t2.total</span><br><span class="line">FROM </span><br><span class="line">  dept t1,</span><br><span class="line">  (SELECT</span><br><span class="line">    dept_id,COUNT(id) total</span><br><span class="line">  FROM </span><br><span class="line">    emp</span><br><span class="line">  GROUP BY dept_id) t2</span><br><span class="line">WHERE t1.`id` = t2.dept_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询</span><br><span class="line">**自关联需要要制造两个不同的emp表进行比较**</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  分析：</span><br><span class="line">    1.姓名 emp， 直接上级的姓名 emp</span><br><span class="line">      * emp表的id 和 mgr 是自关联</span><br><span class="line">    2.条件 emp.id = emp.mgr</span><br><span class="line">    3.查询左表的所有数据，和 交集数据</span><br><span class="line">      * 使用左外连接查询</span><br><span class="line">  </span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">select</span><br><span class="line">  t1.ename,</span><br><span class="line">  t1.mgr,</span><br><span class="line">  t2.`id`,</span><br><span class="line">  t2.ename</span><br><span class="line">from emp t1, emp t2</span><br><span class="line">where t1.mgr = t2.`id`;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  t1.ename,</span><br><span class="line">  t1.mgr,</span><br><span class="line">  t2.`id`,</span><br><span class="line">  t2.`ename`</span><br><span class="line">FROM emp t1</span><br><span class="line">LEFT JOIN emp t2</span><br><span class="line">ON t1.`mgr` = t2.`id`;</span><br></pre></td></tr></table></figure><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="事务的基本介绍"><a href="#事务的基本介绍" class="headerlink" title="事务的基本介绍"></a>事务的基本介绍</h2><ol><li><p>概念：</p><ul><li>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作<strong>要么同时成功，要么同时失败</strong>。<br>即不允许部分成功，例如两个人互相进行转账操作，如果部分发生，则会出现安全问题</li></ul></li><li><p>操作：</p><ol><li>开启事务： start transaction;</li><li>回滚：rollback;</li><li>提交：commit;</li></ol><p> 开启事务之后需要手动提交，如果不提交，在关闭事务后默认回滚，不会记录更新</p><p> 不提交特点：只会有临时数据，可以在本窗口查询数据变化，但如果打开另一个窗口进行查询就无法观察到数据变化，<br> 若直接关闭本窗口，则数据最终不会发生任何变化，类似于不改变本体的假设行为<br> 提交之后才会使数据发生根本变化</p></li><li><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE account (</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  NAME VARCHAR(10),</span><br><span class="line">  balance DOUBLE</span><br><span class="line">);</span><br><span class="line">-- 添加数据</span><br><span class="line">INSERT INTO account (NAME, balance) VALUES (&#x27;zhangsan&#x27;, 1000), (&#x27;lisi&#x27;, 1000);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br><span class="line">-- 张三给李四转账 500 元</span><br><span class="line"></span><br><span class="line">-- 0. 开启事务</span><br><span class="line">START TRANSACTION;</span><br><span class="line">-- 1. 张三账户 -500</span><br><span class="line"></span><br><span class="line">UPDATE account SET balance = balance - 500 WHERE NAME = &#x27;zhangsan&#x27;;</span><br><span class="line">-- 2. 李四账户 +500</span><br><span class="line">-- 出错了...</span><br><span class="line">UPDATE account SET balance = balance + 500 WHERE NAME = &#x27;lisi&#x27;;</span><br><span class="line"></span><br><span class="line">-- 发现执行没有问题，提交事务</span><br><span class="line">COMMIT;</span><br><span class="line"></span><br><span class="line">-- 发现出问题了，回滚事务回开启事务之前</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure></li><li><p>MySQL数据库中事务默认自动提交  </p><ul><li><p>事务提交的两种方式：</p><ul><li>自动提交：<ul><li>mysql就是自动提交的</li><li>一条DML（增删改）语句会自动提交一次事务。</li></ul></li><li>手动提交：<ul><li>Oracle 数据库默认是手动提交事务</li><li><strong>需要先开启事务，再提交</strong></li></ul></li></ul></li><li><p>修改事务的默认提交方式：</p><ul><li>查看事务的默认提交方式：SELECT @@autocommit; </li></ul><p>  –    1 代表自动提交  0 代表手动提交</p><ul><li>修改默认提交方式： set @@autocommit = 0;</li></ul></li></ul></li></ol><h2 id="事务的四大特征（面试常问）："><a href="#事务的四大特征（面试常问）：" class="headerlink" title="事务的四大特征（面试常问）："></a>事务的四大特征（面试常问）：</h2><ol><li>原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</li><li>持久性：当事务提交或回滚后，数据库会持久化的保存数据。</li><li>隔离性：多个事务之间。相互独立。</li><li>一致性：事务操作前后，数据总量不变</li></ol><h2 id="事务的隔离级别（了解）"><a href="#事务的隔离级别（了解）" class="headerlink" title="事务的隔离级别（了解）"></a>事务的隔离级别（了解）</h2><ul><li><p>概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。</p></li><li><p>存在问题：</p><ol><li>脏读：一个事务，读取到另一个事务中没有提交的数据</li><li>不可重复读（虚读）：在同一个事务中，两次读取到的数据不一样。</li><li>幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。<br> A,B同时对C表进行操作，B操作完并提交以后，A查询数据仍为最开始的数据，并没有显示B的操作</li></ol></li><li><p>隔离级别：</p><ol><li>read uncommitted：读未提交<ul><li>产生的问题：脏读、不可重复读、幻读</li></ul></li><li>read committed：读已提交 （Oracle默认）<ul><li>产生的问题：不可重复读、幻读</li></ul></li><li>repeatable read：可重复读 （MySQL默认）<ul><li>产生的问题：幻读</li></ul></li><li>serializable：串行化<ul><li>锁表，不允许同时对表进行操作，可以解决所有的问题</li></ul></li></ol><ul><li>注意：隔离级别从小到大安全性越来越高，但是效率越来越低</li><li>数据库查询隔离级别：<ul><li>select @@tx_isolation;</li></ul></li><li>数据库设置隔离级别：<ul><li>set global transaction isolation level  级别字符串;</li></ul></li></ul></li><li><p>演示：<br>set global transaction isolation level read uncommitted;<br>start transaction;<br>…</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql约束</title>
      <link href="/2021/10/03/Mysql%E7%BA%A6%E6%9D%9F/"/>
      <url>/2021/10/03/Mysql%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul><li>概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    </li><li>分类：<ol><li>主键约束：primary key</li><li>非空约束：not null</li><li>唯一约束：unique</li><li>外键约束：foreign key</li></ol></li></ul><h1 id="约束的使用"><a href="#约束的使用" class="headerlink" title="约束的使用"></a>约束的使用</h1><h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><p>：not null，某一列的值不能为null</p><ol><li><p>创建表时添加约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">  id INT,</span><br><span class="line">  NAME VARCHAR(20) NOT NULL -- name为非空</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>创建表完后，添加非空约束<br><code>ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL</code>;</p></li><li><p>删除name的非空约束<br><code>ALTER TABLE stu MODIFY NAME VARCHAR(20)</code>;</p></li></ol><h2 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h2><p>：unique，某一列的值不能重复</p><ol><li>注意：<ul><li>唯一约束限定的列值可以有多个null</li></ul></li><li>在创建表时，添加唯一约束<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">  id INT,</span><br><span class="line">  phone_number VARCHAR(20) UNIQUE -- 手机号</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>删除唯一约束（只是删除了约束，但没有对数据进行处理）<br>ALTER TABLE stu DROP INDEX phone_number;</li><li>在表创建完后，添加唯一约束<br><code>ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE</code>;</li></ol><h2 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h2><p>：primary key。</p><ol><li><p>注意：</p><ol><li>含义：非空且唯一</li><li>一张表只能有一个字段为主键</li><li>主键就是表中记录的唯一标识</li></ol></li><li><p>在创建表时，添加主键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">  id int primary key,-- 给id添加主键约束</span><br><span class="line">  name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除主键<br>错误写法 alter table stu modify id int ;<br>ALTER TABLE stu DROP PRIMARY KEY;</p></li><li><p>创建完表后，添加主键<br>ALTER TABLE stu MODIFY id INT PRIMARY KEY;</p></li><li><p>自动增长：</p><ol><li><p> 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</p></li><li><p>在创建表时，添加主键约束，并且完成主键自增长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">  id int primary key auto_increment,-- 给id添加主键约束</span><br><span class="line">  name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除自动增长<br>ALTER TABLE stu MODIFY id INT;</p></li><li><p>添加自动增长<br>ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</p></li></ol></li></ol><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><p>：foreign key,让表于表产生关系，从而保证数据的正确性。<br>有外键约束，在删除主表列时将不会允许删除，防止误操作</p><ol><li><p>在创建表时，可以添加外键</p><ul><li>语法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">  ....</span><br><span class="line">  外键列,</span><br><span class="line">  constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>外键名称随便起的，不重复即可<br>最后相当于是下面又加了一行，需要加“,”</li></ul></li><li><p>删除外键<br>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</p></li><li><p>创建表之后，添加外键<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称)</code>;</p></li><li><p>级联操作<br>修改被约束字段，对应的约束对象与被约束对象都会改变</p><ol><li>在添加外键的同时直接添加级联操作<br>语法：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE</code>  ;</li><li>分类：可以一起写，也可以分开写<ol><li>级联更新：ON UPDATE CASCADE<br>一起更新</li><li>级联删除：ON DELETE CASCADE<br>一起删除</li></ol></li></ol></li></ol><h1 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h1><h2 id="多表之间的关系"><a href="#多表之间的关系" class="headerlink" title="多表之间的关系"></a>多表之间的关系</h2><ol><li><p>分类：</p><ol><li>一对一（了解）：<ul><li>如：人和身份证</li><li>分析：一个人只有一个身份证，一个身份证只能对应一个人</li></ul></li><li>一对多（多对一）：<ul><li>如：部门和员工</li><li>分析：一个部门有多个员工，一个员工只能对应一个部门</li></ul></li><li>多对多：<ul><li>如：学生和课程</li><li>分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</li></ul></li></ol></li><li><p>实现关系：</p><ol><li>一对多（多对一）：<ul><li>如：部门和员工</li><li>实现方式：<strong>在多的一方建立外键，指向一的一方的主键</strong>。</li></ul></li><li>多对多：<ul><li>如：学生和课程</li><li>实现方式：多对多关系实现需要<strong>借助第三张中间表</strong>。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</li></ul></li><li>一对一（了解）：<ul><li>如：人和身份证</li><li>实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</li></ul></li></ol></li><li><p>案例</p></li></ol><p>旅游线路分类表 tab_category 和 旅游线路表 tab_route 是一对多的关系、<br>旅游线路表 tab_route 和 用户表 tab_user 是多对多的关系，需要创建一个中间表 收藏表 tab_favorite<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">-- 创建旅游线路分类表 tab_category</span><br><span class="line">-- cid 旅游线路分类主键，自动增长</span><br><span class="line">-- cname 旅游线路分类名称非空，唯一，字符串 100</span><br><span class="line">CREATE TABLE tab_category (</span><br><span class="line">  cid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  cname VARCHAR(100) NOT NULL UNIQUE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建旅游线路表 tab_route</span><br><span class="line">/*</span><br><span class="line">rid 旅游线路主键，自动增长</span><br><span class="line">rname 旅游线路名称非空，唯一，字符串 100</span><br><span class="line">price 价格</span><br><span class="line">rdate 上架时间，日期类型</span><br><span class="line">cid 外键，所属分类</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_route(</span><br><span class="line">  rid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  rname VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">  price DOUBLE,</span><br><span class="line">  rdate DATE,</span><br><span class="line">  cid INT,</span><br><span class="line">  FOREIGN KEY (cid) REFERENCES tab_category(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*创建用户表 tab_user</span><br><span class="line">uid 用户主键，自增长</span><br><span class="line">username 用户名长度 100，唯一，非空</span><br><span class="line">password 密码长度 30，非空</span><br><span class="line">name 真实姓名长度 100</span><br><span class="line">birthday 生日</span><br><span class="line">sex 性别，定长字符串 1</span><br><span class="line">telephone 手机号，字符串 11</span><br><span class="line">email 邮箱，字符串长度 100</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_user (</span><br><span class="line">  uid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  username VARCHAR(100) UNIQUE NOT NULL,</span><br><span class="line">  PASSWORD VARCHAR(30) NOT NULL,</span><br><span class="line">  NAME VARCHAR(100),</span><br><span class="line">  birthday DATE,</span><br><span class="line">  sex CHAR(1) DEFAULT &#x27;男&#x27;,</span><br><span class="line">  telephone VARCHAR(11),</span><br><span class="line">  email VARCHAR(100)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">创建收藏表 tab_favorite</span><br><span class="line">rid 旅游线路 id，外键</span><br><span class="line">date 收藏时间</span><br><span class="line">uid 用户 id，外键</span><br><span class="line">rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_favorite (</span><br><span class="line">  rid INT, -- 线路id</span><br><span class="line">  DATE DATETIME,</span><br><span class="line">  uid INT, -- 用户id</span><br><span class="line">  -- 创建复合主键</span><br><span class="line">  PRIMARY KEY(rid,uid), -- 联合主键</span><br><span class="line">  FOREIGN KEY (rid) REFERENCES tab_route(rid),</span><br><span class="line">  FOREIGN KEY(uid) REFERENCES tab_user(uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h2 id="数据库设计的范式"><a href="#数据库设计的范式" class="headerlink" title="数据库设计的范式"></a>数据库设计的范式</h2><ul><li><p>概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</p><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。<br>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p></li><li><p>分类：</p><ol><li>第一范式（1NF）：每一列都是不可分割的原子数据项，不可以把一列又分成两类</li><li>第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）<ol><li>函数依赖：A–&gt;B,如果通过A属性（属性组）的值，可以确定唯一B属性的值。则称B依赖于A<br>例如：学号–&gt;姓名。  （学号，课程名称） –&gt; 分数</li><li>完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。<br>例如：（学号，课程名称） –&gt; 分数</li><li>部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值即可。<br>例如：（学号，课程名称） – &gt; 姓名</li><li>传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性（属性组）的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A<br>例如：学号–&gt;系名，系名–&gt;系主任</li><li>码：如果在一张表中，一个属性或属性组，被其他<strong>所有属性所完全依赖</strong>，则称这个属性（属性组）为该表的码<br>例如：该表中码为：（学号，课程名称）<ul><li>主属性：码属性组中的所有属性</li><li>非主属性：除去码属性组的属性</li></ul></li></ol></li><li>第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</li></ol></li></ul><h1 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h1><ol><li><p>命令行：</p><ul><li>语法：<ul><li>备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</li><li>还原：<ol><li>登录数据库</li><li>创建数据库</li><li>使用数据库</li><li>执行文件。source 文件路径</li></ol></li></ul></li></ul></li><li><p>图形化工具：</p><ul><li>直接右键导出，执行</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2021/09/27/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/09/27/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><ol><li><p>什么是SQL？<br>Structured Query Language：结构化查询语言<br>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。</p></li><li><p>SQL通用语法</p><ol><li>SQL 语句可以单行或多行书写，<strong>以分号结尾</strong>。</li><li>可使用空格和缩进来增强语句的可读性。</li><li>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</li><li>3 种注释<ul><li>单行注释: – 注释内容 或 # 注释内容（mysql 特有，且空格不能忽略）</li><li>多行注释: /* 注释 */</li></ul></li></ol></li><li><p>SQL分类</p><ol><li>DDL（Data Definition Language）数据定义语言<br>用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等</li><li>DML（Data Manipulation Language）数据操作语言<br>用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等</li><li>DQL（Data Query Language）数据查询语言<br>用来查询数据库中表的记录（数据）。关键字：select, where 等</li><li>DCL（Data Control Language）数据控制语言(了解）<br>用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</li></ol><p> <img src="https://img14.360buyimg.com/ddimg/jfs/t1/197830/33/10387/2456214/61517aaeE275f5e28/c09fdea913e7aea7.bmp" alt="SQL分类"></p></li></ol><h1 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL: 操作数据库、表"></a>DDL: 操作数据库、表</h1><h2 id="操作数据库：CRUD"><a href="#操作数据库：CRUD" class="headerlink" title="操作数据库：CRUD"></a>操作数据库：CRUD</h2><ol><li><p>C（Create）:创建</p><ul><li><p>创建数据库：</p><ul><li>create database 数据库名称;</li></ul></li><li><p>创建数据库，判断不存在，再创建：</p><ul><li>create database if not exists 数据库名称;</li></ul></li><li><p>创建数据库，并指定字符集</p><ul><li>create database 数据库名称 character set 字符集名;</li></ul></li><li><p>练习： 创建db4数据库，判断是否存在，并制定字符集为gbk</p><ul><li>create database if not exists db4 character set gbk;</li></ul></li></ul></li></ol><ol start="2"><li>R（Retrieve）：查询<ul><li>查询所有数据库的名称:<ul><li>show databases;</li></ul></li><li>查询某个数据库的字符集:查询某个数据库的创建语句<ul><li>show create database 数据库名称;</li></ul></li></ul></li></ol><ol start="3"><li>U（Update）:修改<ul><li>修改数据库的字符集（gbk 和 utf8）<ul><li>alter database 数据库名称 character set 字符集名称;</li></ul></li></ul></li></ol><ol start="4"><li>D（Delete）:删除<ul><li>删除数据库<ul><li>drop database 数据库名称;</li></ul></li><li>判断数据库存在，存在再删除<ul><li>drop database if exists 数据库名称;</li></ul></li></ul></li></ol><ol start="5"><li>使用数据库<ul><li>查询当前正在使用的数据库名称<ul><li><code>select database()</code>;</li></ul></li><li>使用数据库<ul><li>use 数据库名称;</li></ul></li></ul></li></ol><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><ol><li><p>C（Create）:创建</p><ol><li>语法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">  列名1 数据类型1,</span><br><span class="line">  列名2 数据类型2,</span><br><span class="line">  ....</span><br><span class="line">  列名n 数据类型n</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>注意：最后一列，不需要加逗号（,）</p></li><li><p>数据库类型：</p><ol><li><p>int：整数类型</p><ul><li>age int,</li></ul></li><li><p>double:小数类型</p><ul><li><code>score double(5,2)</code></li></ul></li><li><p>date:日期，只包含年月日，yyyy-MM-dd</p></li><li><p>datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss</p></li><li><p>timestamp:时间戳类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss    </p><ul><li>如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</li></ul></li><li><p>varchar：字符串</p><ul><li><code>name varchar(20)</code>:姓名最大20个字符</li><li>zhangsan 8个字符  张三 2个字符</li></ul></li></ol></li></ul><ol start="2"><li>创建表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table student(</span><br><span class="line">  id int,</span><br><span class="line">  name varchar(32),</span><br><span class="line">  age int ,</span><br><span class="line">  score double(4,1),</span><br><span class="line">  birthday date,</span><br><span class="line">  insert_time timestamp</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>复制表：<ul><li>create table 表名 like 被复制的表名;    </li></ul></li></ol></li></ol><ol start="2"><li>R（Retrieve）：查询<ul><li>查询某个数据库中所有的表名称<ul><li>show tables;</li></ul></li><li>查询表结构<ul><li>desc 表名;</li></ul></li></ul></li></ol><ol start="3"><li>U（Update）:修改<ol><li>修改表名<br>alter table 表名 rename to 新的表名;</li><li>修改表的字符集<br>alter table 表名 character set 字符集名称;</li><li>添加一列<br>alter table 表名 add 列名 数据类型;</li><li>修改列名称 类型<br>alter table 表名 change 列名 新列名 新数据类型;<br>alter table 表名 modify 列名 新数据类型;<br>只改类型，不修改列名</li><li>删除列<br>alter table 表名 drop 列名;</li></ol></li><li>D（Delete）:删除<ul><li>drop table 表名;</li><li>drop table  if exists 表名 ;</li></ul></li></ol><h1 id="DML-增删改表中数据"><a href="#DML-增删改表中数据" class="headerlink" title="DML: 增删改表中数据"></a>DML: 增删改表中数据</h1><ol><li>添加数据：<ul><li>语法：<ul><li><code>insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n)</code>;</li></ul></li><li>注意：<ol><li>列名和值要一一对应。</li><li>如果表名后，不定义列名，则默认给所有列添加值<br><code>insert into 表名 values(值1,值2,...值n)</code>;</li><li>除了数字类型，其他类型需要使用引号（单双都可以）引起来</li></ol></li></ul></li></ol><ol start="2"><li>删除数据： 删除数据但是不删除表<ul><li>语法：<ul><li><code>delete from 表名 [where 条件]</code></li></ul></li><li>注意：<ol><li>如果不加条件，则删除表中所有记录。</li><li>如果要删除所有记录<ol><li>delete from 表名; – 不推荐使用。有多少条记录就会执行多少次删除操作</li><li>TRUNCATE TABLE 表名; – 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</li></ol></li></ol></li></ul></li></ol><ol start="3"><li><p>修改数据：</p><ul><li><p>语法：</p><ul><li><code>update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]</code>;</li></ul></li><li><p>注意：</p><ol><li>如果不加任何条件，则会将表中所有记录全部修改。</li></ol></li></ul></li></ol><h1 id="DQL-查询表中的记录"><a href="#DQL-查询表中的记录" class="headerlink" title="DQL: 查询表中的记录"></a>DQL: 查询表中的记录</h1><ul><li>select * from 表名;</li></ul><ol><li>语法：<br>select 字段列表（字段就是name，age之类的类名）<br>from 表名列表<br>where 条件列表<br>group by 分组字段<br>having 分组之后的条件<br>order by 排序<br>limit 分页限定</li></ol><ol start="2"><li><p>基础查询</p><ol><li>多个字段的查询<br>select 字段名1，字段名2… from 表名；<ul><li>注意：<ul><li>如果查询所有字段，则可以使用*来替代字段列表。</li></ul></li></ul></li><li>去除重复：<ul><li>distinct<br>同时有多个字段的话必须完全一样才会去除<br>seselect distinct 字段名1，字段名2… from 表名；</li></ul></li><li>计算列<ul><li>一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）<br>select 字段名1+字段名2 from 表名；</li><li><code>ifnull(表达式1,表达式2)</code>：null参与的运算，计算结果都为null<ul><li>表达式1：哪个字段需要判断是否为null</li><li>如果该字段为null后的替换值。<br><code>select 字段名1+ifnull(字段名2,替换值) from 表名</code>；</li></ul></li></ul></li><li>起别名：<ul><li>as：as也可以省略<br><code>select 字段名1+ifnull(字段名2,替换值) as 别名 from 表名</code>；</li></ul></li></ol></li><li><p>条件查询</p><ol><li>where子句后跟条件</li><li>运算符<ul><li>&gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;<code>(!=)</code></li><li>BETWEEN…AND     （包含两边）</li><li><code>IN(集合) </code></li><li>LIKE：模糊查询<ul><li>占位符：<ul><li>_:单个任意字符</li><li>%：多个任意字符（字符数≥0）<br>马% 代表着以 马 作为开头的字符串<br>_华% 代表着第二个字是 华 的字符串<br>%马% 代表着包含着 马 的字符串</li></ul></li></ul></li><li>IS NULL  </li><li>and  或 &amp;&amp;</li><li>or  或 || </li><li>not  或 !<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-- 查询年龄大于20岁</span><br><span class="line">SELECT * FROM student WHERE age &gt; 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE age &gt;= 20;</span><br><span class="line"></span><br><span class="line">-- 查询年龄等于20岁</span><br><span class="line">SELECT * FROM student WHERE age = 20;</span><br><span class="line"></span><br><span class="line">-- 查询年龄不等于20岁</span><br><span class="line">SELECT * FROM student WHERE age != 20;</span><br><span class="line">SELECT * FROM student WHERE age &lt;&gt; 20;</span><br><span class="line"></span><br><span class="line">-- 查询年龄大于等于20 小于等于30</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;</span><br><span class="line">SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;</span><br><span class="line">SELECT * FROM student WHERE age BETWEEN 20 AND 30;   包含20和30</span><br><span class="line"></span><br><span class="line">-- 查询年龄22岁，18岁，25岁的信息</span><br><span class="line">SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25</span><br><span class="line">SELECT * FROM student WHERE age IN (22,18,25);</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩为null</span><br><span class="line">SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE english IS NULL;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩不为null</span><br><span class="line">SELECT * FROM student WHERE english  IS NOT NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询姓马的有哪些？ like</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &#x27;马%&#x27;;</span><br><span class="line">-- 查询姓名第二个字是化的人</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;</span><br><span class="line"></span><br><span class="line">-- 查询姓名是3个字的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &#x27;___&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询姓名中包含德的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &#x27;%德%&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL: 查询语句"></a>DQL: 查询语句</h1><ol><li><p>排序查询</p><ul><li><p>语法：order by 子句</p><ul><li>order by 排序字段1 排序方式1 ，  排序字段2 排序方式2…<br>select * from student order by math DESC;</li></ul></li><li><p>排序方式：</p><ul><li>ASC：升序，默认的。</li><li>DESC：降序。</li></ul></li><li><p>注意：</p><ul><li>如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</li></ul></li></ul></li></ol><ol start="2"><li><p>聚合函数：将<strong>一列数据</strong>作为一个整体，进行纵向的计算。</p><ol><li>count：计算个数<ol><li>一般选择非空的列：主键</li><li><code>count(*)</code><br><code>select count(name) from student</code>;<br>显示student表中名字字段的数目</li></ol></li><li>max：计算最大值</li><li>min：计算最小值</li><li>sum：计算和</li><li>avg：计算平均值</li></ol><ul><li>注意：聚合函数的计算，会排除null值。<br>解决方案：<ol><li>选择不包含非空的列进行计算</li><li>IFNULL函数</li></ol></li></ul></li></ol><ol start="3"><li><p>分组查询:</p><ol><li>语法：group by 分组字段；</li><li>注意：<ol><li>分组之后查询的字段：<strong>分组字段、聚合函数</strong>，需要以小组为单位对数据进行处理</li><li>where 和 having 的区别？<ol><li>where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</li><li>where 后不可以跟聚合函数，having可以进行聚合函数的判断。</li></ol></li></ol></li></ol><p> – 按照性别分组。分别查询男、女同学的平均分</p><p> <code>SELECT sex , AVG(math) FROM student GROUP BY sex</code>;<br> <code>sex是分组字段，AVG(math)是聚合函数</code></p><p> – 按照性别分组。分别查询男、女同学的平均分,人数</p><p> <code>SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex</code>;</p><p> –  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组<br> <code>SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex</code>;</p><p> –  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后，只显示人数大于2个人的<br> <code>SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2</code>;</p><p> <code>SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2</code>;</p></li><li><p>分页查询</p><ol><li>语法：limit 开始的<strong>索引</strong>,每页查询的条数;</li><li>公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数</li></ol><p>   – 每页显示3条记录 </p><p>   SELECT * FROM student LIMIT 0,3; – 第1页</p><p>   SELECT * FROM student LIMIT 3,3; – 第2页</p><p>   SELECT * FROM student LIMIT 6,3; – 第3页</p><ol start="3"><li>limit 是一个MySQL”方言”,在Oracle中会有其他的语法</li></ol></li></ol><h1 id="DCL-管理用户，授权"><a href="#DCL-管理用户，授权" class="headerlink" title="DCL: 管理用户，授权"></a>DCL: 管理用户，授权</h1><ul><li>DBA：数据库管理员</li></ul><ol><li><p>管理用户</p><ol><li>添加用户：<ul><li>语法：CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’;</li></ul></li><li>删除用户：<ul><li>语法：DROP USER ‘用户名‘@’主机名’;</li></ul></li><li>修改用户密码：</li></ol><p>   <code>UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;</code><br>   <code>UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;</code></p><p>   <code>SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);</code><br>   <code>SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);</code></p><ul><li>mysql中忘记了root用户的密码？<ol><li>cmd – &gt; net stop mysql 停止mysql服务<ul><li>需要管理员运行该cmd</li></ul></li><li>使用无验证方式启动mysql服务： mysqld –skip-grant-tables</li><li>打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功</li><li>use mysql;</li><li><code>update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;</code>;</li><li>关闭两个窗口</li><li>打开任务管理器，手动结束mysqld.exe 的进程</li><li>启动mysql服务</li><li>使用新密码登录。</li></ol></li></ul><ol start="4"><li>查询用户：</li></ol><p>   – 1. 切换到mysql数据库<br>   USE myql;<br>   – 2. 查询user表<br>   SELECT * FROM USER;</p><ul><li>通配符： % 表示可以在任意主机使用用户登录数据库</li></ul></li></ol><ol start="2"><li><p>权限管理：</p><ol><li>查询权限：</li></ol><p>   – 查询权限<br>   SHOW GRANTS FOR ‘用户名‘@’主机名’;<br>   SHOW GRANTS FOR ‘lisi‘@’%’;</p><ol start="2"><li>授予权限：</li></ol><p>   – 授予权限<br>   grant 权限列表 on 数据库名.表名 to ‘用户名‘@’主机名’;<br>   – 给张三用户授予所有权限，在任意数据库任意表上</p><p>   GRANT ALL ON <em>.</em> TO ‘zhangsan‘@’localhost’;</p><ol start="3"><li>撤销权限：</li></ol><p>   – 撤销权限：<br>   revoke 权限列表 on 数据库名.表名 from ‘用户名‘@’主机名’;<br>   REVOKE UPDATE ON db3.’account’ FROM ‘lisi‘@’%’;`</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2021/09/25/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/09/25/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><ul><li><p>注解概念：说明程序的。<strong>给计算机看的</strong></p></li><li><p>注释：用文字描述程序的。给程序员看的</p></li><li><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p></li><li><p>概念描述：</p><ul><li>JDK1.5之后的新特性</li><li>说明程序的</li><li>使用注解：@注解名称</li></ul></li><li><p>作用分类：</p><ol><li>编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</li><li>代码分析：通过代码里标识的注解对代码进行分析【使用反射】 （主要使用）</li><li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li></ol></li></ul><h1 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h1><ul><li><p>JDK中预定义的一些注解</p><ul><li>@Override    ：检测被该注解标注的方法是否是继承自父类(接口)的</li><li>@Deprecated：该注解标注的内容，表示已过时；在之后程序调用该内容的时候会出现一道横线表示已过时，但仍可以正常使用</li><li>@SuppressWarnings：压制警告，被注解内容的警告将全部不再显示<ul><li>一般传递参数all  <code>@SuppressWarnings(&quot;all&quot;)</code></li></ul></li></ul></li><li><p>自定义注解  见范例1</p><ul><li><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">元注解</span><br><span class="line">public @interface 注解名称&#123;</span><br><span class="line">  属性列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>本质：注解本质上就是一个<strong>接口</strong>，该接口默认继承Annotation接口</p><ul><li>public interface MyAnno extends java.lang.annotation.Annotation {}</li></ul></li><li><p>属性：接口中的抽象方法</p><ul><li><p>要求：</p><ol><li><p>属性的返回值类型有下列取值</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li><p>定义了属性，在使用时需要给属性赋值   <code>@注解(属性1=...，属性2=...)</code> ， 按照属性的返回值的类型进行赋值</p><ol><li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li><li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li></ol></li></ol></li></ul></li><li><p>元注解：用于描述注解的注解</p><ul><li>@Target：描述注解能够作用的位置 如<code>@Target(ElementType.METHOD,ElementType.TYPE)</code><ul><li>ElementType取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li>@Retention：描述注解被保留的阶段<ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</li></ul></li><li>@Documented：描述注解是否被抽取到api文档中</li><li>@Inherited：描述注解是否被子类继承</li></ul></li></ul></li></ul><ul><li>在程序使用（解析）注解：获取注解中定义的属性值  见范例2<ol><li>获取注解定义的位置的对象，（定义在方法上，类上）</li><li>获取指定的注解</li></ol><ul><li><code>getAnnotation(Class)</code><br>其实就是在内存中生成了一个该注解接口的子类实现对象，利用对象调用属性值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ProImpl implements Pro&#123;</span><br><span class="line">    public String className()&#123;</span><br><span class="line">        return &quot;cn.itcast.annotation.Demo1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public String methodName()&#123;</span><br><span class="line">        return &quot;show&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>调用注解中的抽象方法获取配置的属性值 </li></ol></li></ul><ul><li>小结：<ol><li>以后大多数时候，我们会使用注解，而不是自定义注解</li><li>注解给谁用？<ol><li>编译器</li><li>给解析程序用</li></ol></li><li>注解不是程序的一部分，可以理解为注解就是一个标签，对程序本身无影响</li></ol></li></ul><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><ol><li>简单的定义一个注解并调用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public @interface Anno1 &#123;</span><br><span class="line">    int age();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">public class AnnoDemo01 &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算两数的和</span><br><span class="line">     * @param a 整数</span><br><span class="line">     * @param b 整数</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int add(int a, int b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param s</span><br><span class="line">     */</span><br><span class="line">    @Anno1(age = 1)</span><br><span class="line">    public static void tryone(String s)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ul><li>直接在方法前/**加回车即可生成方法注解</li><li>在本类的文件中终端使用javadoc，即可生成注解文件进行查看</li></ul><ol start="2"><li>对自定义注解的内容进行调用，配合反射<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Anno2 &#123;</span><br><span class="line">    int age();</span><br><span class="line">    String name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Anno2(age = 8,name = &quot;张三&quot;)</span><br><span class="line">public class AnnoDemo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class&lt;AnnoDemo02&gt; annoDemo02Class = AnnoDemo02.class;</span><br><span class="line">        Anno2 annotation = annoDemo02Class.getAnnotation(Anno2.class);</span><br><span class="line">        int age = annotation.age();</span><br><span class="line">        String name = annotation.name();</span><br><span class="line">        System.out.println(name+age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出 张三8</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2021/09/25/%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/09/25/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>反射，框架设计的灵魂<br>框架：半成品软件，可以在框架的基础上进行开发，简化代码<br>反射：将类的各个组成部分封装为其他对象，这就是反射机制<br>具体是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制，减少对框架内容的修改。</p><p>好处</p><ol><li>可以在程序的运行过程中，操作这些对象</li><li>可以解耦，提高程序的可扩展性</li></ol><h1 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h1><p>获取class类的三种方式</p><ul><li>类名.class属性  多用于参数的传递</li><li>对象名.getClass()方法  多用于对象的获取字节码的方式</li><li>Class.forName(全类名)方法  多用于配置文件中</li></ul><p> 同一个字节码文件（*.class）在一次程序运行过程中只会被加载一次，不论通过哪种方式获取的class对象都是同一个（多次获取也仍为同一个）</p><h1 id="Class对象功能："><a href="#Class对象功能：" class="headerlink" title="Class对象功能："></a>Class对象功能：</h1><p>使用方式： 先获得class类a，然后 a.对象功能方法<br>获取功能：</p><ol><li><p>获取成员变量们</p><ul><li><code>Field[] getFields()</code> 返回所有公共<code>(public)</code>成员变量对象的数组</li><li><code>Field[] getDeclaredFields()</code> 返回所有成员变量对象的数组</li><li><code>Field getField(String name)</code> 返回单个公共成员变量对象</li><li><code>Field getDeclaredField(String name)</code> 返回单个成员变量对象</li><li><code>成员变量对象.get(类的对象)</code> 获取值  （类的对象可以通过下面的返回构造方法对象来获得）</li><li><code>成员变量对象.set(类的对象，值)</code> 设定值</li><li><code>成员变量对象.setAccessible(true)</code> 忽略private权限修饰符，直接访问，暴力反射（不使用这个get，set无法访问private对象；同理其他也有setAccessible函数，效果相同）</li></ul></li><li><p>获取构造方法们</p><ul><li><code>Constructor&lt;?&gt;[] getConstructors()</code> 返回所有公共构造方法对象的数组</li><li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code> 返回所有构造方法对象的数组</li><li><code>Constructor getConstructor(Class&lt;?&gt;... parameterTypes)</code> 返回单个公共构造方法对象（<code>getConstructor(String.class, int.class)</code>）</li><li><code>Constructor getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code> 返回单个构造方法对象</li><li><code>构造方法对象.newInstance(参数,参数)</code> 创建对象</li><li>如果没有参数 可以直接 <code>a.newInstance()</code>,省略创建构造方法对象的步骤</li></ul></li><li><p>获取成员方法们</p><ul><li><code>Method[] getMethods()</code> 返回所有公共成员方法对象的数组，包括继承的</li><li><code>Method[] getDeclaredMethods()</code> 返回所有成员方法对象的数组，不包括继承的</li><li><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code> 返回单个公共成员方法对象</li><li>无参数 如 <code>getMethod(eat)</code></li><li>有参数 如 <code>getMethod(eat，String.class)</code></li><li><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code> 返回单个成员方法对象</li><li><code>方法对象.invoke(类的对象,方法要传递参数（没有就不写）)</code></li><li><code>方法对象.getName()</code> 获取方法名</li></ul></li><li><p>获取类名</p></li></ol><ul><li><code>String getName()</code></li></ul><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat(String food)&#123;</span><br><span class="line">        System.out.println(&quot;eat&quot;+food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">//        Class&lt;?&gt; aClass = Class.forName(&quot;domain.Person&quot;);</span><br><span class="line">//        System.out.println(aClass);</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">//        System.out.println(personClass);</span><br><span class="line">//        Person p = new Person();</span><br><span class="line">//        Class&lt;? extends Person&gt; aClass1 = p.getClass();</span><br><span class="line">//        System.out.println(aClass1);</span><br><span class="line">        Method method = personClass.getMethod(&quot;eat&quot;,String.class);</span><br><span class="line">        Constructor&lt;Person&gt; constructor = personClass.getConstructor();</span><br><span class="line">        Person person = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        method.invoke(person,&quot;大米&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果<br>输出 eat大米</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit测试</title>
      <link href="/2021/09/24/Junit%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/09/24/Junit%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h1><p>测试分类</p><ul><li>黑盒测试 不需要写代码，关注输入能否得到目标期望值</li><li>白盒测试 需要写代码，关注程序具体流程</li></ul><p>Junit 单元测试就是白盒测试，可以专门建立一个test包，用于测试，不必每次新建一个main函数</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>定义个测试类<ul><li>建议：<ul><li>测试类名：被测试类名Test</li><li>包名：xxxx.xxxx.test   <strong>不可以写成xxxx.xxxx.Test，会和注解重名，导致程序无法运行</strong></li></ul></li></ul></li><li>定义测试方法：可以独立运行<ul><li>建议：<ul><li>方法名：test测试的方法名</li><li>返回值void</li><li>参数列表：空参</li></ul></li></ul></li><li>给方法加@Test注解</li><li>导入junit依赖环境</li><li>之后测试方法左边会出现三角箭头，点击运行，可以一次只测试一个方法</li></ol><h1 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h1><p>判定结果：</p><ul><li>验证结果是否正确的方法一般通过断言<br><code>Assert.assertEquals(期望结果，运算结果)</code></li></ul><p>补充：</p><ul><li><p>初始化方法：用于资源申请，所有测试方法在执行之前都会先执行该方法<br>添加一个@Before</p></li><li><p>释放资源方法：在所有方法执行完后，都会自动执行该方法<br>添加一个@After</p></li><li><p>每个方法测试前后都会执行这两个方法</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class CalculatorTest &#123;</span><br><span class="line">    @Before</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @After</span><br><span class="line">    public void close()&#123;</span><br><span class="line">        System.out.println(&quot;close&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        Calculator cal = new Calculator();</span><br><span class="line">        System.out.println(&quot;test&quot;);</span><br><span class="line">        int add = cal.add(1, 2);</span><br><span class="line">        Assert.assertEquals(3,add);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><img style="width:1000px" src="https://img11.360buyimg.com/ddimg/jfs/t1/6491/10/18261/65587/614d3eacE296136ae/487c8d7608df8d8c.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流</title>
      <link href="/2021/09/23/Stream%E6%B5%81/"/>
      <url>/2021/09/23/Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h1><p>Stream流与IO流无关，类似于lambda的简化，关注的是做什么，而不是怎么做<br>Stream流的好处</p><ul><li>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印</li><li>Stream流把真正的函数式编程风格引入到Java中</li></ul><p>Stream流的特点</p><ul><li>Stream流的是一个来自数据源的元素队列，数据源流的来源，可以是集合，数组等</li><li>Stream流属于管道流，只能被消费使用一次，第一个Stream流调用完毕方法，数据就会流转到下一个Stream上，而此时第一个Stream流已经使用完毕并关闭，无法再调用</li></ul><h1 id="Stream流的使用"><a href="#Stream流的使用" class="headerlink" title="Stream流的使用"></a>Stream流的使用</h1><h2 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h2><p>获取一个流的方式</p><ul><li>Collection体系集合<br>使用默认方法<code>stream()</code>生成流， <code>default Stream stream()</code></li><li>Map体系集合<br>把Map转成Set集合，间接的生成流（<code>set.stream()</code>）</li><li>数组<br>通过Stream接口的静态方法<code>of(T... values)</code>生成流<code>(Stream.of(数组)</code>或者<code>Stream.of(1,2,3,4))</code></li></ul><h2 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h2><p>（基本处理方式大概是每次会对流中的一个元素进行处理，并递进）<br>中间方法的特点：执行完此方法之后，返回值类型仍是Stream接口，Stream流依然可以继续执行其他操作。</p><ul><li><p><code>Stream filter(Predicate predicate)</code> 用于对流中的数据进行过滤<br>Predicate接口是一个判断类的函数式接口，包含一个<code>test(T t)</code>的抽象方法，对数据按照需求进行判断，如果<code>test(T t)</code>返回一个true，则将数据放在新的流中</p></li><li><p><code>Stream limit(long maxSize)</code> 返回此流中的元素组成的流，截取前指定参数个数的数据</p></li><li><p><code>Stream skip(long n)</code> 跳过指定参数个数的数据，返回由该流的剩余元素组成的流</p></li><li><p><code>static Stream concat(Stream a, Stream b)</code> 合并a和b两个流为一个流</p></li><li><p><code>Stream map(Function mapper)</code> 返回由给定函数应用于此流的元素的结果组成的流，将流中的元素映射到另一个流中去<br>Function接口是一个函数式接口，包含抽象方法<code>apply(T t)</code>,可以将T类型转化为R类型</p></li></ul><h2 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h2><p>执行完此方法之后，返回值类型不再是Stream接口，Stream流将不能再执行其他操作。<br>终结方法</p><ul><li><code>void forEach(Consumer action)</code> 对此流的每个元素执行操作<br>Consumer接口是一个消费型的函数式接口，包含一个<code>accept(T t)</code>抽象方法，意味消费一个指定泛型的数据<br>目的是用来遍历流中的数据，并配合accept的Lambda</li><li><code>long count()</code> 返回此流中的元素数</li></ul><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>函数式接口的处理方式就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.filter((test抽象函数参数) -&gt; &#123;test抽象函数内容&#125;).map((...) -&gt; &#123;...&#125;).forEach.((...) -&gt; &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>配合前面的博客食用</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法引用</title>
      <link href="/2021/09/23/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2021/09/23/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>该篇感觉整体较为复杂，理解不很到位，建议需要的时候再去补一下视频</p><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>方法引用<br><code>::</code>该符号为引用运算符，而它所在的表达式被称为方法引用</p><ul><li>Lambda简化写法 <code>usePrintable(s -&gt; System.out.println(s))</code>;</li><li>方法引用 <code>usePrintable(System.out::println)</code>;</li></ul><p>类似于将使用Lambda的地方替换为方法引用，并省略传递参数</p><h1 id="成员方法引用"><a href="#成员方法引用" class="headerlink" title="成员方法引用"></a>成员方法引用</h1><p>通过对象引用类中的成员方法，只要对象存在，成员方法存在<br>格式<br>对象::成员方法<br>范例<br><code>&quot;HelloWorld&quot;::toUpperCase</code><br>String类中的方法：<code>public String toUpperCase()</code> 将此String所有字符转换为大写</p><h1 id="其他引用"><a href="#其他引用" class="headerlink" title="其他引用"></a>其他引用</h1><ul><li>通过类名引用静态成员方法，类已存在，静态成员方法也已经存在</li><li>类似有父类super引用，本类this引用，构造器引用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式接口</title>
      <link href="/2021/09/20/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/09/20/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<ol><li>函数式接口就是仅包含一个抽象方法的接口</li><li>函数式接口可以使用Lambda表达式</li><li>接口做参数，参数传递的可以是接口的实现类</li><li>接口的实现类又可以使用匿名内部类或者Lambda方法进行书写简化</li></ol><p>大概就是这样的内容</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程案例</title>
      <link href="/2021/09/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/09/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><font size="7">文件上传案例分析</font></p><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>文件上传案例的客户端：读取本地文件，上传到服务器，读取服务器回写的数据<br>实现步骤</p><ol><li>创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源</li><li>创建一个客户端socket对象，构造方法中绑定服务器的IP地址和端口号</li><li>使用Socket对象中的方法<code>getOutputStream()</code>获取网络字节输出流OutputStream对象</li><li>使用本地字节输入流FileInputStream对象中的方法read，读取本地文件</li><li>使用网络字节输出流OutputStream对象中的方法write，把读取到的文件上传到服务器</li><li>使用Socket对象中的方法<code>getInputStream()</code>获取网络字节输入流InputStream对象</li><li>使用网络字节输入流InputStream对象的方法read，读取服务器回写数据</li><li>释放资源（FileInputStream，Socket）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DemoUploadClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;D:\\JavaProject\\Client\\1.png&quot;);</span><br><span class="line">        InetAddress dstAddress;</span><br><span class="line">        Socket socket = new Socket(&quot;10.128.196.110&quot;,8888);</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        int len = 0;</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        while ((len = fis.read(bytes))!=-1)&#123;</span><br><span class="line">            outputStream.write(bytes,0,len);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        // 给服务器上传一个终止序列，解决无法停止bug</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        while ((len = inputStream.read(bytes))!=-1)&#123;</span><br><span class="line">            System.out.println(new String(bytes,0,len));</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>文件上传案例的服务器端：读取客户端上传的文件，保存到服务器的硬盘，给客户端回写上传成功<br>实现步骤</p><ol><li>创建服务器ServerSocket对象和系统要指定的端口号</li><li>使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket,接下来使用此Socket的方法</li><li>使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</li><li>判断目标文件夹是否存在，不存在则创建</li><li>创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地</li><li>使用网络字节输入流InputStream对象的方法read，读取客户端上传的文件</li><li>使用本地字节输出流FileOutputStream对象中的方法write，把读取到文件保存到服务器的硬盘上</li><li>使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</li><li>使用网络字节输出流OutputStream对象中的方法write，给客户端回上传成功</li><li>释放资源（FileOutputStream,Socket,ServerSocket）</li></ol><p><strong>客户端和服务器端无法停止</strong>原因解释：<br>因为read方法当没有东西可以读取会陷入到阻塞状态。<br>客户端的while本地文件读取时不会将结束标记写给服务器，<br>导致服务器端永远也读取不到文件的结束标记，read方法进入到阻塞状态</p><p>解决方案：</p><ul><li> 客户端在上传完文件后，给服务器写一个结束标记<br><code>shutdownOutput()</code> : 禁用此套接字的输出流 ，对于TCP套接字，任何以前写入的数据都将被发送，并且后跟TCP的正常连接终止序列<br>这个函数可以给服务器上传一个结束标记</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class DemoUploadServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(8888);</span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        File file = new File(&quot;D:\\JavaProject\\Server&quot;);</span><br><span class="line">        if (!file.exists())&#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">            // 若无文件夹则创建该文件夹</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(&quot;D:\\JavaProject\\Server\\beauty.png&quot;);</span><br><span class="line">        // 具体到文件</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = inputStream.read(bytes))!=-1)&#123;</span><br><span class="line">            fileOutputStream.write(bytes,0,len);</span><br><span class="line">        &#125;</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(&quot;文件上传成功&quot;.getBytes());</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li>添加多线程思路</li><li>使服务器始终处于监听状态，客户端可以一直保持文件的传输</li><li>再添加服务器端存储文件时的名称处理，避免发生文件覆盖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(8888);</span><br><span class="line">//        int i = 1;</span><br><span class="line">        /*</span><br><span class="line">        让服务器不再停止，一直处于运行状态，客户端随时上传数据</span><br><span class="line">         */</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">//            System.out.println(i);</span><br><span class="line">//            i = i+1;</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">            提高效率可以使用多线程技术，有一个客户端上传文件，就开启一个线程，完成文件的上传.</span><br><span class="line">            同时上传很多文件时，开启多个线程，可以提高效率</span><br><span class="line"></span><br><span class="line">            但是本次socket没有释放，可以直接进入下个循环开启新的线程吗?</span><br><span class="line">            2021.9.14已解决</span><br><span class="line">            经过实验，本次的socket即使没有释放，但只要有新的客户端出现依然可以进入下一个循环，</span><br><span class="line">            即代码逻辑正确，出现新的客户端就开启新的线程，不占用主程序，提高利用率</span><br><span class="line">             */</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    // 抽象的run方法没有声明抛出异常，所以重写方法时不能抛出，要用try catch</span><br><span class="line">                    try &#123;</span><br><span class="line">                        InputStream inputStream = socket.getInputStream();</span><br><span class="line">                        File file = new File(&quot;D:\\JavaProject\\Server&quot;);</span><br><span class="line">                        if (!file.exists())&#123;</span><br><span class="line">                            file.mkdirs();</span><br><span class="line">                            // 若无文件夹则创建该文件夹</span><br><span class="line">                        &#125;</span><br><span class="line">                        String filename = &quot;girl&quot;+System.currentTimeMillis()+new Random().nextInt(99999)+&quot;.png&quot;;</span><br><span class="line">                        FileOutputStream fileOutputStream = new FileOutputStream(file+&quot;\\&quot;+filename);</span><br><span class="line">                        // 具体到文件</span><br><span class="line">                        byte[] bytes = new byte[1024];</span><br><span class="line">                        int len = 0;</span><br><span class="line">                        while ((len = inputStream.read(bytes))!=-1)&#123;</span><br><span class="line">                            fileOutputStream.write(bytes,0,len);</span><br><span class="line">                        &#125;</span><br><span class="line">                        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                        outputStream.write(&quot;文件上传成功&quot;.getBytes());</span><br><span class="line">                        fileOutputStream.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;catch (IOException e)&#123;</span><br><span class="line">                        System.out.println(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><img style="width:600px" src="https://img12.360buyimg.com/ddimg/jfs/t1/199636/33/8269/65417/614022aeE0cdb838b/d04ad01b3049d175.png"><img style="width:600px" src="https://img11.360buyimg.com/ddimg/jfs/t1/77566/21/16909/107959/6140233fE71163afb/a204cea54d51c0a6.png">]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2021/09/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/09/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>网络编程就是在一定的协议下，实现两台计算机的通信的程序<br>网络编程三要素</p><ul><li>IP地址<br>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机<br>和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识</li><li>端口<br>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？<strong>如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了,也就是应用程序的标识</strong></li><li>协议<br>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则<br>被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，<strong>通信双方必须同时遵守才能完成数据交换</strong>。常见的协议有<strong>UDP</strong>协议和<strong>TCP</strong>协议<br>UDP效率高但是会数据丢失，TCP确保数据传输，但是效率不如UDP</li></ul><h1 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h1><img style="width:1000px" src="https://img10.360buyimg.com/ddimg/jfs/t1/205024/13/6374/1504379/613ef2cfE35c31638/1e53ecf8009f10de.jpg">  <p>注意服务器端必须明确的两件事情</p><h2 id="TCP通信的客户端"><a href="#TCP通信的客户端" class="headerlink" title="TCP通信的客户端"></a>TCP通信的客户端</h2><p>向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据<br>表示客户端的类：</p><ul><li>Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点<br>套接字：包含了IP地址和端口号的网络单位</li></ul><p>构造方法</p><ul><li><p><code>Socket(InetAddress address,int port)</code> 创建流套接字并将其连接到指定IP指定端口号</p></li><li><p><code>Socket(String host, int port)</code> 创建流套接字并将其连接到指定主机上的指定端口号<br>host 服务器主机的名称/服务器的IP地址，使用时要加引号<br>port 服务器的端口号</p></li></ul><p>成员方法</p><ul><li><code>InputStream getInputStream()</code> 返回此套接字的输入流</li><li><code>OutputStream getOutputStream()</code> 返回此套接字的输出流</li></ul><p>实现步骤</p><ol><li>创建一个客户端对象socket，构造方法绑定服务器的IP地址和端口号</li><li>使用Socket对象中的方法<code>getOutputStream()</code>获取网络字节输出流OutputStream对象,由客户端发向服务器端</li><li>使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据</li><li>使用Socket对象中的方法<code>getInputStream()</code>获取网络字节输入流InputStream对象，由服务器端发向客户端</li><li>使用网络字节输入流InputStream对象的方法read，读取服务器回写数据</li><li>释放资源（socket）</li></ol><p>注意事项</p><ul><li>客户端和服务器交互必须使用socket中提供的网络流，不能使用自己创建的流对象</li><li>当我们创建客户端对象socket的时候，就会去请求服务器和服务器经过3次握手建立连接通路<ol><li>这时如果服务器没有启动，那么就会抛出异常</li><li>如果服务器已经启动，那么就可以进行交互了</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TCPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket = new Socket(&quot;10.128.196.110&quot;,8888);</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(&quot;你好服务器&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int len = inputStream.read(bytes);</span><br><span class="line">        System.out.println(new String(bytes,0,len));</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="TCP通信的服务器端"><a href="#TCP通信的服务器端" class="headerlink" title="TCP通信的服务器端"></a>TCP通信的服务器端</h2><p>接收客户端请求，读取客户端发送的数据，给客户端回写数据<br>表示服务器的类</p><ul><li> ServerSocket 此类实现服务器套接字</li></ul><p>构造方法</p><ul><li> <code>ServletSocket(int port)</code> 创建绑定到指定端口的服务器套接字</li></ul><p>服务器端必须知道哪个客户端请求的服务器,所以可以使用accept方法获取到请求的客户端对象socket</p><ul><li><code> Socket accept()</code> 监听要连接到此的套接字并接受它</li></ul><p>服务器的实现步骤</p><ol><li>创建服务器ServerSocket对象和系统要指定的端口号</li><li>使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket,接下来使用此Socket的方法</li><li>使用Socket对象中的方法<code>getInputStream()</code>获取网络字节输入流InputStream对象，由客户端发向服务器端</li><li>使用网络字节输入流InputStream对象的方法read，读取客户端发送的数据</li><li>使用Socket对象中的方法<code>getOutputStream()</code>获取网络字节输出流OutputStream对象,由服务器端发向客户端</li><li>使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据</li><li>释放资源（Socket，ServerSocket）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TCPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(8888);</span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int len = inputStream.read(bytes);</span><br><span class="line">        System.out.println(new String(bytes,0,len));</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(&quot;收到谢谢&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在客户端和服务器端使用while大量接受字节流出现报错，暂时没有解决</li></ul><p>2021.9.14已解决，具体解决方案在网络编程案例中，大概原因时客户端没有给服务器上传结束标记，造成阻塞</p><p>要先运行服务器端，此时服务器端会一直保持运行，直到客户端开始运行并完成网络信息交互，服务器端才会释放资源完成运行</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><img style="width:600px" src="https://img13.360buyimg.com/ddimg/jfs/t1/61047/37/17197/21579/613ef4b3E6eda65f3/4034ba6678d9d1d4.png">  <img style="width:600px" src="https://img11.360buyimg.com/ddimg/jfs/t1/198270/6/8359/20015/613ef4ecE5f726df0/bc934472ff3cc560.png">  ]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓冲流</title>
      <link href="/2021/09/07/%E7%BC%93%E5%86%B2%E6%B5%81/"/>
      <url>/2021/09/07/%E7%BC%93%E5%86%B2%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>缓冲流是对IO流的一种增强<br>给基本的流对象增加一个缓冲区（数组），<strong>提高流对象的效率</strong></p><h1 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h1><p>节缓冲输出流 继承父类OutputStream的成员方法<br><code>BufferedOutputStream(OutputStream out)</code> 创建字节缓冲输出流对象<br>使用步骤</p><ol><li>创建FileOutputStream对象，构造方法中绑定要输出的目的地</li><li>创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象</li><li>使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中</li><li>使用BufferedOutputStream对象中的方法flush，把内部缓冲区中的数据刷新到文件中</li><li>释放资源（第4步可以省略）</li></ol><h1 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h1><p>字节缓冲输入流 继承父类InputStream的成员方法<br><code>BufferedInputStream(InputStream in)</code> 创建字节缓冲输入流对象</p><p>使用步骤（重点）</p><ol><li>创建FileIutputStream对象，构造方法中绑定要读取的数据源</li><li>创建BufferedIutputStream对象，构造方法中传递FileIutputStream对象</li><li>使用BufferedIutputStream对象中的方法read，读取文件</li><li>释放资源</li></ol><h1 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h1><p>字符缓冲输出流 继承writer的所有成员方法<br><code>BufferedWriter(Writer out)</code> 创建字符缓冲输出流对象<br>特有方法</p><ul><li><code>void newLine()</code> 写一行行分隔符，行分隔符字符串由系统属性定义，为输出完成换行</li></ul><p>使用步骤</p><ol><li>创建字符缓冲输出流对象，构造文件中传递字符输出流</li><li>调用字符缓冲输出流中的方法write，把数据写入到内存缓冲区中</li><li>调用字符缓冲流中的方法flush，把内存缓冲区中的数据率刷新到文件中</li><li>释放资源</li></ol><h1 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h1><p>字符缓冲输入流 继承了Reader的所有成员方法<br><code>BufferedReader(Reader in)</code> 创建字符缓冲输入流对象<br>特有方法</p><ul><li><code>String readLine()</code> 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符(例如换行符)，如果流的结尾已经到达（超过有内容的最后一行），则为null</li></ul><p>使用步骤</p><ol><li>创建字符缓冲输入流对象，构造文件中传递字符输入流</li><li>使用字符缓冲输入流对象中的方法read/readline读取文本</li><li>释放资源</li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试代码<br>把一个文件的乱序内容排序输出到一个新的文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class DemoTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        TreeMap&lt;String, String&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">        BufferedReader br = new BufferedReader(new FileReader(&quot;Demo03\\demo.txt&quot;));</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;Demo03\\out.txt&quot;));</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null)&#123;</span><br><span class="line">            String[] ary = line.split(&quot;\\.&quot;);</span><br><span class="line">            // .是转义字符，需要\\处理</span><br><span class="line">            map.put(ary[0],ary[1]);</span><br><span class="line">            // Treemap会自动排序</span><br><span class="line">        &#125;</span><br><span class="line">        for (String key: map.keySet()</span><br><span class="line">             ) &#123;</span><br><span class="line">            String s = map.get(key);</span><br><span class="line">            line = key + &quot;.&quot; + s;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文件内容<br><img style="width:800px" src="https://img14.360buyimg.com/ddimg/jfs/t1/202453/23/5437/18820/61370ae5E4d56dcbd/48a5355f33b6a648.png">  </p><p>新文件内容<br><img style="width:800px" src="https://img13.360buyimg.com/ddimg/jfs/t1/197544/5/7185/16599/61370b2dEa045d152/241f1d28ff83659c.png">  </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生开学了</title>
      <link href="/2021/08/30/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%BC%80%E5%AD%A6%E4%BA%86/"/>
      <url>/2021/08/30/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%BC%80%E5%AD%A6%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>9月1号就要滚回学校开学了，希望开学可以与室友同学保持良好的交流关系，与工友建立积极的合作关系，与导师最好是亦师亦友的高效关系，少遇到一些脑瘫，多遇到贵人，生活每天快快乐乐。</p><p>还要督促自己每天加油学习+减肥，学习不能停；一定要努力完成导师布置的任务，少被导师骂，导师人很好，骂你是因为你不争气，要保持积极向上的心，不要因为被骂过于影响自己的心态，学会去调整自己的不成熟；有目的地提升编程能力，奥里给。</p><p>最后，希望这新的学期可以找到一个我喜欢，也喜欢我的漂亮女朋友，短发女孩儿天下第一。<br><img style="width:1000px" src="https://img11.360buyimg.com/ddimg/jfs/t1/196674/23/20765/171357/612cd0a2E5f19f10c/cc2cf02c458aa39b.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2021/08/29/IO%E6%B5%81/"/>
      <url>/2021/08/29/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><img style="width:1000px" src="https://s3.bmp.ovh/imgs/2021/08/08a961692c56b99f.png"><p><strong>流向内存是输入流（从文件调用内容），流出内存的是输出流（向文件存储内容）</strong></p><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>输出字节流的一些子类的共性成员方法</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。</li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li><li><code>public void write(byte[] b)</code> ：将 b.length字节从指定的字节数组写入此输出流。</li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。</li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><p>小贴士： </p><ol><li>close方法，当完成流的操作时，<strong>必须</strong>调用此方法，释放系统资源。</li><li><code>byte[] getBytes()</code> 把字符串转换为字节数组</li></ol><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>文件字节输出流 继承了OutputStream<br>把内存中的数据写入到硬盘的文件中</p><ul><li><code>public FileOutputStream(File file)</code> ：创建文件输出流以写入由指定的File对象表示的文件。</li><li><code>public FileOutputStream(String name)</code> ： 创建文件输出流以指定的名称写入文件。</li></ul><p><strong>但是这样的方法写入不是续写，而是每次直接全部重写</strong></p><p>构造方法的作用</p><ol><li>创建一个FileOutputStream对象</li><li>会根据构造方法中传递的文件/文件路径，创建一个空的文件</li><li>会把FileOutputStream对象指向创建好的文件</li></ol><p>字节输出流的使用步骤（重点）</p><ol><li>创建一个FileOutputStream对象，构造方法中传递写入数据的目的地</li><li>调用FileOutputStream对象中的方法write，把数据写入到文件中</li><li>释放资源</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01OutputStream &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;Demo03\\a.txt&quot;);</span><br><span class="line">        // 相对路径（相对的是这个module，即Demo_NewTeacher）和绝对路径都可以，一个\是转义字符，要\\才行</span><br><span class="line">        fos.write(97);</span><br><span class="line">        // 存储时会把十进制97转化为二进制，因为存储的是是字节，打开文件的时候（如记事本），会自动</span><br><span class="line">        // 把字节转化为字符，此时存储的97就显示为了a</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件存储的是 a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01OutputStream &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(new File(&quot;Demo03\\a.txt&quot;));</span><br><span class="line">        // 不是续写，而是每次直接重写a.txt</span><br><span class="line">        byte[] bytes = &#123;65, 66, 67, 68, 69, 70&#125;;</span><br><span class="line">        byte[] bytes1 = &quot;你好&quot;.getBytes();</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        fos.write(bytes1);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件中存储的是 ABCDEF你好</p><p>续写文件的方法</p><ul><li><code>public FileOutputStream(File file, boolean append)</code> ： 创建文件输出流以写入由指定的 File对象表示的 文件。</li><li><code>public FileOutputStream(String name, boolean append)</code> ： 创建文件输出流以指定的名称写入文件。<br>这两个构造方法，参数中都需要传入一个boolean类型的值， true 表示追加数据， false 表示清空原有数据。</li></ul><p>文件换行的方法</p><ul><li><code>write(&quot;\r\n&quot;.getBytes())</code> 换行</li></ul><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。</li><li><code>public abstract int read()</code> ： 从输入流读取数据的下一个字节，返回的是每个字符对应的ASCAII码数字（一个汉字需要3个字符）</li><li><code>public int read(byte[] b)</code> ： 从输入流中读取一些字节数，并将它们存储到字节数组b中 。<br>小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。</li></ul><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>文件字节输入流<br>作用 把硬盘文件中的数据读取到内存中使用</p><p>构造方法</p><ul><li><code>FileInputStream(File file)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的File对象 file命名。</li><li><code>FileInputStream(String name)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</li></ul><p>使用步骤</p><ol><li>创建一个FileInputStream对象，构造方法中绑定要读取的数据源</li><li>使用FileInputStream对象中的read方法，读取文件</li><li>释放资源</li></ol><p>注意:</p><ol><li>每次调用<code>read()</code>指针会自动向后移，读取到文件的末尾返回-1</li><li><code>String(byte[] bytes)</code>把字节数组bytes转换为字符串，打印的是AB<br><code>Arrays.toString(bytes) </code>打印的是65，66（把指定数组内容变为逗号分隔的字符串）<br> <strong>⬆⬆⬆⬆⬆⬆⬆注意区分</strong><br><code>String(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从off开始转换b数组。</li><li>一次读取多个字节的<code>read(byte[] b)</code>同样会在每次读取后指针向后移，参数<code>byte[]</code>存储每次读到的多个字节，返回值为每次读取的有效字节个数，无新字节返回-1</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo02InPutStream &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;Demo03\\a.txt&quot;);</span><br><span class="line">        int read = fis.read();</span><br><span class="line">        System.out.println(read);</span><br><span class="line">        // 每次调用read指针会自动向后移，读取到文件的末尾返回-1</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回A</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo02InPutStream &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;Demo03\\a.txt&quot;);</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = fis.read(bytes)) != -1)&#123;</span><br><span class="line">            System.out.println(new String(bytes, 0, len));</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回ABCDEF你好</p><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p>字符流 以字符为单位读写数据，专门用于处理文本文件。</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>字符输入流 Reader<br>基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。</li><li><code>public int read() </code>： 从输入流读取一个字符。</li><li><code>public int read(char[] cbuf)</code> ： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>文件字符输入流<br>构造方法</p><ul><li><code>FileReader(File file)</code> ： 创建一个新的 FileReader ，给定要读取的File对象。</li><li><code>FileReader(String fileName)</code> ： 创建一个新的 FileReader ，给定要读取的文件的名称。</li></ul><p>步骤</p><ol><li>创建FileReader对象，构造方法中绑定要读取的数据源</li><li>使用FileReader对象中的方法read读取文件</li><li>释放资源</li></ol><p>他是一个一个的读取字符，“你”就输出20320，即输出的是一个字符完整的二进制字节<br>可以用（char）xx 强制将二进制字节转化为字符</p><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>字符输出流 Writer</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf)</code> 写入字符数组。</li><li><code>abstract void write(char[] cbuf, int off, int len)</code> 写入字符数组的某一部分,off数组的开始索引,len 写的字符个数。</li><li><code>void write(String str)</code> 写入字符串。</li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush()</code> 刷新该流的缓冲。 <code>void close()</code> 关闭此流，但要先刷新它。</li></ul><h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p>文件字符输出流，作用：把内存中的字符数据写入到文件中</p><p>构造方法</p><ul><li><code>FileWriter(File file)</code> ： 创建一个新的 FileWriter，给定要读取的File对象。</li><li><code>FileWriter(String fileName)</code> ： 创建一个新的 FileWriter，给定要读取的文件的名称。</li></ul><p>步骤（重要）</p><ol><li>创建FileWriter对象，构造方法中绑定要写入数据的目的地</li><li>使用FileReader对象中的方法write，把数据写入到内存缓冲区中（字符转化为字节的过程）</li><li>使用FileReader中的方法flush，把内存缓冲区中的数据刷新到文件中</li><li>释放资源（会先把内存缓冲区中的数据刷新到文件中，用close就可以不用flush）</li></ol><p>续写</p><ul><li><code>FileWriter（。。。, boolen append）</code></li></ul><p>换行</p><ul><li><code>\r\n</code><br>（因为可以写入字符串，直接写进去就可以换行，不需要转换）</li></ul><p>小贴士：</p><ul><li>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</li><li>当我们单纯读或者写文本文件时，使用字符流，其他情况使用字节流</li></ul><h1 id="IO异常处理"><a href="#IO异常处理" class="headerlink" title="IO异常处理"></a>IO异常处理</h1><p>在实际开发中处理这样的IO异常要使用try。。catch。。finally，不要抛出处理<br>处理过程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HandleException1 &#123; </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        // 声明变量 </span><br><span class="line">        FileWriter fw = null; </span><br><span class="line">        try &#123;</span><br><span class="line">            //创建流对象 </span><br><span class="line">            fw = new FileWriter(&quot;fw.txt&quot;); </span><br><span class="line">            // 写出数据 </span><br><span class="line">            fw.write(&quot;黑马程序员&quot;); //黑马程序员 </span><br><span class="line">        &#125; catch (IOException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; finally &#123; </span><br><span class="line">            try &#123;</span><br><span class="line">                if (fw != null) &#123; </span><br><span class="line">                    fw.close(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; catch (IOException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用JDK7优化后的 try-with-resource 语句来处理异常，该语句确保了每个资源在语句结束时关闭。<br>所谓的资源 （resource）是指在程序完成后，必须关闭的对象，即会自动把流对象释放，不用在finally中写close</p><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (创建流对象语句，如果多个,使用&#x27;;&#x27;隔开)&#123;</span><br><span class="line">// 读写数据</span><br><span class="line">&#125;catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK9又进行优化<br>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">B b = new B();</span><br><span class="line">try(a;b)&#123;</span><br><span class="line">    读写数据</span><br><span class="line">&#125;catch(....)&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h1><p>Properties集合是一个唯一可以和IO流相结合的集合<br>可以对IO流进行store和load操作</p><ul><li><code>public void load(InputStream inStream)</code>： 从字节输入流中读取键值对。<br>参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filename=a.txt</span><br><span class="line">length=209385038</span><br><span class="line">location=D:\a.txt</span><br></pre></td></tr></table></figure></li></ul><p>加载代码演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class ProDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws FileNotFoundException &#123;</span><br><span class="line">        // 创建属性集对象</span><br><span class="line">        Properties pro = new Properties();</span><br><span class="line">        // 加载文本中信息到属性集</span><br><span class="line">        pro.load(new FileInputStream(&quot;read.txt&quot;));</span><br><span class="line">        // 遍历集合并打印</span><br><span class="line">        Set&lt;String&gt; strings = pro.stringPropertyNames();</span><br><span class="line">        for (String key : strings ) &#123;</span><br><span class="line">          System.out.println(key+&quot; -- &quot;+pro.getProperty(key));</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">filename -- a.txt</span><br><span class="line">length -- 209385038</span><br><span class="line">location -- D:\a.txt</span><br></pre></td></tr></table></figure><p>小贴士：</p><ol><li>文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。</li></ol><h1 id="字节字符转换问题"><a href="#字节字符转换问题" class="headerlink" title="字节字符转换问题"></a>字节字符转换问题</h1><p>文件存储是字节，字符变为字节是编码，字节变为字符是解码<br>编码解码必须是同一套charset机制</p><ul><li>IDEA默认的是UTF-8编码</li><li>windows系统创建的文本文件是默认GBK编码，这样子会产生乱码（但我尝试了下，好像现在是默认UTF-8了）</li></ul><p>对此需要使用转换流来进行处理</p><h2 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h2><p>继承了writer，OutputStreamWriter是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节<br>（编码，能看懂的变成看不懂的）<br>构造方法</p><ul><li><code>OutputStreamWriter(OutputStream out)</code> 创建使用默认字符编码的 OutputStreamWriter，默认UTF-8。</li><li><code>OutputStreamWriter(OutputStream out, String charsetName)</code> 创建使用指定字符集的 OutputStreamWriter。</li></ul><p>参数</p><ul><li>OutputStream out 字节输出流</li><li>String charsetName 指定的编码表面名称，不区分大小写</li></ul><p>使用步骤</p><ol><li>创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称</li><li>使用OutputStreamWriter对象中的方法write，把字符转换为字节存储到缓冲区中</li><li>使用OutputStreamWriter对象中的方法flush，刷新。。</li><li>资源释放</li></ol><h2 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h2><p>继承了Reader，InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符<br>（解码，看不懂的变成能看懂的）<br>构造方法</p><ul><li><code>InputStreamReader(InputStream in)</code> 创建一个使用默认字符集的 InputStreamReader。</li><li><code>InputStreamReader(InputStream in, String charsetName)</code> 创建使用指定字符集的 InputStreamReader。</li></ul><p>参数</p><ul><li>InputStream in 字节输入流</li></ul><p>使用步骤</p><ol><li>建IutputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称</li><li>使用InputStreamReader对象中的方法read读取文件</li><li>释放资源</li></ol><p>注意事项</p><ul><li>构造方法中指定的编码表名称要和文件的编码<strong>相同</strong>，否则会发生乱码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Demo04FileReaderProlem &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        write_gbk();</span><br><span class="line">        read_gbk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void read_gbk() throws IOException &#123;</span><br><span class="line">        InputStream in;</span><br><span class="line">        Charset charset;</span><br><span class="line">        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;Demo03\\gbk.txt&quot;), &quot;gbk&quot;);</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = isr.read()) != -1)&#123;</span><br><span class="line">            System.out.println((char)len);</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void write_gbk() throws IOException &#123;</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;Demo03\\gbk.txt&quot;),&quot;gbk&quot; );</span><br><span class="line">        osw.write(&quot;你好啊&quot;);</span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以GBK的方式写入写出，读出的文件用char强制转换是<br>你<br>好<br>啊<br>如果不强制转换输出<br>20320<br>22909<br>21834</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2021/08/27/%E9%80%92%E5%BD%92/"/>
      <url>/2021/08/27/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>递归分为两种</p><ul><li>直接递归 自己调用自己</li><li>简介递归 A调B，B调C，C调A</li></ul><p>注意事项</p><ul><li>递归一定要有条件限制，保证递归可以停下来，否则会发生栈内存溢出</li><li>在递归中即使有限定条件，递归次数也不能太多，否则也会发生栈内存溢出</li><li>构造方法，禁止递归</li></ul><p>当调用方法的时候，方法的主体不变，每次调用方法的参数不同，可以使用递归，如累加</p><p>（前面有一个关于File类的使用讲解，简单听了听，没做什么笔记，需要到时候再去看）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2021/08/25/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/08/25/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发： 当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态，这种方式我们称之为并发 （Concurrent）。</p><p>并行： 当系统有一个以上CPU时,则线程的操作有可能非并发。 当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行 （Parallel）。</p><p>区别： 并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。</p><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>进程： 是指一个内存中运行的应用程序<br>线程： 线程是进程中的一个执行单元<br>一个程序运行至少有一个进程，一个进程可以包含多个线程<br><strong>一个cpu同一时刻只能处理一个线程</strong><br><img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/16/29/53e95591-46fa-4527-bb06-7c9e0babf6a7.png"> </p><ul><li>主线程：执行主（main）方法的线程</li><li>单线程程序：java程序中只有一个线程</li><li>执行从main方法开始，从上到下依次执行，一旦出现异常会影响后续程序的执行</li></ul><h1 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h1><h2 id="创建Thread类的子类"><a href="#创建Thread类的子类" class="headerlink" title="创建Thread类的子类"></a>创建Thread类的子类</h2><p>创建多线程程序的第一种方式：创建Thread类的子类<br>实现步骤</p><ol><li>创建一个Thread类的子类</li><li>在Thread类的子类中重写Thread类的run方法，设置线程任务（开启线程要做什么）</li><li>创建Thread类的子类对象</li><li>调用Thread类的start方法，开启新的线程，执行run方法<br>结果两个线程并发的运行，main线程和创建的执行run方法的新线程<br>java程序属于抢占式调度，哪个线程优先级高，哪个线程就优先执行,每次执行结果都不太相同</li></ol><p>Thread类中的方法</p><ul><li><code>getName()</code>返回线程的名称</li><li><code>currentThread()</code> 静态方法，返回对当前正在执行的线程对象的引用</li><li><code>setName(&quot;&quot;)</code> 给线程起名字</li><li>创建一个带参数的构造方法，参数传递线程名称，然后调用父类的带参构造方法<code>super(&quot;name&quot;)</code></li><li><code>sleep(long millis)</code> 使线程以指定时间ms暂停，该线程放弃对cpu的执行权<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2>创建多线程的第二种方式:实现Runnable接口<br>实现步骤</li></ul><ol><li>创建Runnable的实现类</li><li>重写run方法，设置线程任务</li><li>创建一个Runnable接口的实现类对象</li><li>创建Thread类对象，构造方法中传递Runnable的实现类对象</li><li>调用thread类的start方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 定义实现类</span><br><span class="line">public class RunnableImpl implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主程序</span><br><span class="line">public class Demo02Runnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RunnableImpl able = new RunnableImpl();</span><br><span class="line">        Thread thread = new Thread(able);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果<img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/16/45/6866b434-ef41-4e06-8fd6-190e57c42d18.png"> </li></ol><p>实现Runnable接口创建多线程的好处（即第一类创建方法的缺点）</p><ul><li>避免了单继承的局限性</li><li>增强了程序的扩展性，降低了程序的耦合性，把设置线程任务（实现类重写run）和开启新线程（创建Thread类对象）进行了分离</li><li>适合多个相同的程序代码的线程去<strong>共享一个</strong>资源<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2>作用为简化代码,但在之后学习的Lambda方法在特定情况下会更为简化一些<br>格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 父类/接口（）&#123;</span><br><span class="line">   重写父类/接口中的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>之后再进行组合，具体过程见InnerClass<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Demo03InnerClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+&quot;nihao&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;-------&gt;&quot;+&quot;fk&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>多线程访问了共享的数据，会产生线程安全问题（三个人吃一个蛋糕，A吃了一口以后，B再去吃蛋糕却仍保持原状，就是线程安全问题）<br><img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/16/31/0cc923b8-88bf-4e9d-b44c-0442400729da.png"> </p><p>为了保证每个线程都正常执行，引入线程同步机制,有三种同步方法</p><ol><li>同步代码块</li><li>同步方法</li><li>锁机制</li></ol><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>代码块写在方法中<br>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized（锁对象）&#123;</span><br><span class="line">    可能会出现线程安全问题的代码（访问了共享数据的代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>锁对象任意，叫同步锁，对象锁，对象监视器</li><li>但必须多个线程使用同一个锁对象（写在run方法外面，写在里面会重复创建），当锁对象被一个线程使用的时候，其他线程就没有锁对象，无法运行对应的代码块</li><li>锁对象把同步代码块锁住，只让一个线程在同步代码块中执行</li><li>不停判断同步锁，降低效率</li><li><strong>即使该代码块出现sleep也仍然执行这个代码块，但是wait会跳出该代码块</strong></li></ul><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>使用步骤</p><ol><li>把访问共享数据的代码抽取出来，放到一个方法中</li><li>在方法上添加synchronized修饰符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 synchronized 返回值类型  方法名（参数列表）&#123;</span><br><span class="line">     可能会出现线程安全问题的代码（访问了共享数据的代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在run方法外定义，run方法内调用即可</li></ol><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>实现了比synchronized更广泛的锁定操作<br>lock（） 获取锁<br>unlock（） 释放锁</p><p>使用步骤</p><ol><li>在成员位置（run方法外面,类似于类中成员变量的位置）创建一个ReentrantLock对象 Lock l = new ReentrantLock()</li><li>在可能出现安全问题的代码前调用Lock接口的方法lock（）获取锁 l.lock()</li><li>在可能出现安全问题的代码后调用Lock接口的方法unlock（）释放锁 l.unlock()</li></ol><h1 id="等待唤醒"><a href="#等待唤醒" class="headerlink" title="等待唤醒"></a>等待唤醒</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>等待唤醒案例：<strong>线程之间通信</strong><br>创建一个顾客线程（消费者）： 告知老板的种类和数量，调用<strong>wait</strong>方法，放弃cpu的执行，进入到WAITING状态（<em>无限等待</em>）<br>创建一个老板线程（生产者）： 花了5s做包子，做好之后，调用<strong>notify</strong>方法，唤醒顾客吃包子<br><img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/16/40/ce0a01c5-6994-40f9-bcd5-39bb30375541.png"> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Demo04WaitAndNotify &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object obj = new Object();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                    /*sleep一定要放在同步代码块外面，放在里面即使sleep也不会跳出执行，会被对象锁锁住</span><br><span class="line">                    不管线程先执行哪个，</span><br><span class="line">                    1.先执行老板线程，遇到sleep，老板线程挂起5s钟，在挂起时立即执行顾客线程，遇到wait，顾客线程也挂起（不再被对象锁锁住）</span><br><span class="line">                    ，等到5s后，老板线程继续执行，触发notify(此时顾客线程唤醒)并执行完同步代码块中的任务后，顾客线程开始执行wait</span><br><span class="line">                    之后的内容</span><br><span class="line">                    2.顾客先执行线程同理，顾客wait后，老板线程执行，sleep之后因为顾客线程等待，不会发生线程转换而是继续执行老板线程，之后。。</span><br><span class="line">                    */</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (obj) &#123;</span><br><span class="line">                    System.out.println(&quot;老板5s后包子出锅&quot;);</span><br><span class="line"></span><br><span class="line">                    obj.notify();</span><br><span class="line">                    System.out.println(&quot;?&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (obj) &#123;</span><br><span class="line">                    System.out.println(&quot;顾客告知想吃的包子种类和数量&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;包子做好了，真好吃&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>notify唤醒wait的线程重新加入对cpu的竞争中，优先唤醒等待时间最长的线程</li><li>notifyall唤醒所有等待的线程</li></ul><p>注意</p><ul><li>顾客和老板线程必须使用同步代码块包裹起来，等待和唤醒只能有一个在执行</li><li>唯一的锁对象才能调用wait和notify方法，<strong>对于同一锁对象的各个线程，若一个线程调用wait和notify，wait使本线程锁住，notify唤醒其他线程（只要是一个锁对象，不同的线程之间就可以互相通信操作）</strong></li><li>不同线程的不同同步代码块只要是<strong>同一个锁对象</strong>，就只能有一个在运行</li></ul><h2 id="具体的等待唤醒机制"><a href="#具体的等待唤醒机制" class="headerlink" title="具体的等待唤醒机制"></a>具体的等待唤醒机制</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。<br>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：<br>包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子 （即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。 接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包 子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取 决于锁的获取情况。<br>详见下图ThreadProject</p><h3 id="包子类"><a href="#包子类" class="headerlink" title="包子类"></a>包子类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BaoZi &#123;</span><br><span class="line">    String pi;</span><br><span class="line">    String xian;</span><br><span class="line">    boolean flag = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包子铺线程"><a href="#包子铺线程" class="headerlink" title="包子铺线程"></a>包子铺线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class BaoZiPu extends Thread&#123;</span><br><span class="line">    private BaoZi bz;</span><br><span class="line"></span><br><span class="line">    public BaoZiPu(BaoZi bz) &#123;</span><br><span class="line">        this.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    // 从外部传来相同的包子类对象作为对象锁</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            synchronized (bz)&#123;</span><br><span class="line">                if (bz.flag==true)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                        // 包子铺线程挂起</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (count%2==0)&#123;</span><br><span class="line">                    bz.pi = &quot;薄皮&quot;;</span><br><span class="line">                    bz.xian = &quot;三鲜馅&quot;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    bz.pi = &quot;冰皮&quot;;</span><br><span class="line">                    bz.xian= &quot;牛肉大葱&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(&quot;包子铺正在生产：&quot;+bz.pi+bz.xian+&quot;包子&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                bz.flag = true;</span><br><span class="line">                bz.notify();</span><br><span class="line">                // 唤醒吃货线程</span><br><span class="line">                System.out.println(&quot;包子已经成产好了：&quot;+bz.pi+bz.xian+&quot;包子，吃货可以开始吃了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="吃货"><a href="#吃货" class="headerlink" title="吃货"></a>吃货</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ChiHuo extends Thread&#123;</span><br><span class="line">    private BaoZi bz;</span><br><span class="line"></span><br><span class="line">    public ChiHuo(BaoZi bz) &#123;</span><br><span class="line">        this.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            synchronized (bz)&#123;</span><br><span class="line">                if (bz.flag==false)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;吃货正在吃：&quot;+bz.pi+bz.xian+&quot;包子&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                bz.flag = false;</span><br><span class="line">                System.out.println(&quot;吃货吃完了包子&quot;);</span><br><span class="line">                System.out.println(&quot;======================&quot;);</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BaoZi baoZi = new BaoZi();</span><br><span class="line">        new BaoZiPu(baoZi).start();</span><br><span class="line">        new ChiHuo(baoZi).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/16/52/58ace8b2-930f-495a-8bb1-e17e43c549df.png"> <h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作， 无需反复创建线程而消耗过多资源<br><img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/17/01/cb4b15bb-a079-4fdf-af80-2ca746d94271.png"> </p><p>创建线程池要使用Executors类中的静态方法<br>static ExecutorService newFixedThreadPool（int nThreads）</p><ul><li>参数为线程池中的线程数量</li><li>返回值 返回ExecutorService接口的实现类对象<br>submit（Runnable task） 提交一个runnable任务用于执行，即从线程池获取一个线程，调用start<br>shutdown（） 关闭/销毁线程</li></ul><p>使用步骤</p><ol><li>newFixedThreadPool生产线程池</li><li>创建一个类，实现Runnable接口，重写run</li><li>调用submit，开启线程，执行run，执行之后会自动归还线程，但主程序并不会停止，因为此时线程池还在开启中</li><li>shutdown销毁线程（不建议执行）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableImpl implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo01ThreadPool &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">        es.submit(new RunnableImpl());</span><br><span class="line">        es.submit(new RunnableImpl());</span><br><span class="line">        es.submit(new RunnableImpl());</span><br><span class="line">        es.submit(new RunnableImpl());</span><br><span class="line">        es.submit(new RunnableImpl());</span><br><span class="line"></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为<br>pool-1-thread-2<br>pool-1-thread-1<br>pool-1-thread-2<br>pool-1-thread-1<br>pool-1-thread-2</p><h1 id="Lambda函数式编程"><a href="#Lambda函数式编程" class="headerlink" title="Lambda函数式编程"></a>Lambda函数式编程</h1><p>面向对象的思想: 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.<br>函数式编程思想: 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程<br>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担</p><p>格式<br>1.一些参数 2.一个箭头 3.一段代码<br>（参数列表）-&gt;{重写方法的代码}</p><ul><li>（）接口中要重写的抽象方法的参数列表</li><li>-&gt; 传递，把参数传递给方法体</li><li>{} 重写接口抽象方法的方法体</li></ul><p>不需要再新建一个类new….<br><strong>不只是线程类，其他各种类的使用中也可以使用Lambda方法</strong></p><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内有且仅有一个参，则小括号可以省略；</li><li>如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><p>注意</p><ol><li>使用Lambda必须具有接口，且要求接口中<strong>有且仅有一个抽象方法</strong>。</li><li>使用Lambda必须具有上下文推断。<br>备注：有且仅有一个抽象方法的接口，称为“函数式接口”。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01Runnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName());</span><br><span class="line">          &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为<br>Thread-0<br>Thread-1<br>可以观察到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简化为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;System.out.println(Thread.currentThread().getName());&#125;</span><br></pre></td></tr></table></figure><p>省略了创建对象，直接从 <code>run()</code>入手，因为是唯一的抽象方法，<code>()</code>即可代表<code>run()</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2021/08/21/%E5%BC%82%E5%B8%B8/"/>
      <url>/2021/08/21/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="Debug调试程序："><a href="#Debug调试程序：" class="headerlink" title="Debug调试程序："></a>Debug调试程序：</h1><p>可以让代码逐行执行，查看代码执行的过程，调试过程中的bug<br>使用方式：</p><ul><li>在行号的右边鼠标左键单击添加断点</li><li>右键选择debug,程序会停留在第一个断点处执行程序<ul><li>f8 逐行执行程序</li><li>f7 进入到方法中，不然在主程序的下一行会直接输出方法的结果，而不会执行方法的一行一行</li><li>shift+f8 跳出方法</li><li>f9 跳到下一个断点，若没有下一个断点就结束程序</li><li>ctrl+f2 退出debug，停止程序</li><li>Console 切换回控制台</li></ul></li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常指的是程序在执行过程中出现的非正常情况<br>指的并不是语法错误，如果语法错了，编译不通过，根本不能运行<br>Throwable是所有错误和异常的超类</p><h1 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h1><p>Exception</p><ul><li>编译期异常，进行写代码出现的问题</li><li>RuntimeException 运行期异常，运行过程中出现的问题</li><li>异常就相当于一个小毛病，处理掉就可以继续执行</li></ul><p>Error错误</p><ul><li>错误就相当于程序得了一个无法治愈的毛病，必须修改源代码才能继续执行</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>java异常处理的五个关键字：try catch finally throw throws</p><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><p>throw可以在指定的方法中抛出指定的异常<br>使用格式 <code>throw new xxxException(&quot;异常产生的原因&quot;)</code><br>注意</p><ol><li>必须写在方法的内部</li><li>new后边的对象必须是Exception或者Exception的子类对象</li><li>抛出指定的异常对象，我们必须处理这个异常对象<ul><li>throw关键字后边创建的是运行期异常RuntimeException或者RuntimeException的子类对象，可以不处理</li><li>throw关键字后边创建的是编译异常（写代码时报错），必须处理，用throws或者try…catch</li></ul></li></ol><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><p>throws关键字：异常处理的第一种方式，交给别人处理<br>使用格式：在方法声明时使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （参数列表） throws AAAException，BBBException&#123;</span><br><span class="line">    throw new AAAException(&quot;异常产生的原因&quot;)</span><br><span class="line">    throw new BBBException(&quot;异常产生的原因&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>必须写在方法声明处</li><li>后面的声明异常必须是Exception或者Exception的子类对象</li><li>方法内部抛出多个异常，那么throws后边必须声明多个，如果异常有子父类关系，直接声明父类即可</li><li>方法要throws声明，main函数也要throws声明，但是有缺点，方法中异常之后的代码不会再处理</li></ol><h2 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h2><p>try…catch关键字：异常处理的第二种方式，自己处理异常<br>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    可能产生异常的代码</span><br><span class="line">&#125;catch（定义一个异常变量，用来接收try中的异常对象）&#123;</span><br><span class="line">    异常处理逻辑，接受异常对象后怎么处理异常对象</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">catch（异常类名xxException 变量名）&#123;...&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ol><li>try抛出多个异常对象，就可以使用多个catch来处理这些异常对象</li><li><ul><li>如果try中产生了异常，就会执行catch中的异常处理逻辑，执行完之后继续执行之后的代码</li><li>如果try中没有异常，执行完try中的代码之后继续执行try…catch之后的代码</li></ul></li><li>可以是方法throws声明个异常，然后在main函数中使用try…catch处理这个方法的异常</li><li>try多个异常的时候，会执行第一个遇到的异常的catch，剩下的异常不再处理</li></ol><h2 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h2><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">   可能产生异常的代码</span><br><span class="line">&#125;catch（定义一个异常变量，用来接收try中的异常对象）&#123;</span><br><span class="line">   异常处理逻辑，接受异常对象后怎么处理异常对象</span><br><span class="line">&#125;</span><br><span class="line"> 。。。</span><br><span class="line">catch（异常类名xxException 变量名）&#123;&#125;</span><br><span class="line">finally&#123;</span><br><span class="line">  无论是否出现异常都会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ul><li>finally不能单独使用，必须和try一起使用</li><li>finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放（IO）</li></ul><h2 id="子父类异常"><a href="#子父类异常" class="headerlink" title="子父类异常"></a>子父类异常</h2><ul><li> 如果父类抛出了多个异常，子类重写父类方法时，子类需要抛出和父类相同的异常，或者是父类异常的子类，或者不抛出异常</li><li> 父类没有抛出异常，子类重写该方法时也不能抛出异常，只能对异常捕获处理try…catch，不能声明抛出throws</li></ul><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>java提供的异常类不够我们使用，需要自己定义一些异常类<br>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class XXXException extends Exception / RuntimeException&#123;</span><br><span class="line">  添加一个空参数的构造方法&#123;super（）&#125;</span><br><span class="line">  添加一个带异常信息的构造方法 （String message）&#123;super(message)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ol><li>自定义异常类一般都是以Exception结尾</li><li>自定义异常类，必须继承Exception / RuntimeException<ul><li> 继承Exception：自定义异常类是编译异常</li><li> 继承RuntimeException： 自定义异常类就是运行期异常，遇到异常会中断程序</li></ul></li></ol><h3 id="异常类定义示例"><a href="#异常类定义示例" class="headerlink" title="异常类定义示例"></a>异常类定义示例</h3><img style="width:800px" src="https://s3.bmp.ovh/imgs/2021/08/5ded087cb540e922.png"> <h3 id="抛出实现"><a href="#抛出实现" class="headerlink" title="抛出实现"></a>抛出实现</h3><img style="width:800px" src="https://s3.bmp.ovh/imgs/2021/08/ea71650d4f3f6793.png"> <h3 id="捕获实现"><a href="#捕获实现" class="headerlink" title="捕获实现"></a>捕获实现</h3><img style="width:800px" src="https://s3.bmp.ovh/imgs/2021/08/e9cee69672f60a5a.png"> ]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map</title>
      <link href="/2021/08/17/Map/"/>
      <url>/2021/08/17/Map/</url>
      
        <content type="html"><![CDATA[<h1 id="Map的基本内容"><a href="#Map的基本内容" class="headerlink" title="Map的基本内容"></a>Map的基本内容</h1><p> Map集合是一个双列集合，一个元素包含两个值（key，value）</p><ul><li>key和value的数据类型可以相同，也可以不同</li><li>key不允许重复，value可以重复</li><li>key和value是一一对应的</li><li>HashMap很快，但无序，继承Map方法</li></ul><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><ul><li>get（key）=&gt;value 根据key值获得value。。。</li><li>put（key, value）=&gt;value 存储进map中，若key不重复返回空，若重复返回被替换的value</li><li>remove（key）=&gt;value 移除key，返回value值</li><li>containkey（key）=&gt;booolean 是否含有这个key</li></ul><h1 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h1><ul><li>keyset（）<br>将Map的key全部返回到一个set中，可以利用set的特点遍历key获取value</li><li>entrySet（）<br>将map的entry对象取出存储到set中，（entry对象就是键值对的映射关系，类似于结婚证），<br>entry对象有getKey()和getValue()方法，可以在遍历中使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变参数方法</title>
      <link href="/2021/08/15/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95/"/>
      <url>/2021/08/15/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>当方法的参数列表数据类型已经确定，但个数不确定时，可以使用可变参数</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>修饰符 返回值类型 方法名（数据类型…变量名）{}<br>这个变量实际上是一个数组</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>一个参数列表只能由一种类型的可变参数，不可以（int…..a, String….b）</li><li>若有多种数据类型，可变参数要放在最后一个 （int a， string b， int…c）</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class KeBian &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int add = method(1,3,4,5,8,9);</span><br><span class="line">        System.out.println(add);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int method(int...ints) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int anInt : ints) &#123;</span><br><span class="line">            sum += anInt;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新电脑第一次博客测试</title>
      <link href="/2021/08/13/%E6%96%B0%E7%94%B5%E8%84%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/08/13/%E6%96%B0%E7%94%B5%E8%84%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>歪日，YOGA14S轻薄本可真好用</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2021/08/11/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2021/08/11/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><img style="width:1000px" src="https://z3.ax1x.com/2021/08/11/fa3zsf.jpg"> <p>具体需要什么类型的数据不知道，就使用泛型定义<br>使用泛型</p><ul><li>避免了类型转换的麻烦，存储的是什么类型取出的就是什么类型</li><li>但泛型是什么类型就只能存储什么类型的数据</li></ul><p>不使用泛型</p><ul><li>可以存储任意类型的数据,但不安全会引发异常<br>如 Arraylist list = new Arraylist()</li></ul><h1 id="泛型类的定义"><a href="#泛型类的定义" class="headerlink" title="泛型类的定义"></a>泛型类的定义</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class GenericClass&lt;E&gt; &#123;</span><br><span class="line">    private E name;</span><br><span class="line"></span><br><span class="line">    public E getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(E name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo02Generic &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericClass gc = new GenericClass();</span><br><span class="line">        gc.setName(&quot;Object name&quot;);</span><br><span class="line">        Object name = gc.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        GenericClass gc1 = new GenericClass();</span><br><span class="line">        gc1.setName(2);</span><br><span class="line">        Object name1 = gc1.getName();</span><br><span class="line">        System.out.println(name1);</span><br><span class="line"></span><br><span class="line">        GenericClass&lt;Integer&gt; gc2 = new GenericClass&lt;&gt;();</span><br><span class="line">        gc2.setName(4);</span><br><span class="line">        Integer name2 = gc2.getName();</span><br><span class="line">        System.out.println(name2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型接口的定义"><a href="#泛型接口的定义" class="headerlink" title="泛型接口的定义"></a>泛型接口的定义</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface GenericInterface &lt;E&gt;&#123;</span><br><span class="line">    public abstract void method(E e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class GenericInterfaceImp2&lt;E&gt; implements GenericInterface&lt;E&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method(E e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class GenericInterfaceImpl1 implements GenericInterface&lt;String&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="泛型方法定义"><a href="#泛型方法定义" class="headerlink" title="泛型方法定义"></a>泛型方法定义</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GenericMethod &#123;</span><br><span class="line">    public &lt;E&gt; void method01(E e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo02Generic &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        GenericMethod gm = new GenericMethod();</span><br><span class="line">        gm.method01(1);</span><br><span class="line">        gm.method01(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h1><p>泛型的通配符 ?  代表任意的数据类型<br>食用方法</p><ul><li>不能创建对象使用，只能作为<strong>方法的参数</strong>使用</li><li>? extends E       ?对应的类必须是E或者是E的子类</li><li>? super E         ?对应的类必须是E或者是E的父类</li></ul><p> 简单用法<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public class Demo03Generic &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(&quot;a&quot;);</span><br><span class="line">        list1.add(&quot;b&quot;);</span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">        list2.add(1);</span><br><span class="line">        list2.add(2);</span><br><span class="line">        method(list1);</span><br><span class="line">        method(list2);</span><br><span class="line">        // ArrayList&lt;?&gt; list3 = .......错误</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method(ArrayList&lt;?&gt; list) &#123;</span><br><span class="line">        Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collection集合</title>
      <link href="/2021/08/11/Collection%E9%9B%86%E5%90%88/"/>
      <url>/2021/08/11/Collection%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><img style="width:1000px" src="https://z3.ax1x.com/2021/08/11/faQAKS.jpg"> <p>Collection 是所有单列集合最顶层的接口（Map是双列接口），里面定义了所有单列集合的共性方法</p><h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><ul><li><code>boolean add(E e) </code>添加元素</li><li><code>boolean remove(Object o)</code> 从集合中移除指定的元素</li><li><code>void clear()</code> 清空集合中的元素</li><li><code>boolean contains(Object o)</code> 判断集合中是否存在指定的元素</li><li><code>boolean isEmpty()</code> 判断集合是否为空</li><li><code>int size()</code>集合的长度，也就是集合中元素的个数</li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是Collection集合中元素的通用获取方式，是一个接口</p><ul><li><code>hasNext()</code> 判断有没有下一个元素可以迭代</li><li><code>next（）</code> 返回迭代的下一个元素</li><li><code>iterator()</code> 返回迭代器的实现类（接口无法直接使用）</li></ul><p>步骤</p><ol><li>iterator()获取实现类</li><li>hasNext()判断</li><li>next（）取出<br>如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; co = new ArrayList&lt;&gt;();</span><br><span class="line">co.add(&quot;Hello&quot;);</span><br><span class="line">co.add(&quot;en&quot;);</span><br><span class="line">co.add(&quot;ok&quot;);</span><br><span class="line">Iterator&lt;String&gt; it = co.iterator();</span><br><span class="line">// 多态  接口            实现类对象</span><br><span class="line">// 获取实现类对象并把指针指向集合的-1索引</span><br><span class="line">while (it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    // 取出下一个元素并且指针向后移动一位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h1><p>增强for循环本质也是一种迭代器，使用for循环格式简化了迭代器的书写,所有的单列集合都可以使用增强for<br>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for（数据类型 变量名：集合名/数组名）&#123;</span><br><span class="line">    sout（变量名）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量名对应的就是集合或数组中的数据<br>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();;</span><br><span class="line">list.add(&quot;aaa&quot;);</span><br><span class="line">list.add(&quot;bbb&quot;);</span><br><span class="line">list.add(&quot;ccc&quot;);</span><br><span class="line">list.add(&quot;ddd&quot;);</span><br><span class="line">for (String i:list) &#123;</span><br><span class="line">    System.out.println(i)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h1><p>详见ArrayList<br>ArrayList 查询快，增删慢，底部是Array数组</p><p>LinkedList增删快。查询慢，底部是链表，有很多的首尾元素操作方法</p><h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>set集合的特点</p><ul><li>不允许存储重复的元素</li><li>没有索引，也不能使用普通的for循环进行遍历</li></ul><p>HashSet继承set</p><ul><li>是一个无序的集合，存储元素和取出元素的顺序有可能不一致</li><li>底层是一个哈希表，哈希表：数组 + 链表/红黑树</li></ul><p>如果HashSet存储自定义类型元素（如Student类），想要元素不重复，必须重写hashcode和equals方法</p><p>LinkedHashSet 集合不允许重复，但是保证元素有序</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2021/08/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/08/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>字符串String是常量；它们的值在创建之后不能更改。字符串缓冲区StringBuilder支持可变的字符串<br>字符串本身就是一个对象，可以<code>str.methods()</code></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>==是进行字符串的地址值比较，内容的比较是 <code>str1.equals(str2)</code>，但是str1不可以是空值，因为空值没有方法</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><ul><li><code>str.length()</code> 获取长度</li><li><code>str1.concat(str2) </code>将1和2拼接并返回</li><li><code>str.charAt(0)</code> 返回字符串的第一个字符</li><li><code>str.indexOf（a）</code>返回字符串第一个参数字符串a首次出现的索引位置，没有返回-1</li><li><code>str.substring(index)</code> 从参数位置一直截取到字符串末尾</li><li><code>str.substring(begin, end)</code> 从begin一直截取到end [begin, end)</li><li><code>str.toCharArray()</code> 将字符串转换为数组并返回</li><li><code>str.getBytes()</code> 获得当前字符串的底层字节数组 a==&gt;97，并返回</li><li><code>str.replace(oldString, newString)</code> 返回一个新的字符串，用new的部分替换old的部分</li><li><code>&quot;a,b,c&quot;.split(&quot;,&quot;)</code>  -&gt; <code>&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;</code> 将字符串按照规定进行拆分<br>若原字符串想要根据”.”进行拆分，因为”.”是转义字符，必须写成<code>split(&quot;\\.&quot;)</code></li></ul><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>StringBuilder字符串缓冲区，可以对字符串进行操作，提高字符串的效率</p><ul><li><code>StringBuilder()</code> 构造一个空的字符串生成器，初始容量16个字符</li><li><code>StringBuilder(Str)</code> 构造一个字符串生成器，初始化为指定的字符串内容 <strong>字符串-&gt;字符串生成器</strong></li></ul><p>常用方法</p><ul><li><code>bu1.append()</code> 向后添加字符串，不必接收返回值，直接反映在bu1中<br>可以<code>bu1.append().append().append()</code></li><li><code>bu.toString()</code> <strong>字符串生成器-&gt;字符串</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/2021/08/07/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2021/08/07/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>一个类内部包含另一个类，就像身体和心脏的关系<br>分类</p><ol><li>成员内部类</li><li>局部内部类（包含匿名内部类）</li></ol><h1 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">     修饰符 class 内部类名称&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li>内用外，随意访问；外用内，需要内部类对象</li><li>主函数调用内部类函数<br><code>外部类名称.内部类名称 对象名 = new 外部类名称（）.new 内部类名称（）</code></li><li>内部类调用外部类的重名变量<br><code>外部类名称.this.变量名</code></li></ol><h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><p>一个类是定义在一个方法内部，只有当前这个方法才能用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">     修饰符 返回值类型 外部类方法名称（）&#123;</span><br><span class="line">         class 局部内部类名称&#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类如果希望访问所在方法的局部变量，那这个局部变量必须是有效final的</p><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>如果接口的实现类或者是父类的子类只需要使用<strong>唯一一次</strong>,那么这种情况下就可以省略掉该类的定义。而使用匿名内部类（较为重要）<br>定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口名称 对象名 = new 接口名称（）&#123;</span><br><span class="line">     覆盖重写所有的抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2021/08/02/%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/08/02/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><ol><li>定义父类的格式 （一个普通的类定义）<ul><li>public class 父类名称{}</li></ul></li><li>定义子类的格式<ul><li>public class 子类名称 <strong>extends</strong> 父类名称{}</li><li>继承时访问重名的成员变量/方法，优先使用最近的对象的，没有再往上找父类，绝不会往下找子类</li></ul></li></ol><h1 id="方法覆盖重写"><a href="#方法覆盖重写" class="headerlink" title="方法覆盖重写"></a>方法覆盖重写</h1><p>在子类对父类的方法进行重写，尽量不要修改父类</p><ol><li>保证父类子类方法名称相同，参数列表也相同</li><li>子类方法的权限必须大于等于父类方法的权限修饰符</li><li>public &gt; protected &gt; ( default ) &gt; private<table><thead><tr><th align="center">类型</th><th align="center">public</th><th align="center">protected</th><th align="center">( default )</th><th align="center">private</th></tr></thead><tbody><tr><td align="center">同一个类</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">同一个包</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">不同包子类（继承关系）</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">不同包非子类（非继承关系）</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td><td align="center">no</td></tr></tbody></table></li></ol><h1 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h1><p>加上abstract关键字，然后去掉大括号，代表一种行为，但具体怎么做不确定<br><code> public abstract void method();</code><br>例如父类定义一个动物吃东西的抽象方法，在子类分成狗和猫对这个抽象方法分别进行具体的描述<br><strong>抽象方法所在的类必须是抽象类</strong>，在class前写上abstract</p><ul><li>不能直接使用new抽象类对象</li><li>必须用一个子类继承抽象父类</li><li>子类必须覆盖重写抽象父类<strong>所有</strong>的抽象方法</li><li>创建子类对象进行使用</li></ul><h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><ol><li><p>对于局部变量 name</p><ul><li>使用本类的成员变量 this.name</li><li>使用父类的成员变量 super.name<br>同理成员方法</li></ul></li><li><p>调用父类的成员方法 super.method();<br>调用父类的构造方法 super()<br>super调用父类的函数，省去重复代码</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2021/08/02/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/08/02/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>接口就是一种公共的规范标准，只要符合标准，就可以大家共用 （插电接口）</p><h1 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h1><p> 一个接口Interface的格式:  public <strong>interface</strong> 接口名称{}</p><ul><li>接口可以有抽象方法，默认方法，静态方法，私有方法</li><li>接口不能直接使用，必须有一个实现类来实现该接口</li></ul><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><p>接口定义”成员变量“ 从效果上看就是接口的常量<br>格式: <code>public static final 数据类型 变量名称</code></p><ul><li>一旦使用final说明不可改变</li><li>可以省略 public static final。但不写效果相同</li><li>接口常量必须进行赋值,且常量的名称使用完全大写的字母，用下划线进行分割(推荐命名)</li></ul><h1 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h1><p><code>public class 实现类名称 implements 接口名称&#123;&#125;</code></p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>接口的所有抽象方法必须覆盖重写，可以B实现A的一部分抽象方法，接着C实现B剩下的抽象方法，此时A和B都是抽象的</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>默认方法的定义 <code>public default void 默认方法名称()&#123;&#125;</code><br>接口添加默认方法，实现类不会报错，但添加抽象方法会出现报错</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>default换成static<br>不能通过<strong>接口实现类的对象</strong>来调用接口当中的静态方法<br>正确用法: 接口名称.静态方法</p><h2 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h2><p> private方法只有接口自己可以调用，不能被实现类或别人调用</p><ul><li>private 方法名称(){}</li><li>private static 名字(){}</li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>一个类的父类唯一，但接口不唯一</li><li>一个类如果父类的方法和接口中的默认方法产生了冲突，优先使用父类当中的方法<br><code>public class Zi extends Fu implements Interface&#123;&#125;</code></li><li>接口是多继承的(extends) <code>public interface MyInterfaceC extends MyInterfaceA,MyInterfaceB</code><br> 若多继承的父类出现重名的默认函数，一定要进行覆写override</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2021/08/02/%E5%A4%9A%E6%80%81/"/>
      <url>/2021/08/02/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><p>多态 保证等号左边不会变动<br>小明这个对象，既有学生形态，又是人类形态。一个对象拥有多种形态，就是对象的多态性<br>体现多态性 父类引用指向子类对象</p><h1 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h1><ol><li>父类名称 对象名 = new 子类名称（）</li><li>接口名称 对象名 = new 实现类名称（）</li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><blockquote><ol><li>调用成员变量<blockquote><ul><li>直接通过对象名称访问成员变量，等号左边是谁就优先用谁，没有则向上找</li><li>间接通过成员方法访问成员变量，该方法属于谁就优先用谁，没有则向上找</li></ul></blockquote></li><li>成员方法的访问规则<blockquote><ul><li>看new的是谁就优先用谁，没有则向上找</li><li>编译看左边，运行看右边（编译的时候，该方法父类必须有，运行的时候优先用子类）<blockquote><ul><li>父子都有，优先用子</li><li>子类没有，父类有，向上找到父类</li><li>子类有，父类没有，报错，因为编译时父类没有该方法<br>为调用子类方法需要向下转型： 子类 子类对象名 = （子类） 父类对象名    instanceof用法</li></ul></blockquote></li></ul></blockquote></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList集合</title>
      <link href="/2021/07/26/ArrayList/"/>
      <url>/2021/07/26/ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>ArrayList是一个类，这个类建立的Array没有固定的大小限制，可以在程序运行中不断地添加元素</p><h1 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h1><p> 如 <code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;()</code></p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p><code>list.add(abc)</code>   往list末尾添加元素abc<br><code>list.get(0)</code>     获取list第一个位置的元素<br><code>list.remove(0)</code>  删除list第一个位置的元素，并返回这个元素的值<br><code>list.size()</code>     返回list的长度</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>ArrayList 的泛型只能是引用类型（如String），不能是基本类（如下的byte等）<br>想要使用基本类的话必须使用对应的包装类</p><table><thead><tr><th align="center">基本类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr></tbody></table><hr><p><em>Markdown想要在网页中表格显示，‘ | ’前必须有空格</em></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与对象</title>
      <link href="/2021/07/21/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/07/21/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向过程就是人亲自手洗衣服，面向对象就是人用洗衣机洗衣服，对象就是洗衣机</p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>由类到对象，类不能直接使用，需要根据类来创建对象，通过对象才能使用<br>类就是手机图纸，对象就是手机，对象通过调用类的成员变量和成员函数等来调用类</p><h1 id="一个标准的类"><a href="#一个标准的类" class="headerlink" title="一个标准的类"></a>一个标准的类</h1><p>定义一个标准的类（标准的类也叫做Java bean）</p><ol><li>所有的成员变量<strong>都</strong>要用private关键字修饰, <strong>private设置后，对象无法直接调用变量，但可以通过类的函数(get,set等)进行间接调用</strong></li><li>为每个成员变量编写一对get、set方法</li><li>编写一个无参数的构造方法, <strong>构造方法就是在创建对象new的时候就会执行</strong></li><li>编写一个有参数的构造方法, 构造方法也是可以进行重载的</li><li>成员变量和局部变量同名时, 用this.来调用成员变量</li><li>构造方法的命名规则 public 类名 (){}</li></ol><p><strong>任何类和接口都可以成为成员变量</strong></p><h1 id="对象建立"><a href="#对象建立" class="headerlink" title="对象建立"></a>对象建立</h1><p>自建的类名 对象名 = new 自建的类名（）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA快捷建</title>
      <link href="/2021/07/16/IDEA%E5%BF%AB%E6%8D%B7%E5%BB%BA/"/>
      <url>/2021/07/16/IDEA%E5%BF%AB%E6%8D%B7%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><img style="width:800px" src="https://ftp.bmp.ovh/imgs/2021/07/c7b4af4f9027d8ae.png">  <ol><li><p>替换变量名称 </p><ul><li><p>ctrl+R    选择替换变量，可以替换所有的</p></li><li><p>shift+F6  替换选中变量，有时候可以替换所有的，有时候替换一部分（没搞懂</p></li><li><p>最好用的方法 选中想要修改的范围后按ctrl+R，之后在左上角搜索框上行输入想替换的文字，搜索框下行输入替换后的文字<br>然后replaceall即可只修改选中范围内的想替换文字</p></li></ul></li><li><p>提示显示 alt+/<br>定义类的时候插入toString等方法 alt+Insert<br>转到定义位置 Ctrl+B</p></li><li><ul><li>5.fori 自动形成数目为5的for循环</li><li>array.fori 自动形成数目为array长度的for循环</li><li>array.forr 自动形成数目为array长度的倒叙for循环</li><li>array.for 增强for循环（详见Collection集合）</li></ul></li><li><p>crtl+Z 撤回      ctrl+shift+z 恢复撤回</p></li><li><p>crtl+p 在（）使用，显示函数要求的参数类型</p></li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><p>javadoc注释方法<br> /**<br> *<br> */</p></li><li><p>在方法中使用数组的时候<br>数组作为参数 <code>public static void method(int[] array )&#123;&#125;</code><br>数组作为返回值 <code>public static int[] method(int a, int b)&#123;&#125;</code><br><em><strong>void是方法无返回值时候的选择，如打印输出</strong></em></p></li><li><p>IDEA中 project–module–package–class</p></li><li><p>int+string会发生转义，如果在sout中不想发生转义需要将字符串用””框住，’’不行<br>‘’代表的是字符，与int在一起会发成转义，变成对应的ASCII码，+号得到的最终是数字<br>“”代表的是字符串，不会转义，通过+号会直接合成一个新的字符串<br>字符可以和int进行大小比较，+，&lt;=, &gt;=等，例如 <code>if(&#39;A&#39; &lt;= 100)&#123;&#125;</code></p></li><li><p>打印对象名，输出的不是地址，说明该对象的类中重写了toString方法</p></li><li><p>静态方法不建议创建对象使用，应该 类名.方法名 使用</p></li><li><p>数组调用参数a[0], 集合Arraylist调用参数 <code>list.get(0)</code></p></li><li><p>a == b ， 比较的是地址值<br><code>a.equals(b)</code>在没有重写的情况下比较的也是地址，如果在类定义的时候进行重写，可以进行值的比较</p></li><li><p>main主函数调用本类的静态方法可以直接调用，但是调用本类的非静态方法需要创建一个本类的对象进行调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class FunDemo &#123;</span><br><span class="line">    //静态方法</span><br><span class="line"></span><br><span class="line">    public static void sayHello(String name)&#123;</span><br><span class="line">    System.out.println(&quot;Hello &quot;+name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //实例方法</span><br><span class="line"></span><br><span class="line">    public void sayBye(String name)&#123;</span><br><span class="line">    System.out.println(&quot;Bye Bye &quot;+name);;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //main方法</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        FunDemo.sayHello(&quot;tom&quot;);//类名.方法名去调用静态的方法</span><br><span class="line"></span><br><span class="line">        sayHello(&quot;jack&quot;);// 本类里调用本类的静态方法，可以省略类名</span><br><span class="line"></span><br><span class="line">        FunDemo fn = new FunDemo();//创建本类的实例对象</span><br><span class="line"></span><br><span class="line">        fn.sayBye(&quot;tom&quot;);//实例对象.方法名 去调用 实例方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.13 记</title>
      <link href="/2021/05/13/5-13-%E8%AE%B0/"/>
      <url>/2021/05/13/5-13-%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="修改意见"><a href="#修改意见" class="headerlink" title="修改意见"></a>修改意见</h1><p>1 摘要修改，原先内容基本<strong>一句到底</strong>，分成几句话进行分析</p><p>2 将二三段合并，合成一个5G异构网络模型，增加一章对神经网络和深度学习进行介绍</p><p>3 仿真结果图不够丰富，增加仿真结果，增加仿真参数</p><p>4 仿真结果有问题，一些图横纵坐标有问题，一些图不收敛</p><p>5 <strong>论文一般是以第三人称进行描述</strong>，少用<em>我们，我</em>，可以用本文，本研究，研究中等，文字应避免口语化，体现专业性</p><p>6 整理行文逻辑</p><h1 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h1><p>1 摘要修改完成，二三段合并完成，并对公式和图的标号进行修改，增加了一章的内容，介绍了深度强化学习</p><p>2 因为DQN神经网络训练的并不成功，仿真结果一直不好，尝试着增加了几张图，但<strong>很不理想</strong>，后期再想办法进行修改看看能不能过关</p><p>3 仿真图修改完成，不收敛的图删除不要</p><p>4 第三人称和行文逻辑问题还没有修改，仿真参数也没有添加</p><h1 id="模型问题"><a href="#模型问题" class="headerlink" title="模型问题"></a>模型问题</h1><p>想了想，我是只把最后一个时隙的状态输入到了神经网络中，应该输入最后的多个时隙状态，这样子的效果会更好，但现在已经很难修改代码结构（这部分的代码很难修改，要是修改会影响很多的部分）</p><p>用户太少的问题，我尝试建立一个函数增加用户数量，但运行时间极大幅度增加，还不停报错，放弃，后续有机会进行进一步的修改</p><p>D2D与UE的0距离接触导致的干扰激增问题暂时无法解决，后续看论文整理下思路</p><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><p>脑壳疼，真的不想改，出优秀毕设的意愿也不是很大，但是导师看我论文比我自己都认真，实在是不改不合适，尽量15号之前修改完毕吧，希望可以稳妥毕业<br><img style="width:300px" src="https://ftp.bmp.ovh/imgs/2021/05/fcfcb3c542b97e1b.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇</title>
      <link href="/2021/05/10/2021%E5%B9%B45%E6%9C%8810%E6%97%A5/"/>
      <url>/2021/05/10/2021%E5%B9%B45%E6%9C%8810%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<p>首先感谢Vychod（lc，可以在友链里看见他）的博客制作帮助，根本不知道想要一个自己的博客该怎么开始比较好，你是个好人。</p><p>要成为研究生了，为了以后可以找到一个好工作和不被导师嫌弃想学习一些有用的技能，打算把自己刷力扣算法的一些思路和学习编程的遇到注意点写在自己的博客上，争取做个有用的人。</p><p>也许还会更新更新日记日常什么的，嘻嘻</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
