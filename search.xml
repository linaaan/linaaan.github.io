<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql约束</title>
      <link href="/2021/10/03/Mysql%E7%BA%A6%E6%9D%9F/"/>
      <url>/2021/10/03/Mysql%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><ul><li>概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。    </li><li>分类：<ol><li>主键约束：primary key</li><li>非空约束：not null</li><li>唯一约束：unique</li><li>外键约束：foreign key</li></ol></li></ul><h1 id="约束概念"><a href="#约束概念" class="headerlink" title="约束概念"></a>约束概念</h1><ul><li><p>非空约束：not null，某一列的值不能为null</p><ol><li><p>创建表时添加约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">  id INT,</span><br><span class="line">  NAME VARCHAR(20) NOT NULL -- name为非空</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>创建表完后，添加非空约束<br><code>ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL</code>;</p></li><li><p>删除name的非空约束<br><code>ALTER TABLE stu MODIFY NAME VARCHAR(20)</code>;</p></li></ol></li><li><p>唯一约束：unique，某一列的值不能重复</p><ol><li>注意：<ul><li>唯一约束限定的列值可以有多个null</li></ul></li><li>在创建表时，添加唯一约束<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE stu(</span><br><span class="line">  id INT,</span><br><span class="line">  phone_number VARCHAR(20) UNIQUE -- 手机号</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>删除唯一约束（只是删除了约束，但没有对数据进行处理）<br>ALTER TABLE stu DROP INDEX phone_number;</li><li>在表创建完后，添加唯一约束<br><code>ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE</code>;</li></ol></li><li><p>主键约束：primary key。</p><ol><li><p>注意：</p><ol><li>含义：非空且唯一</li><li>一张表只能有一个字段为主键</li><li>主键就是表中记录的唯一标识</li></ol></li><li><p>在创建表时，添加主键约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">  id int primary key,-- 给id添加主键约束</span><br><span class="line">  name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除主键<br>错误写法 alter table stu modify id int ;<br>ALTER TABLE stu DROP PRIMARY KEY;</p></li><li><p>创建完表后，添加主键<br>ALTER TABLE stu MODIFY id INT PRIMARY KEY;</p></li><li><p>自动增长：</p><ol><li><p> 概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长</p></li><li><p>在创建表时，添加主键约束，并且完成主键自增长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table stu(</span><br><span class="line">  id int primary key auto_increment,-- 给id添加主键约束</span><br><span class="line">  name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>删除自动增长<br>ALTER TABLE stu MODIFY id INT;</p></li><li><p>添加自动增长<br>ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;</p></li></ol></li></ol></li></ul><ul><li><p>外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。<br>有外键约束，在删除主表列时将不会允许删除，防止误操作</p><ol><li><p>在创建表时，可以添加外键</p><ul><li>语法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">  ....</span><br><span class="line">  外键列,</span><br><span class="line">  constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>外键名称随便起的，不重复即可<br>最后相当于是下面又加了一行，需要加“,”</li></ul></li><li><p>删除外键<br>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</p></li><li><p>创建表之后，添加外键<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称)</code>;</p></li><li><p>级联操作<br>修改被约束字段，对应的约束对象与被约束对象都会改变</p><ol><li>在添加外键的同时直接添加级联操作<br>语法：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE</code>  ;</li><li>分类：可以一起写，也可以分开写<ol><li>级联更新：ON UPDATE CASCADE<br>一起更新</li><li>级联删除：ON DELETE CASCADE<br>一起删除</li></ol></li></ol></li></ol></li></ul><h1 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h1><ol><li><p>多表之间的关系</p><ol><li><p>分类：</p><ol><li>一对一（了解）：<ul><li>如：人和身份证</li><li>分析：一个人只有一个身份证，一个身份证只能对应一个人</li></ul></li><li>一对多（多对一）：<ul><li>如：部门和员工</li><li>分析：一个部门有多个员工，一个员工只能对应一个部门</li></ul></li><li>多对多：<ul><li>如：学生和课程</li><li>分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择</li></ul></li></ol></li><li><p>实现关系：</p></li><li><p>一对多（多对一）：</p><ul><li>如：部门和员工</li><li>实现方式：<strong>在多的一方建立外键，指向一的一方的主键</strong>。</li></ul></li><li><p>多对多：</p><ul><li>如：学生和课程</li><li>实现方式：多对多关系实现需要<strong>借助第三张中间表</strong>。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键</li></ul></li><li><p>一对一（了解）：</p><ul><li>如：人和身份证</li><li>实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</li></ul></li><li><p>案例<br>旅游线路分类表 tab_category 和 旅游线路表 tab_route 是一对多的关系、<br>旅游线路表 tab_route 和 用户表 tab_user 是多对多的关系，需要创建一个中间表 收藏表 tab_favorite</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">-- 创建旅游线路分类表 tab_category</span><br><span class="line">-- cid 旅游线路分类主键，自动增长</span><br><span class="line">-- cname 旅游线路分类名称非空，唯一，字符串 100</span><br><span class="line">CREATE TABLE tab_category (</span><br><span class="line">  cid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  cname VARCHAR(100) NOT NULL UNIQUE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 创建旅游线路表 tab_route</span><br><span class="line">/*</span><br><span class="line">rid 旅游线路主键，自动增长</span><br><span class="line">rname 旅游线路名称非空，唯一，字符串 100</span><br><span class="line">price 价格</span><br><span class="line">rdate 上架时间，日期类型</span><br><span class="line">cid 外键，所属分类</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_route(</span><br><span class="line">  rid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  rname VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">  price DOUBLE,</span><br><span class="line">  rdate DATE,</span><br><span class="line">  cid INT,</span><br><span class="line">  FOREIGN KEY (cid) REFERENCES tab_category(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*创建用户表 tab_user</span><br><span class="line">uid 用户主键，自增长</span><br><span class="line">username 用户名长度 100，唯一，非空</span><br><span class="line">password 密码长度 30，非空</span><br><span class="line">name 真实姓名长度 100</span><br><span class="line">birthday 生日</span><br><span class="line">sex 性别，定长字符串 1</span><br><span class="line">telephone 手机号，字符串 11</span><br><span class="line">email 邮箱，字符串长度 100</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_user (</span><br><span class="line">  uid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  username VARCHAR(100) UNIQUE NOT NULL,</span><br><span class="line">  PASSWORD VARCHAR(30) NOT NULL,</span><br><span class="line">  NAME VARCHAR(100),</span><br><span class="line">  birthday DATE,</span><br><span class="line">  sex CHAR(1) DEFAULT &#x27;男&#x27;,</span><br><span class="line">  telephone VARCHAR(11),</span><br><span class="line">  email VARCHAR(100)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">创建收藏表 tab_favorite</span><br><span class="line">rid 旅游线路 id，外键</span><br><span class="line">date 收藏时间</span><br><span class="line">uid 用户 id，外键</span><br><span class="line">rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_favorite (</span><br><span class="line">  rid INT, -- 线路id</span><br><span class="line">  DATE DATETIME,</span><br><span class="line">  uid INT, -- 用户id</span><br><span class="line">  -- 创建复合主键</span><br><span class="line">  PRIMARY KEY(rid,uid), -- 联合主键</span><br><span class="line">  FOREIGN KEY (rid) REFERENCES tab_route(rid),</span><br><span class="line">  FOREIGN KEY(uid) REFERENCES tab_user(uid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>数据库设计的范式</p><ul><li><p>概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求</p><p>设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。<br>目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。</p></li><li><p>分类：</p><ol><li>第一范式（1NF）：每一列都是不可分割的原子数据项，不可以把一列又分成两类</li><li>第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）<ol><li>函数依赖：A–&gt;B,如果通过A属性（属性组）的值，可以确定唯一B属性的值。则称B依赖于A<br>例如：学号–&gt;姓名。  （学号，课程名称） –&gt; 分数</li><li>完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。<br>例如：（学号，课程名称） –&gt; 分数</li><li>部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值的确定只需要依赖于A属性组中某一些值即可。<br>例如：（学号，课程名称） – &gt; 姓名</li><li>传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性（属性组）的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A<br>例如：学号–&gt;系名，系名–&gt;系主任</li><li>码：如果在一张表中，一个属性或属性组，被其他<strong>所有属性所完全依赖</strong>，则称这个属性（属性组）为该表的码<br>例如：该表中码为：（学号，课程名称）<ul><li>主属性：码属性组中的所有属性</li><li>非主属性：除去码属性组的属性</li></ul></li></ol></li><li>第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</li></ol></li></ul></li></ol><h1 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h1><ol><li>命令行：<ul><li>语法：<ul><li>备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</li><li>还原：<ol><li>登录数据库</li><li>创建数据库</li><li>使用数据库</li><li>执行文件。source 文件路径</li></ol></li></ul></li></ul></li><li>图形化工具：<ul><li>直接右键导出，执行</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="/2021/09/27/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/09/27/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><ol><li><p>什么是SQL？<br>Structured Query Language：结构化查询语言<br>其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。</p></li><li><p>SQL通用语法</p><ol><li>SQL 语句可以单行或多行书写，<strong>以分号结尾</strong>。</li><li>可使用空格和缩进来增强语句的可读性。</li><li>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</li><li>3 种注释<ul><li>单行注释: – 注释内容 或 # 注释内容（mysql 特有，且空格不能忽略）</li><li>多行注释: /* 注释 */</li></ul></li></ol></li><li><p>SQL分类</p><ol><li>DDL（Data Definition Language）数据定义语言<br>用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等</li><li>DML（Data Manipulation Language）数据操作语言<br>用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等</li><li>DQL（Data Query Language）数据查询语言<br>用来查询数据库中表的记录（数据）。关键字：select, where 等</li><li>DCL（Data Control Language）数据控制语言(了解）<br>用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等</li></ol><p> <img src="https://img14.360buyimg.com/ddimg/jfs/t1/197830/33/10387/2456214/61517aaeE275f5e28/c09fdea913e7aea7.bmp" alt="SQL分类"></p></li></ol><h1 id="DDL-操作数据库、表"><a href="#DDL-操作数据库、表" class="headerlink" title="DDL: 操作数据库、表"></a>DDL: 操作数据库、表</h1><ol><li><p>操作数据库：CRUD</p><ol><li><p>C（Create）:创建</p><ul><li><p>创建数据库：</p><ul><li>create database 数据库名称;</li></ul></li><li><p>创建数据库，判断不存在，再创建：</p><ul><li>create database if not exists 数据库名称;</li></ul></li><li><p>创建数据库，并指定字符集</p><ul><li>create database 数据库名称 character set 字符集名;</li></ul></li><li><p>练习： 创建db4数据库，判断是否存在，并制定字符集为gbk</p><ul><li>create database if not exists db4 character set gbk;</li></ul></li></ul></li><li><p>R（Retrieve）：查询</p><ul><li>查询所有数据库的名称:<ul><li>show databases;</li></ul></li><li>查询某个数据库的字符集:查询某个数据库的创建语句<ul><li>show create database 数据库名称;</li></ul></li></ul></li><li><p>U（Update）:修改</p><ul><li>修改数据库的字符集（gbk 和 utf8）<ul><li>alter database 数据库名称 character set 字符集名称;</li></ul></li></ul></li><li><p>D（Delete）:删除</p><ul><li>删除数据库<ul><li>drop database 数据库名称;</li></ul></li><li>判断数据库存在，存在再删除<ul><li>drop database if exists 数据库名称;</li></ul></li></ul></li><li><p>使用数据库</p><ul><li>查询当前正在使用的数据库名称<ul><li><code>select database()</code>;</li></ul></li><li>使用数据库<ul><li>use 数据库名称;</li></ul></li></ul></li></ol></li></ol><ol start="2"><li><p>操作表</p><ol><li><p>C（Create）:创建</p><ol><li>语法：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">  列名1 数据类型1,</span><br><span class="line">  列名2 数据类型2,</span><br><span class="line">  ....</span><br><span class="line">  列名n 数据类型n</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>注意：最后一列，不需要加逗号（,）</p></li><li><p>数据库类型：</p><ol><li><p>int：整数类型</p><ul><li>age int,</li></ul></li><li><p>double:小数类型</p><ul><li><code>score double(5,2)</code></li></ul></li><li><p>date:日期，只包含年月日，yyyy-MM-dd</p></li><li><p>datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss</p></li><li><p>timestamp:时间戳类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss    </p><ul><li>如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值</li></ul></li><li><p>varchar：字符串</p><ul><li><code>name varchar(20)</code>:姓名最大20个字符</li><li>zhangsan 8个字符  张三 2个字符</li></ul></li></ol></li></ul><ol start="2"><li>创建表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create table student(</span><br><span class="line">  id int,</span><br><span class="line">  name varchar(32),</span><br><span class="line">  age int ,</span><br><span class="line">  score double(4,1),</span><br><span class="line">  birthday date,</span><br><span class="line">  insert_time timestamp</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>复制表：<ul><li>create table 表名 like 被复制的表名;          </li></ul></li></ol></li><li><p>R（Retrieve）：查询</p><ul><li>查询某个数据库中所有的表名称<ul><li>show tables;</li></ul></li><li>查询表结构<ul><li>desc 表名;</li></ul></li></ul></li><li><p>U（Update）:修改</p><ol><li>修改表名<br>alter table 表名 rename to 新的表名;</li><li>修改表的字符集<br>alter table 表名 character set 字符集名称;</li><li>添加一列<br>alter table 表名 add 列名 数据类型;</li><li>修改列名称 类型<br>alter table 表名 change 列名 新列名 新数据类型;<br>alter table 表名 modify 列名 新数据类型;<br>只改类型，不修改列名</li><li>删除列<br>alter table 表名 drop 列名;</li></ol></li><li><p>D（Delete）:删除</p><ul><li>drop table 表名;</li><li>drop table  if exists 表名 ;</li></ul></li></ol></li></ol><h1 id="DML-增删改表中数据"><a href="#DML-增删改表中数据" class="headerlink" title="DML: 增删改表中数据"></a>DML: 增删改表中数据</h1><ol><li><p>添加数据：</p><ul><li>语法：<ul><li><code>insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n)</code>;</li></ul></li><li>注意：<ol><li>列名和值要一一对应。</li><li>如果表名后，不定义列名，则默认给所有列添加值<br><code>insert into 表名 values(值1,值2,...值n)</code>;</li><li>除了数字类型，其他类型需要使用引号（单双都可以）引起来</li></ol></li></ul></li><li><p>删除数据： 删除数据但是不删除表</p><ul><li>语法：<ul><li><code>delete from 表名 [where 条件]</code></li></ul></li><li>注意：<ol><li>如果不加条件，则删除表中所有记录。</li><li>如果要删除所有记录<ol><li>delete from 表名; – 不推荐使用。有多少条记录就会执行多少次删除操作</li><li>TRUNCATE TABLE 表名; – 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</li></ol></li></ol></li></ul></li><li><p>修改数据：</p><ul><li><p>语法：</p><ul><li><code>update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件]</code>;</li></ul></li><li><p>注意：</p><ol><li>如果不加任何条件，则会将表中所有记录全部修改。</li></ol></li></ul></li></ol><h1 id="DQL-查询表中的记录"><a href="#DQL-查询表中的记录" class="headerlink" title="DQL: 查询表中的记录"></a>DQL: 查询表中的记录</h1><ul><li>select * from 表名;</li></ul><ol><li>语法：<br>select 字段列表（字段就是name，age之类的类名）<br>from 表名列表<br>where 条件列表<br>group by 分组字段<br>having 分组之后的条件<br>order by 排序<br>limit 分页限定</li></ol><ol start="2"><li><p>基础查询</p><ol><li>多个字段的查询<br>select 字段名1，字段名2… from 表名；<ul><li>注意：<ul><li>如果查询所有字段，则可以使用*来替代字段列表。</li></ul></li></ul></li><li>去除重复：<ul><li>distinct<br>同时有多个字段的话必须完全一样才会去除<br>seselect distinct 字段名1，字段名2… from 表名；</li></ul></li><li>计算列<ul><li>一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）<br>select 字段名1+字段名2 from 表名；</li><li><code>ifnull(表达式1,表达式2)</code>：null参与的运算，计算结果都为null<ul><li>表达式1：哪个字段需要判断是否为null</li><li>如果该字段为null后的替换值。<br><code>select 字段名1+ifnull(字段名2,替换值) from 表名</code>；</li></ul></li></ul></li><li>起别名：<ul><li>as：as也可以省略<br><code>select 字段名1+ifnull(字段名2,替换值) as 别名 from 表名</code>；</li></ul></li></ol></li><li><p>条件查询</p><ol><li>where子句后跟条件</li><li>运算符<ul><li>&gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;<code>(!=)</code></li><li>BETWEEN…AND     （包含两边）</li><li><code>IN(集合) </code></li><li>LIKE：模糊查询<ul><li>占位符：<ul><li>_:单个任意字符</li><li>%：多个任意字符（字符数≥0）<br>马% 代表着以 马 作为开头的字符串<br>_华% 代表着第二个字是 华 的字符串<br>%马% 代表着包含着 马 的字符串</li></ul></li></ul></li><li>IS NULL  </li><li>and  或 &amp;&amp;</li><li>or  或 || </li><li>not  或 !<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-- 查询年龄大于20岁</span><br><span class="line">SELECT * FROM student WHERE age &gt; 20;</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE age &gt;= 20;</span><br><span class="line"></span><br><span class="line">-- 查询年龄等于20岁</span><br><span class="line">SELECT * FROM student WHERE age = 20;</span><br><span class="line"></span><br><span class="line">-- 查询年龄不等于20岁</span><br><span class="line">SELECT * FROM student WHERE age != 20;</span><br><span class="line">SELECT * FROM student WHERE age &lt;&gt; 20;</span><br><span class="line"></span><br><span class="line">-- 查询年龄大于等于20 小于等于30</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE age &gt;= 20 &amp;&amp;  age &lt;=30;</span><br><span class="line">SELECT * FROM student WHERE age &gt;= 20 AND  age &lt;=30;</span><br><span class="line">SELECT * FROM student WHERE age BETWEEN 20 AND 30;   包含20和30</span><br><span class="line"></span><br><span class="line">-- 查询年龄22岁，18岁，25岁的信息</span><br><span class="line">SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25</span><br><span class="line">SELECT * FROM student WHERE age IN (22,18,25);</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩为null</span><br><span class="line">SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE english IS NULL;</span><br><span class="line"></span><br><span class="line">-- 查询英语成绩不为null</span><br><span class="line">SELECT * FROM student WHERE english  IS NOT NULL;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询姓马的有哪些？ like</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &#x27;马%&#x27;;</span><br><span class="line">-- 查询姓名第二个字是化的人</span><br><span class="line"></span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &quot;_化%&quot;;</span><br><span class="line"></span><br><span class="line">-- 查询姓名是3个字的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &#x27;___&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查询姓名中包含德的人</span><br><span class="line">SELECT * FROM student WHERE NAME LIKE &#x27;%德%&#x27;;</span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ol><h1 id="DQL-查询语句"><a href="#DQL-查询语句" class="headerlink" title="DQL: 查询语句"></a>DQL: 查询语句</h1><ol><li><p>排序查询</p><ul><li><p>语法：order by 子句</p><ul><li>order by 排序字段1 排序方式1 ，  排序字段2 排序方式2…<br>select * from student order by math DESC;</li></ul></li><li><p>排序方式：</p><ul><li>ASC：升序，默认的。</li><li>DESC：降序。</li></ul></li><li><p>注意：</p><ul><li>如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</li></ul></li></ul></li></ol><ol start="2"><li><p>聚合函数：将<strong>一列数据</strong>作为一个整体，进行纵向的计算。</p><ol><li>count：计算个数<ol><li>一般选择非空的列：主键</li><li><code>count(*)</code><br><code>select count(name) from student</code>;<br>显示student表中名字字段的数目</li></ol></li><li>max：计算最大值</li><li>min：计算最小值</li><li>sum：计算和</li><li>avg：计算平均值</li></ol><ul><li>注意：聚合函数的计算，会排除null值。<br>解决方案：<ol><li>选择不包含非空的列进行计算</li><li>IFNULL函数</li></ol></li></ul></li><li><p>分组查询:</p><ol><li>语法：group by 分组字段；</li><li>注意：<ol><li>分组之后查询的字段：<strong>分组字段、聚合函数</strong>，需要以小组为单位对数据进行处理</li><li>where 和 having 的区别？<ol><li>where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来</li><li>where 后不可以跟聚合函数，having可以进行聚合函数的判断。</li></ol></li></ol></li></ol><p> – 按照性别分组。分别查询男、女同学的平均分</p><p> <code>SELECT sex , AVG(math) FROM student GROUP BY sex</code>;<br> <code>sex是分组字段，AVG(math)是聚合函数</code></p><p> – 按照性别分组。分别查询男、女同学的平均分,人数</p><p> <code>SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex</code>;</p><p> –  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组<br> <code>SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex</code>;</p><p> –  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后，只显示人数大于2个人的<br> <code>SELECT sex , AVG(math),COUNT(id) FROM student WHERE math &gt; 70 GROUP BY sex HAVING COUNT(id) &gt; 2</code>;</p><p> <code>SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math &gt; 70 GROUP BY sex HAVING 人数 &gt; 2</code>;</p></li></ol><ol start="4"><li><p>分页查询</p><ol><li>语法：limit 开始的<strong>索引</strong>,每页查询的条数;</li><li>公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数</li></ol><p>   – 每页显示3条记录 </p><p>   SELECT * FROM student LIMIT 0,3; – 第1页</p><p>   SELECT * FROM student LIMIT 3,3; – 第2页</p><p>   SELECT * FROM student LIMIT 6,3; – 第3页</p><ol start="3"><li>limit 是一个MySQL”方言”,在Oracle中会有其他的语法</li></ol></li></ol><h1 id="DCL-管理用户，授权"><a href="#DCL-管理用户，授权" class="headerlink" title="DCL: 管理用户，授权"></a>DCL: 管理用户，授权</h1><ul><li>DBA：数据库管理员</li></ul><ol><li><p>管理用户</p><ol><li>添加用户：<ul><li>语法：CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’;</li></ul></li><li>删除用户：<ul><li>语法：DROP USER ‘用户名‘@’主机名’;</li></ul></li><li>修改用户密码：</li></ol><p>   <code>UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;) WHERE USER = &#39;用户名&#39;;</code><br>   <code>UPDATE USER SET PASSWORD = PASSWORD(&#39;abc&#39;) WHERE USER = &#39;lisi&#39;;</code></p><p>   <code>SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39; = PASSWORD(&#39;新密码&#39;);</code><br>   <code>SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; = PASSWORD(&#39;123&#39;);</code></p><ul><li>mysql中忘记了root用户的密码？<ol><li>cmd – &gt; net stop mysql 停止mysql服务<ul><li>需要管理员运行该cmd</li></ul></li><li>使用无验证方式启动mysql服务： mysqld –skip-grant-tables</li><li>打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功</li><li>use mysql;</li><li><code>update user set password = password(&#39;你的新密码&#39;) where user = &#39;root&#39;</code>;</li><li>关闭两个窗口</li><li>打开任务管理器，手动结束mysqld.exe 的进程</li><li>启动mysql服务</li><li>使用新密码登录。</li></ol></li></ul><ol start="4"><li>查询用户：</li></ol><p>   – 1. 切换到mysql数据库<br>   USE myql;<br>   – 2. 查询user表<br>   SELECT * FROM USER;</p><ul><li>通配符： % 表示可以在任意主机使用用户登录数据库</li></ul></li><li><p>权限管理：</p><ol><li>查询权限：</li></ol><p>   – 查询权限<br>   SHOW GRANTS FOR ‘用户名‘@’主机名’;<br>   SHOW GRANTS FOR ‘lisi‘@’%’;</p><ol start="2"><li>授予权限：</li></ol><p>   – 授予权限<br>   grant 权限列表 on 数据库名.表名 to ‘用户名‘@’主机名’;<br>   – 给张三用户授予所有权限，在任意数据库任意表上</p><p>   GRANT ALL ON <em>.</em> TO ‘zhangsan‘@’localhost’;</p><ol start="3"><li>撤销权限：</li></ol><p>   – 撤销权限：<br>   revoke 权限列表 on 数据库名.表名 from ‘用户名‘@’主机名’;<br>   REVOKE UPDATE ON db3.’account’ FROM ‘lisi‘@’%’;`</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解</title>
      <link href="/2021/09/25/%E6%B3%A8%E8%A7%A3/"/>
      <url>/2021/09/25/%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><ul><li><p>注解概念：说明程序的。<strong>给计算机看的</strong></p></li><li><p>注释：用文字描述程序的。给程序员看的</p></li><li><p>定义：注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。</p></li><li><p>概念描述：</p><ul><li>JDK1.5之后的新特性</li><li>说明程序的</li><li>使用注解：@注解名称</li></ul></li><li><p>作用分类：</p><ol><li>编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</li><li>代码分析：通过代码里标识的注解对代码进行分析【使用反射】 （主要使用）</li><li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li></ol></li></ul><h1 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h1><ul><li><p>JDK中预定义的一些注解</p><ul><li>@Override    ：检测被该注解标注的方法是否是继承自父类(接口)的</li><li>@Deprecated：该注解标注的内容，表示已过时；在之后程序调用该内容的时候会出现一道横线表示已过时，但仍可以正常使用</li><li>@SuppressWarnings：压制警告，被注解内容的警告将全部不再显示<ul><li>一般传递参数all  <code>@SuppressWarnings(&quot;all&quot;)</code></li></ul></li></ul></li><li><p>自定义注解  见范例1</p><ul><li><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">元注解</span><br><span class="line">public @interface 注解名称&#123;</span><br><span class="line">  属性列表;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>本质：注解本质上就是一个<strong>接口</strong>，该接口默认继承Annotation接口</p><ul><li>public interface MyAnno extends java.lang.annotation.Annotation {}</li></ul></li><li><p>属性：接口中的抽象方法</p><ul><li><p>要求：</p><ol><li><p>属性的返回值类型有下列取值</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li><p>定义了属性，在使用时需要给属性赋值   <code>@注解(属性1=...，属性2=...)</code> ， 按照属性的返回值的类型进行赋值</p><ol><li>如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</li><li>如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</li><li>数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</li></ol></li></ol></li></ul></li><li><p>元注解：用于描述注解的注解</p><ul><li>@Target：描述注解能够作用的位置 如<code>@Target(ElementType.METHOD,ElementType.TYPE)</code><ul><li>ElementType取值：<ul><li>TYPE：可以作用于类上</li><li>METHOD：可以作用于方法上</li><li>FIELD：可以作用于成员变量上</li></ul></li></ul></li><li>@Retention：描述注解被保留的阶段<ul><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</li></ul></li><li>@Documented：描述注解是否被抽取到api文档中</li><li>@Inherited：描述注解是否被子类继承</li></ul></li></ul></li></ul><ul><li>在程序使用（解析）注解：获取注解中定义的属性值  见范例2<ol><li>获取注解定义的位置的对象，（定义在方法上，类上）</li><li>获取指定的注解</li></ol><ul><li><code>getAnnotation(Class)</code><br>其实就是在内存中生成了一个该注解接口的子类实现对象，利用对象调用属性值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ProImpl implements Pro&#123;</span><br><span class="line">    public String className()&#123;</span><br><span class="line">        return &quot;cn.itcast.annotation.Demo1&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public String methodName()&#123;</span><br><span class="line">        return &quot;show&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>调用注解中的抽象方法获取配置的属性值 </li></ol></li></ul><ul><li>小结：<ol><li>以后大多数时候，我们会使用注解，而不是自定义注解</li><li>注解给谁用？<ol><li>编译器</li><li>给解析程序用</li></ol></li><li>注解不是程序的一部分，可以理解为注解就是一个标签，对程序本身无影响</li></ol></li></ul><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><ol><li>简单的定义一个注解并调用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public @interface Anno1 &#123;</span><br><span class="line">    int age();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">public class AnnoDemo01 &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 计算两数的和</span><br><span class="line">     * @param a 整数</span><br><span class="line">     * @param b 整数</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static int add(int a, int b)&#123;</span><br><span class="line">        return a+b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param s</span><br><span class="line">     */</span><br><span class="line">    @Anno1(age = 1)</span><br><span class="line">    public static void tryone(String s)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ul><li>直接在方法前/**加回车即可生成方法注解</li><li>在本类的文件中终端使用javadoc，即可生成注解文件进行查看</li></ul><ol start="2"><li>对自定义注解的内容进行调用，配合反射<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface Anno2 &#123;</span><br><span class="line">    int age();</span><br><span class="line">    String name();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Anno2(age = 8,name = &quot;张三&quot;)</span><br><span class="line">public class AnnoDemo02 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Class&lt;AnnoDemo02&gt; annoDemo02Class = AnnoDemo02.class;</span><br><span class="line">        Anno2 annotation = annoDemo02Class.getAnnotation(Anno2.class);</span><br><span class="line">        int age = annotation.age();</span><br><span class="line">        String name = annotation.name();</span><br><span class="line">        System.out.println(name+age);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>输出 张三8</li></ol>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2021/09/25/%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/09/25/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>反射，框架设计的灵魂<br>框架：半成品软件，可以在框架的基础上进行开发，简化代码<br>反射：将类的各个组成部分封装为其他对象，这就是反射机制<br>具体是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制，减少对框架内容的修改。</p><p>好处</p><ol><li>可以在程序的运行过程中，操作这些对象</li><li>可以解耦，提高程序的可扩展性</li></ol><h1 id="获取Class"><a href="#获取Class" class="headerlink" title="获取Class"></a>获取Class</h1><p>获取class类的三种方式</p><ul><li>类名.class属性  多用于参数的传递</li><li>对象名.getClass()方法  多用于对象的获取字节码的方式</li><li>Class.forName(全类名)方法  多用于配置文件中</li></ul><p> 同一个字节码文件（*.class）在一次程序运行过程中只会被加载一次，不论通过哪种方式获取的class对象都是同一个（多次获取也仍为同一个）</p><h1 id="Class对象功能："><a href="#Class对象功能：" class="headerlink" title="Class对象功能："></a>Class对象功能：</h1><p>使用方式： 先获得class类a，然后 a.对象功能方法<br>获取功能：</p><ol><li><p>获取成员变量们</p><ul><li><code>Field[] getFields()</code> 返回所有公共<code>(public)</code>成员变量对象的数组</li><li><code>Field[] getDeclaredFields()</code> 返回所有成员变量对象的数组</li><li><code>Field getField(String name)</code> 返回单个公共成员变量对象</li><li><code>Field getDeclaredField(String name)</code> 返回单个成员变量对象</li><li><code>成员变量对象.get(类的对象)</code> 获取值  （类的对象可以通过下面的返回构造方法对象来获得）</li><li><code>成员变量对象.set(类的对象，值)</code> 设定值</li><li><code>成员变量对象.setAccessible(true)</code> 忽略private权限修饰符，直接访问，暴力反射（不使用这个get，set无法访问private对象；同理其他也有setAccessible函数，效果相同）</li></ul></li><li><p>获取构造方法们</p><ul><li><code>Constructor&lt;?&gt;[] getConstructors()</code> 返回所有公共构造方法对象的数组</li><li><code>Constructor&lt;?&gt;[] getDeclaredConstructors()</code> 返回所有构造方法对象的数组</li><li><code>Constructor getConstructor(Class&lt;?&gt;... parameterTypes)</code> 返回单个公共构造方法对象（<code>getConstructor(String.class, int.class)</code>）</li><li><code>Constructor getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code> 返回单个构造方法对象</li><li><code>构造方法对象.newInstance(参数,参数)</code> 创建对象</li><li>如果没有参数 可以直接 <code>a.newInstance()</code>,省略创建构造方法对象的步骤</li></ul></li><li><p>获取成员方法们</p><ul><li><code>Method[] getMethods()</code> 返回所有公共成员方法对象的数组，包括继承的</li><li><code>Method[] getDeclaredMethods()</code> 返回所有成员方法对象的数组，不包括继承的</li><li><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code> 返回单个公共成员方法对象</li><li>无参数 如 <code>getMethod(eat)</code></li><li>有参数 如 <code>getMethod(eat，String.class)</code></li><li><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code> 返回单个成员方法对象</li><li><code>方法对象.invoke(类的对象,方法要传递参数（没有就不写）)</code></li><li><code>方法对象.getName()</code> 获取方法名</li></ul></li><li><p>获取类名</p></li></ol><ul><li><code>String getName()</code></li></ul><h1 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class Person &#123;</span><br><span class="line">    private int age;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;age=&quot; + age +</span><br><span class="line">                &quot;, name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person(int age, String name) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void eat(String food)&#123;</span><br><span class="line">        System.out.println(&quot;eat&quot;+food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public class ReflectDemo &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception&#123;</span><br><span class="line">//        Class&lt;?&gt; aClass = Class.forName(&quot;domain.Person&quot;);</span><br><span class="line">//        System.out.println(aClass);</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">//        System.out.println(personClass);</span><br><span class="line">//        Person p = new Person();</span><br><span class="line">//        Class&lt;? extends Person&gt; aClass1 = p.getClass();</span><br><span class="line">//        System.out.println(aClass1);</span><br><span class="line">        Method method = personClass.getMethod(&quot;eat&quot;,String.class);</span><br><span class="line">        Constructor&lt;Person&gt; constructor = personClass.getConstructor();</span><br><span class="line">        Person person = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        method.invoke(person,&quot;大米&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果<br>输出 eat大米</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
            <tag> 框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Junit测试</title>
      <link href="/2021/09/24/Junit%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/09/24/Junit%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h1><p>测试分类</p><ul><li>黑盒测试 不需要写代码，关注输入能否得到目标期望值</li><li>白盒测试 需要写代码，关注程序具体流程</li></ul><p>Junit 单元测试就是白盒测试，可以专门建立一个test包，用于测试，不必每次新建一个main函数</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li>定义个测试类<ul><li>建议：<ul><li>测试类名：被测试类名Test</li><li>包名：xxxx.xxxx.test   <strong>不可以写成xxxx.xxxx.Test，会和注解重名，导致程序无法运行</strong></li></ul></li></ul></li><li>定义测试方法：可以独立运行<ul><li>建议：<ul><li>方法名：test测试的方法名</li><li>返回值void</li><li>参数列表：空参</li></ul></li></ul></li><li>给方法加@Test注解</li><li>导入junit依赖环境</li><li>之后测试方法左边会出现三角箭头，点击运行，可以一次只测试一个方法</li></ol><h1 id="判定"><a href="#判定" class="headerlink" title="判定"></a>判定</h1><p>判定结果：</p><ul><li>验证结果是否正确的方法一般通过断言<br><code>Assert.assertEquals(期望结果，运算结果)</code></li></ul><p>补充：</p><ul><li><p>初始化方法：用于资源申请，所有测试方法在执行之前都会先执行该方法<br>添加一个@Before</p></li><li><p>释放资源方法：在所有方法执行完后，都会自动执行该方法<br>添加一个@After</p></li><li><p>每个方法测试前后都会执行这两个方法</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class CalculatorTest &#123;</span><br><span class="line">    @Before</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        System.out.println(&quot;start&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @After</span><br><span class="line">    public void close()&#123;</span><br><span class="line">        System.out.println(&quot;close&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        Calculator cal = new Calculator();</span><br><span class="line">        System.out.println(&quot;test&quot;);</span><br><span class="line">        int add = cal.add(1, 2);</span><br><span class="line">        Assert.assertEquals(3,add);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果<br><img style="width:1000px" src="https://img11.360buyimg.com/ddimg/jfs/t1/6491/10/18261/65587/614d3eacE296136ae/487c8d7608df8d8c.png"></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流</title>
      <link href="/2021/09/23/Stream%E6%B5%81/"/>
      <url>/2021/09/23/Stream%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h1><p>Stream流与IO流无关，类似于lambda的简化，关注的是做什么，而不是怎么做<br>Stream流的好处</p><ul><li>直接阅读代码的字面意思即可完美展示无关逻辑方式的语义：获取流、过滤姓张、过滤长度为3、逐一打印</li><li>Stream流把真正的函数式编程风格引入到Java中</li></ul><p>Stream流的特点</p><ul><li>Stream流的是一个来自数据源的元素队列，数据源流的来源，可以是集合，数组等</li><li>Stream流属于管道流，只能被消费使用一次，第一个Stream流调用完毕方法，数据就会流转到下一个Stream上，而此时第一个Stream流已经使用完毕并关闭，无法再调用</li></ul><h1 id="Stream流的使用"><a href="#Stream流的使用" class="headerlink" title="Stream流的使用"></a>Stream流的使用</h1><h2 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h2><p>获取一个流的方式</p><ul><li>Collection体系集合<br>使用默认方法<code>stream()</code>生成流， <code>default Stream stream()</code></li><li>Map体系集合<br>把Map转成Set集合，间接的生成流（<code>set.stream()</code>）</li><li>数组<br>通过Stream接口的静态方法<code>of(T... values)</code>生成流<code>(Stream.of(数组)</code>或者<code>Stream.of(1,2,3,4))</code></li></ul><h2 id="中间方法"><a href="#中间方法" class="headerlink" title="中间方法"></a>中间方法</h2><p>（基本处理方式大概是每次会对流中的一个元素进行处理，并递进）<br>中间方法的特点：执行完此方法之后，返回值类型仍是Stream接口，Stream流依然可以继续执行其他操作。</p><ul><li><p><code>Stream filter(Predicate predicate)</code> 用于对流中的数据进行过滤<br>Predicate接口是一个判断类的函数式接口，包含一个<code>test(T t)</code>的抽象方法，对数据按照需求进行判断，如果<code>test(T t)</code>返回一个true，则将数据放在新的流中</p></li><li><p><code>Stream limit(long maxSize)</code> 返回此流中的元素组成的流，截取前指定参数个数的数据</p></li><li><p><code>Stream skip(long n)</code> 跳过指定参数个数的数据，返回由该流的剩余元素组成的流</p></li><li><p><code>static Stream concat(Stream a, Stream b)</code> 合并a和b两个流为一个流</p></li><li><p><code>Stream map(Function mapper)</code> 返回由给定函数应用于此流的元素的结果组成的流，将流中的元素映射到另一个流中去<br>Function接口是一个函数式接口，包含抽象方法<code>apply(T t)</code>,可以将T类型转化为R类型</p></li></ul><h2 id="终结方法"><a href="#终结方法" class="headerlink" title="终结方法"></a>终结方法</h2><p>执行完此方法之后，返回值类型不再是Stream接口，Stream流将不能再执行其他操作。<br>终结方法</p><ul><li><code>void forEach(Consumer action)</code> 对此流的每个元素执行操作<br>Consumer接口是一个消费型的函数式接口，包含一个<code>accept(T t)</code>抽象方法，意味消费一个指定泛型的数据<br>目的是用来遍历流中的数据，并配合accept的Lambda</li><li><code>long count()</code> 返回此流中的元素数</li></ul><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>函数式接口的处理方式就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.filter((test抽象函数参数) -&gt; &#123;test抽象函数内容&#125;).map((...) -&gt; &#123;...&#125;).forEach.((...) -&gt; &#123;...&#125;)</span><br></pre></td></tr></table></figure><p>配合前面的博客食用</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方法引用</title>
      <link href="/2021/09/23/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
      <url>/2021/09/23/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>该篇感觉整体较为复杂，理解不很到位，建议需要的时候再去补一下视频</p><h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>方法引用<br><code>::</code>该符号为引用运算符，而它所在的表达式被称为方法引用</p><ul><li>Lambda简化写法 <code>usePrintable(s -&gt; System.out.println(s))</code>;</li><li>方法引用 <code>usePrintable(System.out::println)</code>;</li></ul><p>类似于将使用Lambda的地方替换为方法引用，并省略传递参数</p><h1 id="成员方法引用"><a href="#成员方法引用" class="headerlink" title="成员方法引用"></a>成员方法引用</h1><p>通过对象引用类中的成员方法，只要对象存在，成员方法存在<br>格式<br>对象::成员方法<br>范例<br><code>&quot;HelloWorld&quot;::toUpperCase</code><br>String类中的方法：<code>public String toUpperCase()</code> 将此String所有字符转换为大写</p><h1 id="其他引用"><a href="#其他引用" class="headerlink" title="其他引用"></a>其他引用</h1><ul><li>通过类名引用静态成员方法，类已存在，静态成员方法也已经存在</li><li>类似有父类super引用，本类this引用，构造器引用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式接口</title>
      <link href="/2021/09/20/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/09/20/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<ol><li>函数式接口就是仅包含一个抽象方法的接口</li><li>函数式接口可以使用Lambda表达式</li><li>接口做参数，参数传递的可以是接口的实现类</li><li>接口的实现类又可以使用匿名内部类或者Lambda方法进行书写简化</li></ol><p>大概就是这样的内容</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程案例</title>
      <link href="/2021/09/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/09/14/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><font size = 7>文件上传案例分析</font></p><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>文件上传案例的客户端：读取本地文件，上传到服务器，读取服务器回写的数据<br>实现步骤</p><ol><li>创建一个本地字节输入流FileInputStream对象，构造方法中绑定要读取的数据源</li><li>创建一个客户端socket对象，构造方法中绑定服务器的IP地址和端口号</li><li>使用Socket对象中的方法<code>getOutputStream()</code>获取网络字节输出流OutputStream对象</li><li>使用本地字节输入流FileInputStream对象中的方法read，读取本地文件</li><li>使用网络字节输出流OutputStream对象中的方法write，把读取到的文件上传到服务器</li><li>使用Socket对象中的方法<code>getInputStream()</code>获取网络字节输入流InputStream对象</li><li>使用网络字节输入流InputStream对象的方法read，读取服务器回写数据</li><li>释放资源（FileInputStream，Socket）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DemoUploadClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;D:\\JavaProject\\Client\\1.png&quot;);</span><br><span class="line">        InetAddress dstAddress;</span><br><span class="line">        Socket socket = new Socket(&quot;10.128.196.110&quot;,8888);</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        int len = 0;</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        while ((len = fis.read(bytes))!=-1)&#123;</span><br><span class="line">            outputStream.write(bytes,0,len);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        // 给服务器上传一个终止序列，解决无法停止bug</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        while ((len = inputStream.read(bytes))!=-1)&#123;</span><br><span class="line">            System.out.println(new String(bytes,0,len));</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h1><p>文件上传案例的服务器端：读取客户端上传的文件，保存到服务器的硬盘，给客户端回写上传成功<br>实现步骤</p><ol><li>创建服务器ServerSocket对象和系统要指定的端口号</li><li>使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket,接下来使用此Socket的方法</li><li>使用Socket对象中的方法getInputStream()获取网络字节输入流InputStream对象</li><li>判断目标文件夹是否存在，不存在则创建</li><li>创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地</li><li>使用网络字节输入流InputStream对象的方法read，读取客户端上传的文件</li><li>使用本地字节输出流FileOutputStream对象中的方法write，把读取到文件保存到服务器的硬盘上</li><li>使用Socket对象中的方法getOutputStream()获取网络字节输出流OutputStream对象</li><li>使用网络字节输出流OutputStream对象中的方法write，给客户端回上传成功</li><li>释放资源（FileOutputStream,Socket,ServerSocket）</li></ol><p><strong>客户端和服务器端无法停止</strong>原因解释：<br>因为read方法当没有东西可以读取会陷入到阻塞状态。<br>客户端的while本地文件读取时不会将结束标记写给服务器，<br>导致服务器端永远也读取不到文件的结束标记，read方法进入到阻塞状态</p><p>解决方案：</p><ul><li> 客户端在上传完文件后，给服务器写一个结束标记<br><code>shutdownOutput()</code> : 禁用此套接字的输出流 ，对于TCP套接字，任何以前写入的数据都将被发送，并且后跟TCP的正常连接终止序列<br>这个函数可以给服务器上传一个结束标记</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class DemoUploadServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(8888);</span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        File file = new File(&quot;D:\\JavaProject\\Server&quot;);</span><br><span class="line">        if (!file.exists())&#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">            // 若无文件夹则创建该文件夹</span><br><span class="line">        &#125;</span><br><span class="line">        FileOutputStream fileOutputStream = new FileOutputStream(&quot;D:\\JavaProject\\Server\\beauty.png&quot;);</span><br><span class="line">        // 具体到文件</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = inputStream.read(bytes))!=-1)&#123;</span><br><span class="line">            fileOutputStream.write(bytes,0,len);</span><br><span class="line">        &#125;</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(&quot;文件上传成功&quot;.getBytes());</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ol><li>添加多线程思路</li><li>使服务器始终处于监听状态，客户端可以一直保持文件的传输</li><li>再添加服务器端存储文件时的名称处理，避免发生文件覆盖<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01Server &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(8888);</span><br><span class="line">//        int i = 1;</span><br><span class="line">        /*</span><br><span class="line">        让服务器不再停止，一直处于运行状态，客户端随时上传数据</span><br><span class="line">         */</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">//            System.out.println(i);</span><br><span class="line">//            i = i+1;</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">            提高效率可以使用多线程技术，有一个客户端上传文件，就开启一个线程，完成文件的上传.</span><br><span class="line">            同时上传很多文件时，开启多个线程，可以提高效率</span><br><span class="line"></span><br><span class="line">            但是本次socket没有释放，可以直接进入下个循环开启新的线程吗?</span><br><span class="line">            2021.9.14已解决</span><br><span class="line">            经过实验，本次的socket即使没有释放，但只要有新的客户端出现依然可以进入下一个循环，</span><br><span class="line">            即代码逻辑正确，出现新的客户端就开启新的线程，不占用主程序，提高利用率</span><br><span class="line">             */</span><br><span class="line">            new Thread(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    // 抽象的run方法没有声明抛出异常，所以重写方法时不能抛出，要用try catch</span><br><span class="line">                    try &#123;</span><br><span class="line">                        InputStream inputStream = socket.getInputStream();</span><br><span class="line">                        File file = new File(&quot;D:\\JavaProject\\Server&quot;);</span><br><span class="line">                        if (!file.exists())&#123;</span><br><span class="line">                            file.mkdirs();</span><br><span class="line">                            // 若无文件夹则创建该文件夹</span><br><span class="line">                        &#125;</span><br><span class="line">                        String filename = &quot;girl&quot;+System.currentTimeMillis()+new Random().nextInt(99999)+&quot;.png&quot;;</span><br><span class="line">                        FileOutputStream fileOutputStream = new FileOutputStream(file+&quot;\\&quot;+filename);</span><br><span class="line">                        // 具体到文件</span><br><span class="line">                        byte[] bytes = new byte[1024];</span><br><span class="line">                        int len = 0;</span><br><span class="line">                        while ((len = inputStream.read(bytes))!=-1)&#123;</span><br><span class="line">                            fileOutputStream.write(bytes,0,len);</span><br><span class="line">                        &#125;</span><br><span class="line">                        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">                        outputStream.write(&quot;文件上传成功&quot;.getBytes());</span><br><span class="line">                        fileOutputStream.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;catch (IOException e)&#123;</span><br><span class="line">                        System.out.println(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        //serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><img style = "width:600px" src = "https://img12.360buyimg.com/ddimg/jfs/t1/199636/33/8269/65417/614022aeE0cdb838b/d04ad01b3049d175.png"><img style = "width:600px" src = "https://img11.360buyimg.com/ddimg/jfs/t1/77566/21/16909/107959/6140233fE71163afb/a204cea54d51c0a6.png">]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程</title>
      <link href="/2021/09/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2021/09/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>网络编程就是在一定的协议下，实现两台计算机的通信的程序<br>网络编程三要素</p><ul><li>IP地址<br>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机<br>和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识</li><li>端口<br>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？<strong>如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了,也就是应用程序的标识</strong></li><li>协议<br>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则<br>被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，<strong>通信双方必须同时遵守才能完成数据交换</strong>。常见的协议有<strong>UDP</strong>协议和<strong>TCP</strong>协议<br>UDP效率高但是会数据丢失，TCP确保数据传输，但是效率不如UDP</li></ul><h1 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h1><img style="width:1000px" src="https://img10.360buyimg.com/ddimg/jfs/t1/205024/13/6374/1504379/613ef2cfE35c31638/1e53ecf8009f10de.jpg">  <p>注意服务器端必须明确的两件事情</p><h2 id="TCP通信的客户端"><a href="#TCP通信的客户端" class="headerlink" title="TCP通信的客户端"></a>TCP通信的客户端</h2><p>向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据<br>表示客户端的类：</p><ul><li>Socket：此类实现客户端套接字（也可以就叫“套接字”）。套接字是两台机器间通信的端点<br>套接字：包含了IP地址和端口号的网络单位</li></ul><p>构造方法</p><ul><li><p><code>Socket(InetAddress address,int port)</code> 创建流套接字并将其连接到指定IP指定端口号</p></li><li><p><code>Socket(String host, int port)</code> 创建流套接字并将其连接到指定主机上的指定端口号<br>host 服务器主机的名称/服务器的IP地址，使用时要加引号<br>port 服务器的端口号</p></li></ul><p>成员方法</p><ul><li><code>InputStream getInputStream()</code> 返回此套接字的输入流</li><li><code>OutputStream getOutputStream()</code> 返回此套接字的输出流</li></ul><p>实现步骤</p><ol><li>创建一个客户端对象socket，构造方法绑定服务器的IP地址和端口号</li><li>使用Socket对象中的方法<code>getOutputStream()</code>获取网络字节输出流OutputStream对象,由客户端发向服务器端</li><li>使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据</li><li>使用Socket对象中的方法<code>getInputStream()</code>获取网络字节输入流InputStream对象，由服务器端发向客户端</li><li>使用网络字节输入流InputStream对象的方法read，读取服务器回写数据</li><li>释放资源（socket）</li></ol><p>注意事项</p><ul><li>客户端和服务器交互必须使用socket中提供的网络流，不能使用自己创建的流对象</li><li>当我们创建客户端对象socket的时候，就会去请求服务器和服务器经过3次握手建立连接通路<ol><li>这时如果服务器没有启动，那么就会抛出异常</li><li>如果服务器已经启动，那么就可以进行交互了</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TCPClient &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Socket socket = new Socket(&quot;10.128.196.110&quot;,8888);</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(&quot;你好服务器&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int len = inputStream.read(bytes);</span><br><span class="line">        System.out.println(new String(bytes,0,len));</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="TCP通信的服务器端"><a href="#TCP通信的服务器端" class="headerlink" title="TCP通信的服务器端"></a>TCP通信的服务器端</h2><p>接收客户端请求，读取客户端发送的数据，给客户端回写数据<br>表示服务器的类</p><ul><li> ServerSocket 此类实现服务器套接字</li></ul><p>构造方法</p><ul><li> <code>ServletSocket(int port)</code> 创建绑定到指定端口的服务器套接字</li></ul><p>服务器端必须知道哪个客户端请求的服务器,所以可以使用accept方法获取到请求的客户端对象socket</p><ul><li><code> Socket accept()</code> 监听要连接到此的套接字并接受它</li></ul><p>服务器的实现步骤</p><ol><li>创建服务器ServerSocket对象和系统要指定的端口号</li><li>使用ServerSocket对象中的方法accept，获取到请求的客户端对象Socket,接下来使用此Socket的方法</li><li>使用Socket对象中的方法<code>getInputStream()</code>获取网络字节输入流InputStream对象，由客户端发向服务器端</li><li>使用网络字节输入流InputStream对象的方法read，读取客户端发送的数据</li><li>使用Socket对象中的方法<code>getOutputStream()</code>获取网络字节输出流OutputStream对象,由服务器端发向客户端</li><li>使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据</li><li>释放资源（Socket，ServerSocket）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TCPServer &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        ServerSocket serverSocket = new ServerSocket(8888);</span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int len = inputStream.read(bytes);</span><br><span class="line">        System.out.println(new String(bytes,0,len));</span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        outputStream.write(&quot;收到谢谢&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在客户端和服务器端使用while大量接受字节流出现报错，暂时没有解决</li></ul><p>2021.9.14已解决，具体解决方案在网络编程案例中，大概原因时客户端没有给服务器上传结束标记，造成阻塞</p><p>要先运行服务器端，此时服务器端会一直保持运行，直到客户端开始运行并完成网络信息交互，服务器端才会释放资源完成运行</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><img style="width:600px" src="https://img13.360buyimg.com/ddimg/jfs/t1/61047/37/17197/21579/613ef4b3E6eda65f3/4034ba6678d9d1d4.png">  <img style="width:600px" src="https://img11.360buyimg.com/ddimg/jfs/t1/198270/6/8359/20015/613ef4ecE5f726df0/bc934472ff3cc560.png">  ]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓冲流</title>
      <link href="/2021/09/07/%E7%BC%93%E5%86%B2%E6%B5%81/"/>
      <url>/2021/09/07/%E7%BC%93%E5%86%B2%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>缓冲流是对IO流的一种增强<br>给基本的流对象增加一个缓冲区（数组），<strong>提高流对象的效率</strong></p><h1 id="BufferedOutputStream"><a href="#BufferedOutputStream" class="headerlink" title="BufferedOutputStream"></a>BufferedOutputStream</h1><p>节缓冲输出流 继承父类OutputStream的成员方法<br><code>BufferedOutputStream(OutputStream out)</code> 创建字节缓冲输出流对象<br>使用步骤</p><ol><li>创建FileOutputStream对象，构造方法中绑定要输出的目的地</li><li>创建BufferedOutputStream对象，构造方法中传递FileOutputStream对象</li><li>使用BufferedOutputStream对象中的方法write，把数据写入到内部缓冲区中</li><li>使用BufferedOutputStream对象中的方法flush，把内部缓冲区中的数据刷新到文件中</li><li>释放资源（第4步可以省略）</li></ol><h1 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h1><p>字节缓冲输入流 继承父类InputStream的成员方法<br><code>BufferedInputStream(InputStream in)</code> 创建字节缓冲输入流对象</p><p>使用步骤（重点）</p><ol><li>创建FileIutputStream对象，构造方法中绑定要读取的数据源</li><li>创建BufferedIutputStream对象，构造方法中传递FileIutputStream对象</li><li>使用BufferedIutputStream对象中的方法read，读取文件</li><li>释放资源</li></ol><h1 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h1><p>字符缓冲输出流 继承writer的所有成员方法<br><code>BufferedWriter(Writer out)</code> 创建字符缓冲输出流对象<br>特有方法</p><ul><li><code>void newLine()</code> 写一行行分隔符，行分隔符字符串由系统属性定义，为输出完成换行</li></ul><p>使用步骤</p><ol><li>创建字符缓冲输出流对象，构造文件中传递字符输出流</li><li>调用字符缓冲输出流中的方法write，把数据写入到内存缓冲区中</li><li>调用字符缓冲流中的方法flush，把内存缓冲区中的数据率刷新到文件中</li><li>释放资源</li></ol><h1 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h1><p>字符缓冲输入流 继承了Reader的所有成员方法<br><code>BufferedReader(Reader in)</code> 创建字符缓冲输入流对象<br>特有方法</p><ul><li><code>String readLine()</code> 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符(例如换行符)，如果流的结尾已经到达（超过有内容的最后一行），则为null</li></ul><p>使用步骤</p><ol><li>创建字符缓冲输入流对象，构造文件中传递字符输入流</li><li>使用字符缓冲输入流对象中的方法read/readline读取文本</li><li>释放资源</li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试代码<br>把一个文件的乱序内容排序输出到一个新的文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class DemoTest &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        TreeMap&lt;String, String&gt; map = new TreeMap&lt;&gt;();</span><br><span class="line">        BufferedReader br = new BufferedReader(new FileReader(&quot;Demo03\\demo.txt&quot;));</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;Demo03\\out.txt&quot;));</span><br><span class="line">        String line;</span><br><span class="line">        while ((line = br.readLine()) != null)&#123;</span><br><span class="line">            String[] ary = line.split(&quot;\\.&quot;);</span><br><span class="line">            // .是转义字符，需要\\处理</span><br><span class="line">            map.put(ary[0],ary[1]);</span><br><span class="line">            // Treemap会自动排序</span><br><span class="line">        &#125;</span><br><span class="line">        for (String key: map.keySet()</span><br><span class="line">             ) &#123;</span><br><span class="line">            String s = map.get(key);</span><br><span class="line">            line = key + &quot;.&quot; + s;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原文件内容<br><img style="width:800px" src="https://img14.360buyimg.com/ddimg/jfs/t1/202453/23/5437/18820/61370ae5E4d56dcbd/48a5355f33b6a648.png">  </p><p>新文件内容<br><img style="width:800px" src="https://img13.360buyimg.com/ddimg/jfs/t1/197544/5/7185/16599/61370b2dEa045d152/241f1d28ff83659c.png">  </p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生开学了</title>
      <link href="/2021/08/30/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%BC%80%E5%AD%A6%E4%BA%86/"/>
      <url>/2021/08/30/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%BC%80%E5%AD%A6%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>9月1号就要滚回学校开学了，希望开学可以与室友同学保持良好的交流关系，与工友建立积极的合作关系，与导师最好是亦师亦友的高效关系，少遇到一些脑瘫，多遇到贵人，生活每天快快乐乐。</p><p>还要督促自己每天加油学习+减肥，学习不能停；一定要努力完成导师布置的任务，少被导师骂，导师人很好，骂你是因为你不争气，要保持积极向上的心，不要因为被骂过于影响自己的心态，学会去调整自己的不成熟；有目的地提升编程能力，奥里给。</p><p>最后，希望这新的学期可以找到一个我喜欢，也喜欢我的漂亮女朋友，短发女孩儿天下第一。<br><img style="width:1000px" src="https://img11.360buyimg.com/ddimg/jfs/t1/196674/23/20765/171357/612cd0a2E5f19f10c/cc2cf02c458aa39b.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO流</title>
      <link href="/2021/08/29/IO%E6%B5%81/"/>
      <url>/2021/08/29/IO%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><img style="width:1000px" src="https://s3.bmp.ovh/imgs/2021/08/08a961692c56b99f.png"><p><strong>流向内存是输入流（从文件调用内容），流出内存的是输出流（向文件存储内容）</strong></p><h1 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h1><h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><p>输出字节流的一些子类的共性成员方法</p><ul><li><code>public void close()</code> ：关闭此输出流并释放与此流相关联的任何系统资源。</li><li><code>public void flush()</code> ：刷新此输出流并强制任何缓冲的输出字节被写出。</li><li><code>public void write(byte[] b)</code> ：将 b.length字节从指定的字节数组写入此输出流。</li><li><code>public void write(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。</li><li><code>public abstract void write(int b)</code> ：将指定的字节输出流。</li></ul><p>小贴士： </p><ol><li>close方法，当完成流的操作时，<strong>必须</strong>调用此方法，释放系统资源。</li><li><code>byte[] getBytes()</code> 把字符串转换为字节数组</li></ol><h3 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h3><p>文件字节输出流 继承了OutputStream<br>把内存中的数据写入到硬盘的文件中</p><ul><li><code>public FileOutputStream(File file)</code> ：创建文件输出流以写入由指定的File对象表示的文件。</li><li><code>public FileOutputStream(String name)</code> ： 创建文件输出流以指定的名称写入文件。</li></ul><p><strong>但是这样的方法写入不是续写，而是每次直接全部重写</strong></p><p>构造方法的作用</p><ol><li>创建一个FileOutputStream对象</li><li>会根据构造方法中传递的文件/文件路径，创建一个空的文件</li><li>会把FileOutputStream对象指向创建好的文件</li></ol><p>字节输出流的使用步骤（重点）</p><ol><li>创建一个FileOutputStream对象，构造方法中传递写入数据的目的地</li><li>调用FileOutputStream对象中的方法write，把数据写入到文件中</li><li>释放资源</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01OutputStream &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;Demo03\\a.txt&quot;);</span><br><span class="line">        // 相对路径（相对的是这个module，即Demo_NewTeacher）和绝对路径都可以，一个\是转义字符，要\\才行</span><br><span class="line">        fos.write(97);</span><br><span class="line">        // 存储时会把十进制97转化为二进制，因为存储的是是字节，打开文件的时候（如记事本），会自动</span><br><span class="line">        // 把字节转化为字符，此时存储的97就显示为了a</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件存储的是 a</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01OutputStream &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(new File(&quot;Demo03\\a.txt&quot;));</span><br><span class="line">        // 不是续写，而是每次直接重写a.txt</span><br><span class="line">        byte[] bytes = &#123;65, 66, 67, 68, 69, 70&#125;;</span><br><span class="line">        byte[] bytes1 = &quot;你好&quot;.getBytes();</span><br><span class="line">        fos.write(bytes);</span><br><span class="line">        fos.write(bytes1);</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件中存储的是 ABCDEF你好</p><p>续写文件的方法</p><ul><li><code>public FileOutputStream(File file, boolean append)</code> ： 创建文件输出流以写入由指定的 File对象表示的 文件。</li><li><code>public FileOutputStream(String name, boolean append)</code> ： 创建文件输出流以指定的名称写入文件。<br>这两个构造方法，参数中都需要传入一个boolean类型的值， true 表示追加数据， false 表示清空原有数据。</li></ul><p>文件换行的方法</p><ul><li><code>write(&quot;\r\n&quot;.getBytes())</code> 换行</li></ul><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><p>字节输入流的基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此输入流并释放与此流相关联的任何系统资源。</li><li><code>public abstract int read()</code> ： 从输入流读取数据的下一个字节，返回的是每个字符对应的ASCAII码数字（一个汉字需要3个字符）</li><li><code>public int read(byte[] b)</code> ： 从输入流中读取一些字节数，并将它们存储到字节数组b中 。<br>小贴士： close方法，当完成流的操作时，必须调用此方法，释放系统资源。</li></ul><h3 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h3><p>文件字节输入流<br>作用 把硬盘文件中的数据读取到内存中使用</p><p>构造方法</p><ul><li><code>FileInputStream(File file)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的File对象 file命名。</li><li><code>FileInputStream(String name)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</li></ul><p>使用步骤</p><ol><li>创建一个FileInputStream对象，构造方法中绑定要读取的数据源</li><li>使用FileInputStream对象中的read方法，读取文件</li><li>释放资源</li></ol><p>注意:</p><ol><li>每次调用<code>read()</code>指针会自动向后移，读取到文件的末尾返回-1</li><li><code>String(byte[] bytes)</code>把字节数组bytes转换为字符串，打印的是AB<br><code>Arrays.toString(bytes) </code>打印的是65，66（把指定数组内容变为逗号分隔的字符串）<br> <strong>⬆⬆⬆⬆⬆⬆⬆注意区分</strong><br><code>String(byte[] b, int off, int len)</code> ：从指定的字节数组写入 len字节，从off开始转换b数组。</li><li>一次读取多个字节的<code>read(byte[] b)</code>同样会在每次读取后指针向后移，参数<code>byte[]</code>存储每次读到的多个字节，返回值为每次读取的有效字节个数，无新字节返回-1</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Demo02InPutStream &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;Demo03\\a.txt&quot;);</span><br><span class="line">        int read = fis.read();</span><br><span class="line">        System.out.println(read);</span><br><span class="line">        // 每次调用read指针会自动向后移，读取到文件的末尾返回-1</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回A</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Demo02InPutStream &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;Demo03\\a.txt&quot;);</span><br><span class="line">        byte[] bytes = new byte[1024];</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = fis.read(bytes)) != -1)&#123;</span><br><span class="line">            System.out.println(new String(bytes, 0, len));</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回ABCDEF你好</p><h1 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h1><p>字符流 以字符为单位读写数据，专门用于处理文本文件。</p><h2 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h2><p>字符输入流 Reader<br>基本共性功能方法。</p><ul><li><code>public void close()</code> ：关闭此流并释放与此流相关联的任何系统资源。</li><li><code>public int read() </code>： 从输入流读取一个字符。</li><li><code>public int read(char[] cbuf)</code> ： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</li></ul><h3 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h3><p>文件字符输入流<br>构造方法</p><ul><li><code>FileReader(File file)</code> ： 创建一个新的 FileReader ，给定要读取的File对象。</li><li><code>FileReader(String fileName)</code> ： 创建一个新的 FileReader ，给定要读取的文件的名称。</li></ul><p>步骤</p><ol><li>创建FileReader对象，构造方法中绑定要读取的数据源</li><li>使用FileReader对象中的方法read读取文件</li><li>释放资源</li></ol><p>他是一个一个的读取字符，“你”就输出20320，即输出的是一个字符完整的二进制字节<br>可以用（char）xx 强制将二进制字节转化为字符</p><h2 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h2><p>字符输出流 Writer</p><ul><li><code>void write(int c)</code> 写入单个字符。</li><li><code>void write(char[] cbuf)</code> 写入字符数组。</li><li><code>abstract void write(char[] cbuf, int off, int len)</code> 写入字符数组的某一部分,off数组的开始索引,len 写的字符个数。</li><li><code>void write(String str)</code> 写入字符串。</li><li><code>void write(String str, int off, int len)</code> 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</li><li><code>void flush()</code> 刷新该流的缓冲。 <code>void close()</code> 关闭此流，但要先刷新它。</li></ul><h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p>文件字符输出流，作用：把内存中的字符数据写入到文件中</p><p>构造方法</p><ul><li><code>FileWriter(File file)</code> ： 创建一个新的 FileWriter，给定要读取的File对象。</li><li><code>FileWriter(String fileName)</code> ： 创建一个新的 FileWriter，给定要读取的文件的名称。</li></ul><p>步骤（重要）</p><ol><li>创建FileWriter对象，构造方法中绑定要写入数据的目的地</li><li>使用FileReader对象中的方法write，把数据写入到内存缓冲区中（字符转化为字节的过程）</li><li>使用FileReader中的方法flush，把内存缓冲区中的数据刷新到文件中</li><li>释放资源（会先把内存缓冲区中的数据刷新到文件中，用close就可以不用flush）</li></ol><p>续写</p><ul><li><code>FileWriter（。。。, boolen append）</code></li></ul><p>换行</p><ul><li><code>\r\n</code><br>（因为可以写入字符串，直接写进去就可以换行，不需要转换）</li></ul><p>小贴士：</p><ul><li>字符流，只能操作文本文件，不能操作图片，视频等非文本文件。</li><li>当我们单纯读或者写文本文件时，使用字符流，其他情况使用字节流</li></ul><h1 id="IO异常处理"><a href="#IO异常处理" class="headerlink" title="IO异常处理"></a>IO异常处理</h1><p>在实际开发中处理这样的IO异常要使用try。。catch。。finally，不要抛出处理<br>处理过程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class HandleException1 &#123; </span><br><span class="line">    public static void main(String[] args) &#123; </span><br><span class="line">        // 声明变量 </span><br><span class="line">        FileWriter fw = null; </span><br><span class="line">        try &#123;</span><br><span class="line">            //创建流对象 </span><br><span class="line">            fw = new FileWriter(&quot;fw.txt&quot;); </span><br><span class="line">            // 写出数据 </span><br><span class="line">            fw.write(&quot;黑马程序员&quot;); //黑马程序员 </span><br><span class="line">        &#125; catch (IOException e) &#123; </span><br><span class="line">            e.printStackTrace(); </span><br><span class="line">        &#125; finally &#123; </span><br><span class="line">            try &#123;</span><br><span class="line">                if (fw != null) &#123; </span><br><span class="line">                    fw.close(); </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; catch (IOException e) &#123; </span><br><span class="line">                e.printStackTrace(); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用JDK7优化后的 try-with-resource 语句来处理异常，该语句确保了每个资源在语句结束时关闭。<br>所谓的资源 （resource）是指在程序完成后，必须关闭的对象，即会自动把流对象释放，不用在finally中写close</p><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try (创建流对象语句，如果多个,使用&#x27;;&#x27;隔开)&#123;</span><br><span class="line">// 读写数据</span><br><span class="line">&#125;catch (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK9又进行优化<br>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A a = new A();</span><br><span class="line">B b = new B();</span><br><span class="line">try(a;b)&#123;</span><br><span class="line">    读写数据</span><br><span class="line">&#125;catch(....)&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h1><p>Properties集合是一个唯一可以和IO流相结合的集合<br>可以对IO流进行store和load操作<br>具体需要再查</p><h1 id="字节字符转换问题"><a href="#字节字符转换问题" class="headerlink" title="字节字符转换问题"></a>字节字符转换问题</h1><p>文件存储是字节，字符变为字节是编码，字节变为字符是解码<br>编码解码必须是同一套charset机制</p><ul><li>IDEA默认的是UTF-8编码</li><li>windows系统创建的文本文件是默认GBK编码，这样子会产生乱码（但我尝试了下，好像现在是默认UTF-8了）</li></ul><p>对此需要使用转换流来进行处理</p><h2 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h2><p>继承了writer，OutputStreamWriter是字符流通向字节流的桥梁：可使用指定的 charset 将要写入流中的字符编码成字节<br>（编码，能看懂的变成看不懂的）<br>构造方法</p><ul><li><code>OutputStreamWriter(OutputStream out)</code> 创建使用默认字符编码的 OutputStreamWriter，默认UTF-8。</li><li><code>OutputStreamWriter(OutputStream out, String charsetName)</code> 创建使用指定字符集的 OutputStreamWriter。</li></ul><p>参数</p><ul><li>OutputStream out 字节输出流</li><li>String charsetName 指定的编码表面名称，不区分大小写</li></ul><p>使用步骤</p><ol><li>创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称</li><li>使用OutputStreamWriter对象中的方法write，把字符转换为字节存储到缓冲区中</li><li>使用OutputStreamWriter对象中的方法flush，刷新。。</li><li>资源释放</li></ol><h2 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h2><p>继承了Reader，InputStreamReader 是字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符<br>（解码，看不懂的变成能看懂的）<br>构造方法</p><ul><li><code>InputStreamReader(InputStream in)</code> 创建一个使用默认字符集的 InputStreamReader。</li><li><code>InputStreamReader(InputStream in, String charsetName)</code> 创建使用指定字符集的 InputStreamReader。</li></ul><p>参数</p><ul><li>InputStream in 字节输入流</li></ul><p>使用步骤</p><ol><li>建IutputStreamReader对象，构造方法中传递字节输入流和指定的编码表名称</li><li>使用InputStreamReader对象中的方法read读取文件</li><li>释放资源</li></ol><p>注意事项</p><ul><li>构造方法中指定的编码表名称要和文件的编码<strong>相同</strong>，否则会发生乱码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class Demo04FileReaderProlem &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        write_gbk();</span><br><span class="line">        read_gbk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void read_gbk() throws IOException &#123;</span><br><span class="line">        InputStream in;</span><br><span class="line">        Charset charset;</span><br><span class="line">        InputStreamReader isr = new InputStreamReader(new FileInputStream(&quot;Demo03\\gbk.txt&quot;), &quot;gbk&quot;);</span><br><span class="line">        int len = 0;</span><br><span class="line">        while ((len = isr.read()) != -1)&#123;</span><br><span class="line">            System.out.println((char)len);</span><br><span class="line">        &#125;</span><br><span class="line">        isr.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void write_gbk() throws IOException &#123;</span><br><span class="line">        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;Demo03\\gbk.txt&quot;),&quot;gbk&quot; );</span><br><span class="line">        osw.write(&quot;你好啊&quot;);</span><br><span class="line">        osw.flush();</span><br><span class="line">        osw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以GBK的方式写入写出，读出的文件用char强制转换是<br>你<br>好<br>啊<br>如果不强制转换输出<br>20320<br>22909<br>21834</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2021/08/27/%E9%80%92%E5%BD%92/"/>
      <url>/2021/08/27/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>递归分为两种</p><ul><li>直接递归 自己调用自己</li><li>简介递归 A调B，B调C，C调A</li></ul><p>注意事项</p><ul><li>递归一定要有条件限制，保证递归可以停下来，否则会发生栈内存溢出</li><li>在递归中即使有限定条件，递归次数也不能太多，否则也会发生栈内存溢出</li><li>构造方法，禁止递归</li></ul><p>当调用方法的时候，方法的主体不变，每次调用方法的参数不同，可以使用递归，如累加</p><p>（前面有一个关于File类的使用讲解，简单听了听，没做什么笔记，需要到时候再去看）</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/2021/08/25/%E7%BA%BF%E7%A8%8B/"/>
      <url>/2021/08/25/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p>并发： 当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状态，这种方式我们称之为并发 （Concurrent）。</p><p>并行： 当系统有一个以上CPU时,则线程的操作有可能非并发。 当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行 （Parallel）。</p><p>区别： 并发和并行是即相似又有区别的两个概念，并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔内发生。</p><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>进程： 是指一个内存中运行的应用程序<br>线程： 线程是进程中的一个执行单元<br>一个程序运行至少有一个进程，一个进程可以包含多个线程<br><strong>一个cpu同一时刻只能处理一个线程</strong><br><img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/16/29/53e95591-46fa-4527-bb06-7c9e0babf6a7.png"> </p><ul><li>主线程：执行主（main）方法的线程</li><li>单线程程序：java程序中只有一个线程</li><li>执行从main方法开始，从上到下依次执行，一旦出现异常会影响后续程序的执行</li></ul><h1 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h1><h2 id="创建Thread类的子类"><a href="#创建Thread类的子类" class="headerlink" title="创建Thread类的子类"></a>创建Thread类的子类</h2><p>创建多线程程序的第一种方式：创建Thread类的子类<br>实现步骤</p><ol><li>创建一个Thread类的子类</li><li>在Thread类的子类中重写Thread类的run方法，设置线程任务（开启线程要做什么）</li><li>创建Thread类的子类对象</li><li>调用Thread类的start方法，开启新的线程，执行run方法<br>结果两个线程并发的运行，main线程和创建的执行run方法的新线程<br>java程序属于抢占式调度，哪个线程优先级高，哪个线程就优先执行,每次执行结果都不太相同</li></ol><p>Thread类中的方法</p><ul><li><code>getName()</code>返回线程的名称</li><li><code>currentThread()</code> 静态方法，返回对当前正在执行的线程对象的引用</li><li><code>setName(&quot;&quot;)</code> 给线程起名字</li><li>创建一个带参数的构造方法，参数传递线程名称，然后调用父类的带参构造方法<code>super(&quot;name&quot;)</code></li><li><code>sleep(long millis)</code> 使线程以指定时间ms暂停，该线程放弃对cpu的执行权<h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2>创建多线程的第二种方式:实现Runnable接口<br>实现步骤</li></ul><ol><li>创建Runnable的实现类</li><li>重写run方法，设置线程任务</li><li>创建一个Runnable接口的实现类对象</li><li>创建Thread类对象，构造方法中传递Runnable的实现类对象</li><li>调用thread类的start方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 定义实现类</span><br><span class="line">public class RunnableImpl implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主程序</span><br><span class="line">public class Demo02Runnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RunnableImpl able = new RunnableImpl();</span><br><span class="line">        Thread thread = new Thread(able);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>结果<img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/16/45/6866b434-ef41-4e06-8fd6-190e57c42d18.png"> </li></ol><p>实现Runnable接口创建多线程的好处（即第一类创建方法的缺点）</p><ul><li>避免了单继承的局限性</li><li>增强了程序的扩展性，降低了程序的耦合性，把设置线程任务（实现类重写run）和开启新线程（创建Thread类对象）进行了分离</li><li>适合多个相同的程序代码的线程去<strong>共享一个</strong>资源<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2>作用为简化代码,但在之后学习的Lambda方法在特定情况下会更为简化一些<br>格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new 父类/接口（）&#123;</span><br><span class="line">   重写父类/接口中的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>之后再进行组合，具体过程见InnerClass<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Demo03InnerClass &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;---&gt;&quot;+&quot;nihao&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                for (int i = 0; i &lt; 20; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+&quot;-------&gt;&quot;+&quot;fk&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>多线程访问了共享的数据，会产生线程安全问题（三个人吃一个蛋糕，A吃了一口以后，B再去吃蛋糕却仍保持原状，就是线程安全问题）<br><img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/16/31/0cc923b8-88bf-4e9d-b44c-0442400729da.png"> </p><p>为了保证每个线程都正常执行，引入线程同步机制,有三种同步方法</p><ol><li>同步代码块</li><li>同步方法</li><li>锁机制</li></ol><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><p>代码块写在方法中<br>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">synchronized（锁对象）&#123;</span><br><span class="line">    可能会出现线程安全问题的代码（访问了共享数据的代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ul><li>锁对象任意，叫同步锁，对象锁，对象监视器</li><li>但必须多个线程使用同一个锁对象（写在run方法外面，写在里面会重复创建），当锁对象被一个线程使用的时候，其他线程就没有锁对象，无法运行对应的代码块</li><li>锁对象把同步代码块锁住，只让一个线程在同步代码块中执行</li><li>不停判断同步锁，降低效率</li><li><strong>即使该代码块出现sleep也仍然执行这个代码块，但是wait会跳出该代码块</strong></li></ul><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>使用步骤</p><ol><li>把访问共享数据的代码抽取出来，放到一个方法中</li><li>在方法上添加synchronized修饰符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 synchronized 返回值类型  方法名（参数列表）&#123;</span><br><span class="line">     可能会出现线程安全问题的代码（访问了共享数据的代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在run方法外定义，run方法内调用即可</li></ol><h2 id="Lock锁"><a href="#Lock锁" class="headerlink" title="Lock锁"></a>Lock锁</h2><p>实现了比synchronized更广泛的锁定操作<br>lock（） 获取锁<br>unlock（） 释放锁</p><p>使用步骤</p><ol><li>在成员位置（run方法外面,类似于类中成员变量的位置）创建一个ReentrantLock对象 Lock l = new ReentrantLock()</li><li>在可能出现安全问题的代码前调用Lock接口的方法lock（）获取锁 l.lock()</li><li>在可能出现安全问题的代码后调用Lock接口的方法unlock（）释放锁 l.unlock()</li></ol><h1 id="等待唤醒"><a href="#等待唤醒" class="headerlink" title="等待唤醒"></a>等待唤醒</h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>等待唤醒案例：<strong>线程之间通信</strong><br>创建一个顾客线程（消费者）： 告知老板的种类和数量，调用<strong>wait</strong>方法，放弃cpu的执行，进入到WAITING状态（<em>无限等待</em>）<br>创建一个老板线程（生产者）： 花了5s做包子，做好之后，调用<strong>notify</strong>方法，唤醒顾客吃包子<br><img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/16/40/ce0a01c5-6994-40f9-bcd5-39bb30375541.png"> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class Demo04WaitAndNotify &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Object obj = new Object();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                    /*sleep一定要放在同步代码块外面，放在里面即使sleep也不会跳出执行，会被对象锁锁住</span><br><span class="line">                    不管线程先执行哪个，</span><br><span class="line">                    1.先执行老板线程，遇到sleep，老板线程挂起5s钟，在挂起时立即执行顾客线程，遇到wait，顾客线程也挂起（不再被对象锁锁住）</span><br><span class="line">                    ，等到5s后，老板线程继续执行，触发notify(此时顾客线程唤醒)并执行完同步代码块中的任务后，顾客线程开始执行wait</span><br><span class="line">                    之后的内容</span><br><span class="line">                    2.顾客先执行线程同理，顾客wait后，老板线程执行，sleep之后因为顾客线程等待，不会发生线程转换而是继续执行老板线程，之后。。</span><br><span class="line">                    */</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                synchronized (obj) &#123;</span><br><span class="line">                    System.out.println(&quot;老板5s后包子出锅&quot;);</span><br><span class="line"></span><br><span class="line">                    obj.notify();</span><br><span class="line">                    System.out.println(&quot;?&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        new Thread()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                synchronized (obj) &#123;</span><br><span class="line">                    System.out.println(&quot;顾客告知想吃的包子种类和数量&quot;);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(&quot;包子做好了，真好吃&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>notify唤醒wait的线程重新加入对cpu的竞争中，优先唤醒等待时间最长的线程</li><li>notifyall唤醒所有等待的线程</li></ul><p>注意</p><ul><li>顾客和老板线程必须使用同步代码块包裹起来，等待和唤醒只能有一个在执行</li><li>唯一的锁对象才能调用wait和notify方法，<strong>对于同一锁对象的各个线程，若一个线程调用wait和notify，wait使本线程锁住，notify唤醒其他线程（只要是一个锁对象，不同的线程之间就可以互相通信操作）</strong></li><li>不同线程的不同同步代码块只要是<strong>同一个锁对象</strong>，就只能有一个在运行</li></ul><h2 id="具体的等待唤醒机制"><a href="#具体的等待唤醒机制" class="headerlink" title="具体的等待唤醒机制"></a>具体的等待唤醒机制</h2><p>等待唤醒机制其实就是经典的“生产者与消费者”的问题。<br>就拿生产包子消费包子来说等待唤醒机制如何有效利用资源：<br>包子铺线程生产包子，吃货线程消费包子。当包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子 （即包子状态为true），并通知吃货线程（解除吃货的等待状态）,因为已经有包子了，那么包子铺线程进入等待状态。 接下来，吃货线程能否进一步执行则取决于锁的获取情况。如果吃货获取到锁，那么就执行吃包子动作，包子吃完（包 子状态为false），并通知包子铺线程（解除包子铺的等待状态）,吃货线程进入等待。包子铺线程能否进一步执行则取 决于锁的获取情况。<br>详见下图ThreadProject</p><h3 id="包子类"><a href="#包子类" class="headerlink" title="包子类"></a>包子类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BaoZi &#123;</span><br><span class="line">    String pi;</span><br><span class="line">    String xian;</span><br><span class="line">    boolean flag = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包子铺线程"><a href="#包子铺线程" class="headerlink" title="包子铺线程"></a>包子铺线程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class BaoZiPu extends Thread&#123;</span><br><span class="line">    private BaoZi bz;</span><br><span class="line"></span><br><span class="line">    public BaoZiPu(BaoZi bz) &#123;</span><br><span class="line">        this.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line">    // 从外部传来相同的包子类对象作为对象锁</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            synchronized (bz)&#123;</span><br><span class="line">                if (bz.flag==true)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                        // 包子铺线程挂起</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (count%2==0)&#123;</span><br><span class="line">                    bz.pi = &quot;薄皮&quot;;</span><br><span class="line">                    bz.xian = &quot;三鲜馅&quot;;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    bz.pi = &quot;冰皮&quot;;</span><br><span class="line">                    bz.xian= &quot;牛肉大葱&quot;;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(&quot;包子铺正在生产：&quot;+bz.pi+bz.xian+&quot;包子&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                bz.flag = true;</span><br><span class="line">                bz.notify();</span><br><span class="line">                // 唤醒吃货线程</span><br><span class="line">                System.out.println(&quot;包子已经成产好了：&quot;+bz.pi+bz.xian+&quot;包子，吃货可以开始吃了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="吃货"><a href="#吃货" class="headerlink" title="吃货"></a>吃货</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class ChiHuo extends Thread&#123;</span><br><span class="line">    private BaoZi bz;</span><br><span class="line"></span><br><span class="line">    public ChiHuo(BaoZi bz) &#123;</span><br><span class="line">        this.bz = bz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            synchronized (bz)&#123;</span><br><span class="line">                if (bz.flag==false)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        bz.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(&quot;吃货正在吃：&quot;+bz.pi+bz.xian+&quot;包子&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                bz.flag = false;</span><br><span class="line">                System.out.println(&quot;吃货吃完了包子&quot;);</span><br><span class="line">                System.out.println(&quot;======================&quot;);</span><br><span class="line">                bz.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Demo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        BaoZi baoZi = new BaoZi();</span><br><span class="line">        new BaoZiPu(baoZi).start();</span><br><span class="line">        new ChiHuo(baoZi).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/16/52/58ace8b2-930f-495a-8bb1-e17e43c549df.png"> <h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作， 无需反复创建线程而消耗过多资源<br><img style="width:800px" src="https://pic.stackoverflow.wiki/uploadImages/39/149/60/192/2021/08/25/17/01/cb4b15bb-a079-4fdf-af80-2ca746d94271.png"> </p><p>创建线程池要使用Executors类中的静态方法<br>static ExecutorService newFixedThreadPool（int nThreads）</p><ul><li>参数为线程池中的线程数量</li><li>返回值 返回ExecutorService接口的实现类对象<br>submit（Runnable task） 提交一个runnable任务用于执行，即从线程池获取一个线程，调用start<br>shutdown（） 关闭/销毁线程</li></ul><p>使用步骤</p><ol><li>newFixedThreadPool生产线程池</li><li>创建一个类，实现Runnable接口，重写run</li><li>调用submit，开启线程，执行run，执行之后会自动归还线程，但主程序并不会停止，因为此时线程池还在开启中</li><li>shutdown销毁线程（不建议执行）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class RunnableImpl implements Runnable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo01ThreadPool &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(2);</span><br><span class="line"></span><br><span class="line">        es.submit(new RunnableImpl());</span><br><span class="line">        es.submit(new RunnableImpl());</span><br><span class="line">        es.submit(new RunnableImpl());</span><br><span class="line">        es.submit(new RunnableImpl());</span><br><span class="line">        es.submit(new RunnableImpl());</span><br><span class="line"></span><br><span class="line">        es.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为<br>pool-1-thread-2<br>pool-1-thread-1<br>pool-1-thread-2<br>pool-1-thread-1<br>pool-1-thread-2</p><h1 id="Lambda函数式编程"><a href="#Lambda函数式编程" class="headerlink" title="Lambda函数式编程"></a>Lambda函数式编程</h1><p>面向对象的思想: 做一件事情,找一个能解决这个事情的对象,调用对象的方法,完成事情.<br>函数式编程思想: 只要能获取到结果,谁去做的,怎么做的都不重要,重视的是结果,不重视过程<br>不再有“不得不创建接口对象”的束缚，不再有“抽象方法覆盖重写”的负担</p><p>格式<br>1.一些参数 2.一个箭头 3.一段代码<br>（参数列表）-&gt;{重写方法的代码}</p><ul><li>（）接口中要重写的抽象方法的参数列表</li><li>-&gt; 传递，把参数传递给方法体</li><li>{} 重写接口抽象方法的方法体</li></ul><p>不需要再新建一个类new….<br><strong>不只是线程类，其他各种类的使用中也可以使用Lambda方法</strong></p><p>在Lambda标准格式的基础上，使用省略写法的规则为：</p><ol><li>小括号内参数的类型可以省略；</li><li>如果小括号内有且仅有一个参，则小括号可以省略；</li><li>如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li></ol><p>注意</p><ol><li>使用Lambda必须具有接口，且要求接口中<strong>有且仅有一个抽象方法</strong>。</li><li>使用Lambda必须具有上下文推断。<br>备注：有且仅有一个抽象方法的接口，称为“函数式接口”。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Demo01Runnable &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName());</span><br><span class="line">          &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为<br>Thread-0<br>Thread-1<br>可以观察到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简化为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; &#123;System.out.println(Thread.currentThread().getName());&#125;</span><br></pre></td></tr></table></figure><p>省略了创建对象，直接从 <code>run()</code>入手，因为是唯一的抽象方法，<code>()</code>即可代表<code>run()</code></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/2021/08/21/%E5%BC%82%E5%B8%B8/"/>
      <url>/2021/08/21/%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="Debug调试程序："><a href="#Debug调试程序：" class="headerlink" title="Debug调试程序："></a>Debug调试程序：</h1><p>可以让代码逐行执行，查看代码执行的过程，调试过程中的bug<br>使用方式：</p><ul><li>在行号的右边鼠标左键单击添加断点</li><li>右键选择debug,程序会停留在第一个断点处执行程序<ul><li>f8 逐行执行程序</li><li>f7 进入到方法中，不然在主程序的下一行会直接输出方法的结果，而不会执行方法的一行一行</li><li>shift+f8 跳出方法</li><li>f9 跳到下一个断点，若没有下一个断点就结束程序</li><li>ctrl+f2 退出debug，停止程序</li><li>Console 切换回控制台</li></ul></li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常指的是程序在执行过程中出现的非正常情况<br>指的并不是语法错误，如果语法错了，编译不通过，根本不能运行<br>Throwable是所有错误和异常的超类</p><h1 id="异常类型"><a href="#异常类型" class="headerlink" title="异常类型"></a>异常类型</h1><p>Exception</p><ul><li>编译期异常，进行写代码出现的问题</li><li>RuntimeException 运行期异常，运行过程中出现的问题</li><li>异常就相当于一个小毛病，处理掉就可以继续执行</li></ul><p>Error错误</p><ul><li>错误就相当于程序得了一个无法治愈的毛病，必须修改源代码才能继续执行</li></ul><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>java异常处理的五个关键字：try catch finally throw throws</p><h2 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h2><p>throw可以在指定的方法中抛出指定的异常<br>使用格式 <code>throw new xxxException(&quot;异常产生的原因&quot;)</code><br>注意</p><ol><li>必须写在方法的内部</li><li>new后边的对象必须是Exception或者Exception的子类对象</li><li>抛出指定的异常对象，我们必须处理这个异常对象<ul><li>throw关键字后边创建的是运行期异常RuntimeException或者RuntimeException的子类对象，可以不处理</li><li>throw关键字后边创建的是编译异常（写代码时报错），必须处理，用throws或者try…catch</li></ul></li></ol><h2 id="throws"><a href="#throws" class="headerlink" title="throws"></a>throws</h2><p>throws关键字：异常处理的第一种方式，交给别人处理<br>使用格式：在方法声明时使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名 （参数列表） throws AAAException，BBBException&#123;</span><br><span class="line">    throw new AAAException(&quot;异常产生的原因&quot;)</span><br><span class="line">    throw new BBBException(&quot;异常产生的原因&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>必须写在方法声明处</li><li>后面的声明异常必须是Exception或者Exception的子类对象</li><li>方法内部抛出多个异常，那么throws后边必须声明多个，如果异常有子父类关系，直接声明父类即可</li><li>方法要throws声明，main函数也要throws声明，但是有缺点，方法中异常之后的代码不会再处理</li></ol><h2 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h2><p>try…catch关键字：异常处理的第二种方式，自己处理异常<br>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    可能产生异常的代码</span><br><span class="line">&#125;catch（定义一个异常变量，用来接收try中的异常对象）&#123;</span><br><span class="line">    异常处理逻辑，接受异常对象后怎么处理异常对象</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">catch（异常类名xxException 变量名）&#123;...&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ol><li>try抛出多个异常对象，就可以使用多个catch来处理这些异常对象</li><li><ul><li>如果try中产生了异常，就会执行catch中的异常处理逻辑，执行完之后继续执行之后的代码</li><li>如果try中没有异常，执行完try中的代码之后继续执行try…catch之后的代码</li></ul></li><li>可以是方法throws声明个异常，然后在main函数中使用try…catch处理这个方法的异常</li><li>try多个异常的时候，会执行第一个遇到的异常的catch，剩下的异常不再处理</li></ol><h2 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h2><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">   可能产生异常的代码</span><br><span class="line">&#125;catch（定义一个异常变量，用来接收try中的异常对象）&#123;</span><br><span class="line">   异常处理逻辑，接受异常对象后怎么处理异常对象</span><br><span class="line">&#125;</span><br><span class="line"> 。。。</span><br><span class="line">catch（异常类名xxException 变量名）&#123;&#125;</span><br><span class="line">finally&#123;</span><br><span class="line">  无论是否出现异常都会执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ul><li>finally不能单独使用，必须和try一起使用</li><li>finally一般用于资源释放（资源回收），无论程序是否出现异常，最后都要资源释放（IO）</li></ul><h2 id="子父类异常"><a href="#子父类异常" class="headerlink" title="子父类异常"></a>子父类异常</h2><ul><li> 如果父类抛出了多个异常，子类重写父类方法时，子类需要抛出和父类相同的异常，或者是父类异常的子类，或者不抛出异常</li><li> 父类没有抛出异常，子类重写该方法时也不能抛出异常，只能对异常捕获处理try…catch，不能声明抛出throws</li></ul><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><p>java提供的异常类不够我们使用，需要自己定义一些异常类<br>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class XXXException extends Exception / RuntimeException&#123;</span><br><span class="line">  添加一个空参数的构造方法&#123;super（）&#125;</span><br><span class="line">  添加一个带异常信息的构造方法 （String message）&#123;super(message)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意</p><ol><li>自定义异常类一般都是以Exception结尾</li><li>自定义异常类，必须继承Exception / RuntimeException<ul><li> 继承Exception：自定义异常类是编译异常</li><li> 继承RuntimeException： 自定义异常类就是运行期异常，遇到异常会中断程序</li></ul></li></ol><h3 id="异常类定义示例"><a href="#异常类定义示例" class="headerlink" title="异常类定义示例"></a>异常类定义示例</h3><img style="width:800px" src="https://s3.bmp.ovh/imgs/2021/08/5ded087cb540e922.png"> <h3 id="抛出实现"><a href="#抛出实现" class="headerlink" title="抛出实现"></a>抛出实现</h3><img style="width:800px" src="https://s3.bmp.ovh/imgs/2021/08/ea71650d4f3f6793.png"> <h3 id="捕获实现"><a href="#捕获实现" class="headerlink" title="捕获实现"></a>捕获实现</h3><img style="width:800px" src="https://s3.bmp.ovh/imgs/2021/08/e9cee69672f60a5a.png"> ]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map</title>
      <link href="/2021/08/17/Map/"/>
      <url>/2021/08/17/Map/</url>
      
        <content type="html"><![CDATA[<h1 id="Map的基本内容"><a href="#Map的基本内容" class="headerlink" title="Map的基本内容"></a>Map的基本内容</h1><p> Map集合是一个双列集合，一个元素包含两个值（key，value）</p><ul><li>key和value的数据类型可以相同，也可以不同</li><li>key不允许重复，value可以重复</li><li>key和value是一一对应的</li><li>HashMap很快，但无序，继承Map方法</li></ul><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><ul><li>get（key）=&gt;value 根据key值获得value。。。</li><li>put（key, value）=&gt;value 存储进map中，若key不重复返回空，若重复返回被替换的value</li><li>remove（key）=&gt;value 移除key，返回value值</li><li>containkey（key）=&gt;booolean 是否含有这个key</li></ul><h1 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h1><ul><li>keyset（）<br>将Map的key全部返回到一个set中，可以利用set的特点遍历key获取value</li><li>entrySet（）<br>将map的entry对象取出存储到set中，（entry对象就是键值对的映射关系，类似于结婚证），<br>entry对象有getKey()和getValue()方法，可以在遍历中使用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可变参数方法</title>
      <link href="/2021/08/15/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95/"/>
      <url>/2021/08/15/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>当方法的参数列表数据类型已经确定，但个数不确定时，可以使用可变参数</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>修饰符 返回值类型 方法名（数据类型…变量名）{}<br>这个变量实际上是一个数组</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>一个参数列表只能由一种类型的可变参数，不可以（int…..a, String….b）</li><li>若有多种数据类型，可变参数要放在最后一个 （int a， string b， int…c）</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class KeBian &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int add = method(1,3,4,5,8,9);</span><br><span class="line">        System.out.println(add);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static int method(int...ints) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int anInt : ints) &#123;</span><br><span class="line">            sum += anInt;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新电脑第一次博客测试</title>
      <link href="/2021/08/13/%E6%96%B0%E7%94%B5%E8%84%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/"/>
      <url>/2021/08/13/%E6%96%B0%E7%94%B5%E8%84%91%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>歪日，YOGA14S轻薄本可真好用</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型</title>
      <link href="/2021/08/11/%E6%B3%9B%E5%9E%8B/"/>
      <url>/2021/08/11/%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><img style="width:1000px" src="https://z3.ax1x.com/2021/08/11/fa3zsf.jpg"> <p>具体需要什么类型的数据不知道，就使用泛型定义<br>使用泛型</p><ul><li>避免了类型转换的麻烦，存储的是什么类型取出的就是什么类型</li><li>但泛型是什么类型就只能存储什么类型的数据</li></ul><p>不使用泛型</p><ul><li>可以存储任意类型的数据,但不安全会引发异常<br>如 Arraylist list = new Arraylist()</li></ul><h1 id="泛型类的定义"><a href="#泛型类的定义" class="headerlink" title="泛型类的定义"></a>泛型类的定义</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class GenericClass&lt;E&gt; &#123;</span><br><span class="line">    private E name;</span><br><span class="line"></span><br><span class="line">    public E getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(E name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo02Generic &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GenericClass gc = new GenericClass();</span><br><span class="line">        gc.setName(&quot;Object name&quot;);</span><br><span class="line">        Object name = gc.getName();</span><br><span class="line">        System.out.println(name);</span><br><span class="line"></span><br><span class="line">        GenericClass gc1 = new GenericClass();</span><br><span class="line">        gc1.setName(2);</span><br><span class="line">        Object name1 = gc1.getName();</span><br><span class="line">        System.out.println(name1);</span><br><span class="line"></span><br><span class="line">        GenericClass&lt;Integer&gt; gc2 = new GenericClass&lt;&gt;();</span><br><span class="line">        gc2.setName(4);</span><br><span class="line">        Integer name2 = gc2.getName();</span><br><span class="line">        System.out.println(name2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型接口的定义"><a href="#泛型接口的定义" class="headerlink" title="泛型接口的定义"></a>泛型接口的定义</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface GenericInterface &lt;E&gt;&#123;</span><br><span class="line">    public abstract void method(E e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class GenericInterfaceImp2&lt;E&gt; implements GenericInterface&lt;E&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method(E e) &#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class GenericInterfaceImpl1 implements GenericInterface&lt;String&gt;&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void method(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="泛型方法定义"><a href="#泛型方法定义" class="headerlink" title="泛型方法定义"></a>泛型方法定义</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class GenericMethod &#123;</span><br><span class="line">    public &lt;E&gt; void method01(E e)&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Demo02Generic &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        GenericMethod gm = new GenericMethod();</span><br><span class="line">        gm.method01(1);</span><br><span class="line">        gm.method01(&quot;Hello&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="泛型的通配符"><a href="#泛型的通配符" class="headerlink" title="泛型的通配符"></a>泛型的通配符</h1><p>泛型的通配符 ?  代表任意的数据类型<br>食用方法</p><ul><li>不能创建对象使用，只能作为<strong>方法的参数</strong>使用</li><li>? extends E       ?对应的类必须是E或者是E的子类</li><li>? super E         ?对应的类必须是E或者是E的父类</li></ul><p> 简单用法<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public class Demo03Generic &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(&quot;a&quot;);</span><br><span class="line">        list1.add(&quot;b&quot;);</span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">        list2.add(1);</span><br><span class="line">        list2.add(2);</span><br><span class="line">        method(list1);</span><br><span class="line">        method(list2);</span><br><span class="line">        // ArrayList&lt;?&gt; list3 = .......错误</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void method(ArrayList&lt;?&gt; list) &#123;</span><br><span class="line">        Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">        while (iterator.hasNext())&#123;</span><br><span class="line">            Object next = iterator.next();</span><br><span class="line">            System.out.println(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Collection集合</title>
      <link href="/2021/08/11/Collection%E9%9B%86%E5%90%88/"/>
      <url>/2021/08/11/Collection%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><img style="width:1000px" src="https://z3.ax1x.com/2021/08/11/faQAKS.jpg"> <p>Collection 是所有单列集合最顶层的接口（Map是双列接口），里面定义了所有单列集合的共性方法</p><h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><ul><li><code>boolean add(E e) </code>添加元素</li><li><code>boolean remove(Object o)</code> 从集合中移除指定的元素</li><li><code>void clear()</code> 清空集合中的元素</li><li><code>boolean contains(Object o)</code> 判断集合中是否存在指定的元素</li><li><code>boolean isEmpty()</code> 判断集合是否为空</li><li><code>int size()</code>集合的长度，也就是集合中元素的个数</li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是Collection集合中元素的通用获取方式，是一个接口</p><ul><li><code>hasNext()</code> 判断有没有下一个元素可以迭代</li><li><code>next（）</code> 返回迭代的下一个元素</li><li><code>iterator()</code> 返回迭代器的实现类（接口无法直接使用）</li></ul><p>步骤</p><ol><li>iterator()获取实现类</li><li>hasNext()判断</li><li>next（）取出<br>如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; co = new ArrayList&lt;&gt;();</span><br><span class="line">co.add(&quot;Hello&quot;);</span><br><span class="line">co.add(&quot;en&quot;);</span><br><span class="line">co.add(&quot;ok&quot;);</span><br><span class="line">Iterator&lt;String&gt; it = co.iterator();</span><br><span class="line">// 多态  接口            实现类对象</span><br><span class="line">// 获取实现类对象并把指针指向集合的-1索引</span><br><span class="line">while (it.hasNext())&#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    // 取出下一个元素并且指针向后移动一位</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h1><p>增强for循环本质也是一种迭代器，使用for循环格式简化了迭代器的书写,所有的单列集合都可以使用增强for<br>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for（数据类型 变量名：集合名/数组名）&#123;</span><br><span class="line">    sout（变量名）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量名对应的就是集合或数组中的数据<br>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();;</span><br><span class="line">list.add(&quot;aaa&quot;);</span><br><span class="line">list.add(&quot;bbb&quot;);</span><br><span class="line">list.add(&quot;ccc&quot;);</span><br><span class="line">list.add(&quot;ddd&quot;);</span><br><span class="line">for (String i:list) &#123;</span><br><span class="line">    System.out.println(i)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h1><p>详见ArrayList<br>ArrayList 查询快，增删慢，底部是Array数组</p><p>LinkedList增删快。查询慢，底部是链表，有很多的首尾元素操作方法</p><h1 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h1><p>set集合的特点</p><ul><li>不允许存储重复的元素</li><li>没有索引，也不能使用普通的for循环进行遍历</li></ul><p>HashSet继承set</p><ul><li>是一个无序的集合，存储元素和取出元素的顺序有可能不一致</li><li>底层是一个哈希表，哈希表：数组 + 链表/红黑树</li></ul><p>如果HashSet存储自定义类型元素（如Student类），想要元素不重复，必须重写hashcode和equals方法</p><p>LinkedHashSet 集合不允许重复，但是保证元素有序</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/2021/08/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/08/07/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>字符串String是常量；它们的值在创建之后不能更改。字符串缓冲区StringBuilder支持可变的字符串<br>字符串本身就是一个对象，可以<code>str.methods()</code></p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>==是进行字符串的地址值比较，内容的比较是 <code>str1.equals(str2)</code>，但是str1不可以是空值，因为空值没有方法</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><ul><li><code>str.length()</code> 获取长度</li><li><code>str1.concat(str2) </code>将1和2拼接并返回</li><li><code>str.charAt(0)</code> 返回字符串的第一个字符</li><li><code>str.indexOf（a）</code>返回字符串第一个参数字符串a首次出现的索引位置，没有返回-1</li><li><code>str.substring(index)</code> 从参数位置一直截取到字符串末尾</li><li><code>str.substring(begin, end)</code> 从begin一直截取到end [begin, end)</li><li><code>str.toCharArray()</code> 将字符串转换为数组并返回</li><li><code>str.getBytes()</code> 获得当前字符串的底层字节数组 a==&gt;97，并返回</li><li><code>str.replace(oldString, newString)</code> 返回一个新的字符串，用new的部分替换old的部分</li><li><code>&quot;a,b,c&quot;.split(&quot;,&quot;)</code>  -&gt; <code>&#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;</code> 将字符串按照规定进行拆分<br>若原字符串想要根据”.”进行拆分，因为”.”是转义字符，必须写成<code>split(&quot;\\.&quot;)</code></li></ul><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>StringBuilder字符串缓冲区，可以对字符串进行操作，提高字符串的效率</p><ul><li><code>StringBuilder()</code> 构造一个空的字符串生成器，初始容量16个字符</li><li><code>StringBuilder(Str)</code> 构造一个字符串生成器，初始化为指定的字符串内容 <strong>字符串-&gt;字符串生成器</strong></li></ul><p>常用方法</p><ul><li><code>bu1.append()</code> 向后添加字符串，不必接收返回值，直接反映在bu1中<br>可以<code>bu1.append().append().append()</code></li><li><code>bu.toString()</code> <strong>字符串生成器-&gt;字符串</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内部类</title>
      <link href="/2021/08/07/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
      <url>/2021/08/07/%E5%86%85%E9%83%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>一个类内部包含另一个类，就像身体和心脏的关系<br>分类</p><ol><li>成员内部类</li><li>局部内部类（包含匿名内部类）</li></ol><h1 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">     修饰符 class 内部类名称&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:</p><ol><li>内用外，随意访问；外用内，需要内部类对象</li><li>主函数调用内部类函数<br><code>外部类名称.内部类名称 对象名 = new 外部类名称（）.new 内部类名称（）</code></li><li>内部类调用外部类的重名变量<br><code>外部类名称.this.变量名</code></li></ol><h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><p>一个类是定义在一个方法内部，只有当前这个方法才能用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 外部类名称&#123;</span><br><span class="line">     修饰符 返回值类型 外部类方法名称（）&#123;</span><br><span class="line">         class 局部内部类名称&#123;&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局部内部类如果希望访问所在方法的局部变量，那这个局部变量必须是有效final的</p><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>如果接口的实现类或者是父类的子类只需要使用<strong>唯一一次</strong>,那么这种情况下就可以省略掉该类的定义。而使用匿名内部类（较为重要）<br>定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口名称 对象名 = new 接口名称（）&#123;</span><br><span class="line">     覆盖重写所有的抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承</title>
      <link href="/2021/08/02/%E7%BB%A7%E6%89%BF/"/>
      <url>/2021/08/02/%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><ol><li>定义父类的格式 （一个普通的类定义）<ul><li>public class 父类名称{}</li></ul></li><li>定义子类的格式<ul><li>public class 子类名称 <strong>extends</strong> 父类名称{}</li><li>继承时访问重名的成员变量/方法，优先使用最近的对象的，没有再往上找父类，绝不会往下找子类</li></ul></li></ol><h1 id="方法覆盖重写"><a href="#方法覆盖重写" class="headerlink" title="方法覆盖重写"></a>方法覆盖重写</h1><p>在子类对父类的方法进行重写，尽量不要修改父类</p><ol><li>保证父类子类方法名称相同，参数列表也相同</li><li>子类方法的权限必须大于等于父类方法的权限修饰符</li><li>public &gt; protected &gt; ( default ) &gt; private<table><thead><tr><th align="center">类型</th><th align="center">public</th><th align="center">protected</th><th align="center">( default )</th><th align="center">private</th></tr></thead><tbody><tr><td align="center">同一个类</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">同一个包</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">不同包子类（继承关系）</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">不同包非子类（非继承关系）</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td><td align="center">no</td></tr></tbody></table></li></ol><h1 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h1><p>加上abstract关键字，然后去掉大括号，代表一种行为，但具体怎么做不确定<br><code> public abstract void method();</code><br>例如父类定义一个动物吃东西的抽象方法，在子类分成狗和猫对这个抽象方法分别进行具体的描述<br><strong>抽象方法所在的类必须是抽象类</strong>，在class前写上abstract</p><ul><li>不能直接使用new抽象类对象</li><li>必须用一个子类继承抽象父类</li><li>子类必须覆盖重写抽象父类<strong>所有</strong>的抽象方法</li><li>创建子类对象进行使用</li></ul><h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><ol><li><p>对于局部变量 name</p><ul><li>使用本类的成员变量 this.name</li><li>使用父类的成员变量 super.name<br>同理成员方法</li></ul></li><li><p>调用父类的成员方法 super.method();<br>调用父类的构造方法 super()<br>super调用父类的函数，省去重复代码</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/2021/08/02/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/08/02/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>接口就是一种公共的规范标准，只要符合标准，就可以大家共用 （插电接口）</p><h1 id="接口的实现"><a href="#接口的实现" class="headerlink" title="接口的实现"></a>接口的实现</h1><p> 一个接口Interface的格式:  public <strong>interface</strong> 接口名称{}</p><ul><li>接口可以有抽象方法，默认方法，静态方法，私有方法</li><li>接口不能直接使用，必须有一个实现类来实现该接口</li></ul><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><p>接口定义”成员变量“ 从效果上看就是接口的常量<br>格式: <code>public static final 数据类型 变量名称</code></p><ul><li>一旦使用final说明不可改变</li><li>可以省略 public static final。但不写效果相同</li><li>接口常量必须进行赋值,且常量的名称使用完全大写的字母，用下划线进行分割(推荐命名)</li></ul><h1 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h1><p><code>public class 实现类名称 implements 接口名称&#123;&#125;</code></p><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p>接口的所有抽象方法必须覆盖重写，可以B实现A的一部分抽象方法，接着C实现B剩下的抽象方法，此时A和B都是抽象的</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>默认方法的定义 <code>public default void 默认方法名称()&#123;&#125;</code><br>接口添加默认方法，实现类不会报错，但添加抽象方法会出现报错</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>default换成static<br>不能通过<strong>接口实现类的对象</strong>来调用接口当中的静态方法<br>正确用法: 接口名称.静态方法</p><h2 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h2><p> private方法只有接口自己可以调用，不能被实现类或别人调用</p><ul><li>private 方法名称(){}</li><li>private static 名字(){}</li></ul><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>一个类的父类唯一，但接口不唯一</li><li>一个类如果父类的方法和接口中的默认方法产生了冲突，优先使用父类当中的方法<br><code>public class Zi extends Fu implements Interface&#123;&#125;</code></li><li>接口是多继承的(extends) <code>public interface MyInterfaceC extends MyInterfaceA,MyInterfaceB</code><br> 若多继承的父类出现重名的默认函数，一定要进行覆写override</li></ol>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2021/08/02/%E5%A4%9A%E6%80%81/"/>
      <url>/2021/08/02/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><p>多态 保证等号左边不会变动<br>小明这个对象，既有学生形态，又是人类形态。一个对象拥有多种形态，就是对象的多态性<br>体现多态性 父类引用指向子类对象</p><h1 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h1><ol><li>父类名称 对象名 = new 子类名称（）</li><li>接口名称 对象名 = new 实现类名称（）</li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><blockquote><ol><li>调用成员变量<blockquote><ul><li>直接通过对象名称访问成员变量，等号左边是谁就优先用谁，没有则向上找</li><li>间接通过成员方法访问成员变量，该方法属于谁就优先用谁，没有则向上找</li></ul></blockquote></li><li>成员方法的访问规则<blockquote><ul><li>看new的是谁就优先用谁，没有则向上找</li><li>编译看左边，运行看右边（编译的时候，该方法父类必须有，运行的时候优先用子类）<blockquote><ul><li>父子都有，优先用子</li><li>子类没有，父类有，向上找到父类</li><li>子类有，父类没有，报错，因为编译时父类没有该方法<br>为调用子类方法需要向下转型： 子类 子类对象名 = （子类） 父类对象名    instanceof用法</li></ul></blockquote></li></ul></blockquote></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList集合</title>
      <link href="/2021/07/26/ArrayList/"/>
      <url>/2021/07/26/ArrayList/</url>
      
        <content type="html"><![CDATA[<h1 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h1><p>ArrayList是一个类，这个类建立的Array没有固定的大小限制，可以在程序运行中不断地添加元素</p><h1 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h1><p> 如 <code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;()</code></p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><p><code>list.add(abc)</code>   往list末尾添加元素abc<br><code>list.get(0)</code>     获取list第一个位置的元素<br><code>list.remove(0)</code>  删除list第一个位置的元素，并返回这个元素的值<br><code>list.size()</code>     返回list的长度</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>ArrayList 的泛型只能是引用类型（如String），不能是基本类（如下的byte等）<br>想要使用基本类的话必须使用对应的包装类</p><table><thead><tr><th align="center">基本类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center">int</td><td align="center">Integer</td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">char</td><td align="center">Character</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr></tbody></table><hr><p><em>Markdown想要在网页中表格显示，‘ | ’前必须有空格</em></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类与对象</title>
      <link href="/2021/07/21/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/2021/07/21/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>面向过程就是人亲自手洗衣服，面向对象就是人用洗衣机洗衣服，对象就是洗衣机</p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>由类到对象，类不能直接使用，需要根据类来创建对象，通过对象才能使用<br>类就是手机图纸，对象就是手机，对象通过调用类的成员变量和成员函数等来调用类</p><h1 id="一个标准的类"><a href="#一个标准的类" class="headerlink" title="一个标准的类"></a>一个标准的类</h1><p>定义一个标准的类（标准的类也叫做Java bean）</p><ol><li>所有的成员变量<strong>都</strong>要用private关键字修饰, <strong>private设置后，对象无法直接调用变量，但可以通过类的函数(get,set等)进行间接调用</strong></li><li>为每个成员变量编写一对get、set方法</li><li>编写一个无参数的构造方法, <strong>构造方法就是在创建对象new的时候就会执行</strong></li><li>编写一个有参数的构造方法, 构造方法也是可以进行重载的</li><li>成员变量和局部变量同名时, 用this.来调用成员变量</li><li>构造方法的命名规则 public 类名 (){}</li></ol><p><strong>任何类和接口都可以成为成员变量</strong></p><h1 id="对象建立"><a href="#对象建立" class="headerlink" title="对象建立"></a>对象建立</h1><p>自建的类名 对象名 = new 自建的类名（）</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA快捷建</title>
      <link href="/2021/07/16/IDEA%E5%BF%AB%E6%8D%B7%E5%BB%BA/"/>
      <url>/2021/07/16/IDEA%E5%BF%AB%E6%8D%B7%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><img style="width:800px" src="https://ftp.bmp.ovh/imgs/2021/07/c7b4af4f9027d8ae.png">  <ol><li><p>替换变量名称 </p><ul><li>ctrl+R    选择替换变量，可以替换所有的</li><li>shift+F6  替换选中变量，有时候可以替换所有的，有时候替换一部分（没搞懂</li></ul></li><li><p>提示显示 alt+/<br>定义类的时候插入toString等方法 alt+Insert<br>转到定义位置 Ctrl+B</p></li><li><ul><li>5.fori 自动形成数目为5的for循环</li><li>array.fori 自动形成数目为array长度的for循环</li><li>array.forr 自动形成数目为array长度的倒叙for循环</li><li>array.for 增强for循环（详见Collection集合）</li></ul></li><li><p>crtl+Z 撤回      ctrl+shift+z 恢复撤回</p></li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><p>javadoc注释方法<br> /**<br> *<br> */</p></li><li><p>在方法中使用数组的时候<br>数组作为参数 <code>public static void method(int[] array )&#123;&#125;</code><br>数组作为返回值 <code>public static int[] method(int a, int b)&#123;&#125;</code><br><em><strong>void是方法无返回值时候的选择，如打印输出</strong></em></p></li><li><p>IDEA中 project–module–package–class</p></li><li><p>int+string会发生转义，如果在sout中不想发生转义需要将字符串用””框住，’’不行<br>‘’代表的是字符，与int在一起会发成转义，变成对应的ASCII码，+号得到的最终是数字<br>“”代表的是字符串，不会转义，通过+号会直接合成一个新的字符串<br>字符可以和int进行大小比较，+，&lt;=, &gt;=等，例如 <code>if(&#39;A&#39; &lt;= 100)&#123;&#125;</code></p></li><li><p>打印对象名，输出的不是地址，说明该对象的类中重写了toString方法</p></li><li><p>静态方法不建议创建对象使用，应该 类名.方法名 使用</p></li><li><p>数组调用参数a[0], 集合Arraylist调用参数 <code>list.get(0)</code></p></li><li><p>a == b ， 比较的是地址值<br><code>a.equals(b)</code>在没有重写的情况下比较的也是地址，如果在类定义的时候进行重写，可以进行值的比较</p></li></ol><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.13 记</title>
      <link href="/2021/05/13/5-13-%E8%AE%B0/"/>
      <url>/2021/05/13/5-13-%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="修改意见"><a href="#修改意见" class="headerlink" title="修改意见"></a>修改意见</h1><p>1 摘要修改，原先内容基本<strong>一句到底</strong>，分成几句话进行分析</p><p>2 将二三段合并，合成一个5G异构网络模型，增加一章对神经网络和深度学习进行介绍</p><p>3 仿真结果图不够丰富，增加仿真结果，增加仿真参数</p><p>4 仿真结果有问题，一些图横纵坐标有问题，一些图不收敛</p><p>5 <strong>论文一般是以第三人称进行描述</strong>，少用<em>我们，我</em>，可以用本文，本研究，研究中等，文字应避免口语化，体现专业性</p><p>6 整理行文逻辑</p><h1 id="完成情况"><a href="#完成情况" class="headerlink" title="完成情况"></a>完成情况</h1><p>1 摘要修改完成，二三段合并完成，并对公式和图的标号进行修改，增加了一章的内容，介绍了深度强化学习</p><p>2 因为DQN神经网络训练的并不成功，仿真结果一直不好，尝试着增加了几张图，但<strong>很不理想</strong>，后期再想办法进行修改看看能不能过关</p><p>3 仿真图修改完成，不收敛的图删除不要</p><p>4 第三人称和行文逻辑问题还没有修改，仿真参数也没有添加</p><h1 id="模型问题"><a href="#模型问题" class="headerlink" title="模型问题"></a>模型问题</h1><p>想了想，我是只把最后一个时隙的状态输入到了神经网络中，应该输入最后的多个时隙状态，这样子的效果会更好，但现在已经很难修改代码结构（这部分的代码很难修改，要是修改会影响很多的部分）</p><p>用户太少的问题，我尝试建立一个函数增加用户数量，但运行时间极大幅度增加，还不停报错，放弃，后续有机会进行进一步的修改</p><p>D2D与UE的0距离接触导致的干扰激增问题暂时无法解决，后续看论文整理下思路</p><h1 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h1><p>脑壳疼，真的不想改，出优秀毕设的意愿也不是很大，但是导师看我论文比我自己都认真，实在是不改不合适，尽量15号之前修改完毕吧，希望可以稳妥毕业<br><img style="width:300px" src="https://ftp.bmp.ovh/imgs/2021/05/fcfcb3c542b97e1b.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇</title>
      <link href="/2021/05/10/2021%E5%B9%B45%E6%9C%8810%E6%97%A5/"/>
      <url>/2021/05/10/2021%E5%B9%B45%E6%9C%8810%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<p>首先感谢Vychod（lc，可以在友链里看见他）的博客制作帮助，根本不知道想要一个自己的博客该怎么开始比较好，你是个好人。</p><p>要成为研究生了，为了以后可以找到一个好工作和不被导师嫌弃想学习一些有用的技能，打算把自己刷力扣算法的一些思路和学习编程的遇到注意点写在自己的博客上，争取做个有用的人。</p><p>也许还会更新更新日记日常什么的，嘻嘻</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
